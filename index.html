<html lang="pt-BR"><head>
  <meta charset="utf-8">
  <title>DUAL // FUSION OS — V8 (Reactive Core)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  <link rel="manifest" href="./manifest.json">
  <meta name="theme-color" content="#05070a">
  <link rel="apple-touch-icon" href="./icon-192.png">

  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@200;400;600;900&amp;family=JetBrains+Mono:wght@400;700&amp;display=swap" rel="stylesheet">
  <script src="https://unpkg.com/lucide@latest"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>

<style id="UNIFIED_STYLE">
/* ========== UNIFIED ROOT / GLOBAL VARIABLES ========== */
:root{
  /* Colors & accents */
  --bg-deep: #030406;
  --bg-gradient: linear-gradient(180deg,#000,#111);
  --bg: var(--bg-gradient);
  --text: #d7d7d7;
  --neon-cyan: #00f2ff;
  --neon-purple: #bd00ff;
  --neon-gold: #ffd700;
  --neon-danger: #ff2a6d;
  --neon-success: #00ff9d;

  /* UI fonts */
  --font-ui: 'Montserrat', sans-serif;
  --font-code: 'JetBrains Mono', monospace;

  /* Glass / card */
  --glass-surface: rgba(18,18,22,0.65);
  --glass-border: rgba(255,255,255,0.06);
  --card-bg: rgba(255,255,255,0.03);
  --glass: rgba(255,255,255,0.04);

  /* Gradients used by chips/list markers */
  --grad-a: #7effa1;
  --grad-b: #67e6ff;

  /* misc helper variables referenced in components */
  --panel: #0e1220;
  --ink: #e8ecf6;
  --txt-card: color-mix(in oklab, var(--panel) 92%, black);
  --chip-bg: linear-gradient(42deg, var(--grad-a), var(--grad-b));

  /* Timings & easings */
  --ease-overshoot: cubic-bezier(0.34, 1.3, 0.64, 1);
  --ease-smooth: cubic-bezier(0.23, 1, 0.32, 1);
  --fast: .25s; --med: .6s; --slow: 1.2s;

  /* z-index helpers */
  --z-base: 0;
  --z-content: 100;
  --z-widget: 500;
  --z-overlay: 1000;
  --z-system: 5000;
}

/* ========== RESET / BASE ========== */
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent;outline:none;user-select:none}
html,body{height:100%;margin:0;font-family:var(--font-ui),system-ui,-apple-system; background:var(--bg); color:var(--text); -webkit-font-smoothing:antialiased}
.activation-pre, .cyber-input, input, textarea, .toaster, .response-block p { user-select:text !important; -webkit-user-select:text !important; }

/* subtle grid background */
body{
  min-height:100vh;
  overflow:hidden;
  background-image:
    linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
  background-size:52px 52px;
  background-position:center;
}

/* ========== NEW REACTIVE ANIMATIONS ========== */
@keyframes softPulse {
    0% { filter: brightness(1); text-shadow: 0 0 0 transparent; transform:translate(-50%, -50%) scale(1); }
    50% { filter: brightness(1.4); text-shadow: 0 0 10px var(--neon-cyan); transform:translate(-50%, -50%) scale(1.02); }
    100% { filter: brightness(1); text-shadow: 0 0 0 transparent; transform:translate(-50%, -50%) scale(1); }
}
.pulse-update {
    animation: softPulse 0.4s ease-out forwards;
}

/* ========== AMBIENT BLOBS ========== */
.ambient-light{position:fixed;inset:0;z-index:var(--z-base);pointer-events:none}
.blob{position:absolute;border-radius:50%;filter:blur(100px);opacity:0.14;animation:float 25s infinite alternate ease-in-out}
.blob-1{width:60vw;height:60vw;background:var(--neon-cyan);top:-20%;left:-20%}
.blob-2{width:50vw;height:50vw;background:var(--neon-purple);bottom:-20%;right:-20%;animation-delay:-5s}

/* ========== KEYFRAMES ========== */
@keyframes float{0%{transform:translate(0,0)}100%{transform:translate(40px,60px)}}
@keyframes gradientFlow{0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%}}
@keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.02)}}
@keyframes fadeIn{from{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}
@keyframes clickPulse{0%,100%{opacity:1}50%{opacity:0.8}}

/* ========== SNAP ZONE ========== */
#snap-zone {
  position: fixed; top: 0; left: 0; right: 0; height: 80px;
  background: linear-gradient(to bottom, rgba(0, 242, 255, 0.25), transparent);
  opacity: 0; pointer-events: none; transition: opacity 0.3s ease; z-index:9000;
  box-shadow: 0 0 40px rgba(0, 242, 255, 0.1);
}
#snap-zone.active{opacity:1}

/* ========== CENTRAL CONTAINER & FUSION CARD ========== */
.container{position:absolute;inset:0;pointer-events:none;display:flex;align-items:center;justify-content:center;perspective:1200px;z-index:10}
.fusion-card{
  pointer-events:auto;
  width:100%; max-width:440px;
  max-height:85vh; overflow-y:auto; overflow-x:hidden;
  background:var(--glass-surface); backdrop-filter:blur(30px); -webkit-backdrop-filter:blur(30px);
  border:1px solid var(--glass-border); border-radius:36px; padding:30px 25px;
  box-shadow:0 40px 100px rgba(0,0,0,0.8);
  position:relative; opacity:0; transform:translateY(50px) scale(0.96);
  display:flex; flex-direction:column; gap:8px;
  transition: width 0.5s var(--ease-smooth), height 0.5s var(--ease-smooth), border-radius 0.5s var(--ease-smooth), opacity 0.4s, left 0.4s var(--ease-smooth), top 0.4s var(--ease-smooth), box-shadow 0.4s;
  will-change: transform, width, height, border-radius, left, top;
  touch-action: pan-y;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
  scrollbar-width: none;
}
.fusion-card::-webkit-scrollbar{display:none}
.fusion-card.active{opacity:1;transform:translateY(0) scale(1)}
.fusion-card.closed{width:260px;padding:14px 16px;border-radius:22px}
.fusion-card.closed .card-body{display:none}

/* ========== ORB STATE ========== */
.fusion-card.orb{
  position:fixed !important;
  width:68px !important;height:68px !important;
  padding:0 !important;border-radius:50% !important;
  align-items:center;justify-content:center;
  box-shadow:0 15px 40px rgba(0,0,0,0.6), 0 0 20px rgba(0,242,255,0.2);
  z-index:9999; cursor:grab; touch-action:none; overflow:visible;
}
.fusion-card.orb:active{cursor:grabbing;transform:scale(0.95)}
.fusion-card.orb .text-block, .fusion-card.orb .clock-widget, .fusion-card.orb .card-body, .fusion-card.orb .small-preview{display:none !important}
.fusion-card.orb .card-header{margin:0;width:100%;height:100%;justify-content:center;padding:0}
.fusion-card.orb .avatar-slot{width:54px;height:54px;border-radius:50%;margin:0;opacity:1;pointer-events:none}

/* orb quick menu */
.orb-menu-trigger{
  position:absolute;bottom:-30px;left:50%;transform:translateX(-50%);
  width:24px;height:24px;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.2);
  border-radius:50%;display:none;align-items:center;justify-content:center;cursor:pointer;
  color:#fff;font-size:12px;pointer-events:auto;backdrop-filter:blur(4px);
}
.fusion-card.orb:hover .orb-menu-trigger{display:flex}

/* ========== HUD STATE ========== */
.fusion-card.hud{
  position:fixed !important; top:0 !important; left:50% !important;
  transform:translateX(-50%) !important;
  width:96% !important; max-width:600px !important; height:64px !important;
  padding:0 16px !important; border-radius:0 0 24px 24px !important;
  flex-direction:row; align-items:center; justify-content:space-between;
  box-shadow:0 10px 40px rgba(0,0,0,0.7); z-index:9999; overflow:visible;
  border-top:none; opacity:0.78; touch-action:none;
}
.fusion-card.hud .card-body, .fusion-card.hud .small-preview{display:none !important}
.fusion-card.hud .card-header{margin:0;width:100%;justify-content:space-between}
.fusion-card.hud .avatar-slot{width:40px;height:40px}
.fusion-card.hud .brand-dual{font-size:1.2rem;margin:0}
.fusion-card.hud .greeting-row{display:none}
.fusion-card.hud .text-block{flex:unset}

/* drag handle for hud */
.drag-handle{
  width:60px;height:5px;background:rgba(255,255,255,0.15);border-radius:10px;
  position:absolute;bottom:8px;left:50%;transform:translateX(-50%);display:none;cursor:grab;pointer-events:none;
  transition:background 0.3s;
}
.fusion-card.hud:active .drag-handle{background:var(--neon-cyan);width:70px}
.fusion-card.hud .drag-handle{display:block}

/* hud menu btn */
.hud-menu-btn{display:none;background:transparent;border:none;color:rgba(255,255,255,0.6);cursor:pointer}
.fusion-card.hud .hud-menu-btn{display:block}

/* ========== HEADER / AVATAR / TEXT BLOCKS ========== */
.card-header{display:flex;align-items:center;gap:15px;margin-bottom:18px;width:100%;cursor:pointer;touch-action:none}
.avatar-slot{width:64px;height:64px;border-radius:18px;overflow:hidden;opacity:0;transition:opacity 0.35s}
.avatar-slot.shown{opacity:1}
.text-block{flex:1;display:flex;flex-direction:column;justify-content:center}
.greeting-row{font-size:1.5rem;line-height:1;display:flex;align-items:baseline;gap:6px;flex-wrap:wrap}
.txt-thin{font-weight:200;color:rgba(255,255,255,0.7)}
.txt-heavy{font-weight:600;color:#fff}

/* brand gradient */
.brand-dual{
  font-size:2.2rem;font-weight:900;line-height:0.95;text-transform:uppercase;letter-spacing:-2px;margin-top:4px;
  background:linear-gradient(-45deg,#fff,var(--neon-cyan),var(--neon-purple),#fff);
  background-size:300%;-webkit-background-clip:text;-webkit-text-fill-color:transparent;animation:gradientFlow 4s ease infinite;
}

/* clock & status */
.clock-widget{text-align:right}
.time-display{font-family:var(--font-code);font-size:1rem;color:rgba(255,255,255,0.5);font-weight:700}
.status-led{font-size:0.6rem;color:var(--neon-cyan);text-transform:uppercase;letter-spacing:1px;margin-top:4px;display:block}

/* ========== SMALL PREVIEW / COLLAPSE ========== */
.small-preview{display:none;align-items:center;gap:10px;margin-top:8px;padding:8px 10px;border-radius:10px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);font-family:var(--font-code);font-size:0.86rem;color:rgba(255,255,255,0.9);cursor:pointer}
.small-preview .mini-avatar{width:30px;height:30px;border-radius:6px;flex-shrink:0;overflow:hidden;display:inline-flex;align-items:center;justify-content:center}
.small-preview .small-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:calc(100% - 110px)}
.small-preview .ident-badge{margin-left:auto;font-weight:700;font-size:0.78rem;padding:4px 8px;border-radius:999px;background:rgba(255,255,255,0.03);color:rgba(255,255,255,0.9);border:1px solid rgba(255,255,255,0.02)}
.fusion-card.closed:not(.orb):not(.hud) .small-preview{display:flex}

/* card body & stagger reveal */
.card-body{display:flex;flex-direction:column;gap:12px}
.stagger-item{opacity:0;transform:translateY(15px);transition:opacity 0.4s ease, transform 0.4s var(--ease-overshoot)}
.content-visible .stagger-item{opacity:1;transform:translateY(0)}
.content-visible .stagger-item:nth-child(1){transition-delay:0.1s}
.content-visible .stagger-item:nth-child(2){transition-delay:0.18s}
.content-visible .stagger-item:nth-child(3){transition-delay:0.25s}
.content-visible .stagger-item:nth-child(4){transition-delay:0.30s}

/* ========== INPUTS / TOASTERS / MODALS / PANELS ========== */
.cyber-input{width:100%;background:rgba(0,0,0,0.3);border:1px solid rgba(255,255,255,0.1);border-radius:16px;padding:16px 50px 16px 18px;color:#fff;font-family:var(--font-code);font-size:0.9rem}
.toaster-wrap{position:fixed;right:20px;bottom:20px;z-index:99999;display:flex;flex-direction:column;gap:8px;pointer-events:none}
.toaster{pointer-events:auto;background:linear-gradient(180deg,#0b1220,#071018);border:1px solid rgba(255,255,255,0.06);padding:10px 14px;border-radius:10px;box-shadow:0 18px 40px rgba(0,0,0,0.6);font-family:var(--font-ui);font-size:0.95rem;opacity:0;transform:translateY(8px);transition:all 260ms var(--ease-smooth)}
.toaster.show{opacity:1;transform:translateY(0)}
.toaster.error{border-color:var(--neon-danger);color:var(--neon-danger)}
.toaster.success{border-color:var(--neon-success);color:var(--neon-success)}

.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.65);display:none;align-items:center;justify-content:center;z-index:99998;backdrop-filter:blur(8px)}
.keys-card{width:90%;max-width:760px;background:linear-gradient(180deg,#071018,#0b1220);border:1px solid rgba(255,255,255,0.08);padding:20px;border-radius:16px;color:#fff;box-shadow:0 20px 50px rgba(0,0,0,0.8);max-height:90vh;display:flex;flex-direction:column}
.keys-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:15px;padding-bottom:10px;border-bottom:1px solid rgba(255,255,255,0.05)}
.key-list{flex:1;overflow-y:auto;display:flex;flex-direction:column;gap:8px;padding-right:6px;min-height:100px}
.key-item{display:flex;align-items:center;gap:8px;padding:12px;border-radius:10px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02)}
.key-item.active-item{background:rgba(0, 242, 255, 0.05);border-color:rgba(0, 242, 255, 0.2)}
.small-btn{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.1);padding:6px 10px;border-radius:8px;color:#fff;cursor:pointer;font-size:0.75rem;text-transform:uppercase;font-weight:600;transition:0.2s}
.small-btn:hover{background:rgba(255,255,255,0.08);border-color:rgba(255,255,255,0.2)}
.small-btn.active-btn{background:var(--neon-success);color:#000;border:none}
.danger{color:var(--neon-danger);border-color:rgba(255,42,109,0.3)}
.danger:hover{background:rgba(255,42,109,0.1)}

.form-section{margin-top:15px;padding-top:15px;border-top:1px solid rgba(255,255,255,0.05)}
.form-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px}
.form-row{display:flex;gap:8px}
.form-row input, .form-grid input{width:100%;padding:10px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.08);background:#030406;color:#fff;font-family:var(--font-code);font-size:0.85rem}
.form-row input:focus, .form-grid input:focus{border-color:var(--neon-cyan)}

#vaultModal .keys-card{max-width:400px;text-align:center}
.vault-icon{width:50px;height:50px;margin:0 auto 15px;color:var(--neon-purple);background:rgba(189,0,255,0.1);border-radius:50%;display:flex;align-items:center;justify-content:center}

/* ========== CHAT / SVG / PARTICLES / TOP INFO ========== */
#particles-js{position:absolute;inset:0;z-index:12; pointer-events:none}
.svg-container{position:absolute;top:35%;left:50%;transform:translate(-50%,-50%);width:160px;height:160px;z-index:-1; pointer-events:none}
.svg-container object{width:100%;height:100%}
.top-info{position:fixed;top:28px;left:50%;transform:translate(-50%,-50%);z-index:3;background:rgba(0,0,0,0.35);padding:8px 12px;border-radius:12px;font-size:0.69em;backdrop-filter:blur(6px);pointer-events:none; cursor:pointer;}

/* ========== RESPONSE AREA ========== */
.response-container{
  position:fixed; left:20px; right:20px; bottom:160px;
  padding:12px;background:rgba(0,0,0,0.4);backdrop-filter:blur(10px);
  border-radius:20px; max-height:calc(100vh - 220px); overflow-y:auto; -webkit-overflow-scrolling:touch; z-index:1;
}
.page{display:none; opacity:0; transition:opacity 0.8s ease-in-out}
.page.active{display:block; opacity:1}
.page.initial{text-align:center;font-size:1.1em}
.response-controls{display:flex;justify-content:space-between;align-items:center;margin-top:15px;padding-top:10px;border-top:1px solid rgba(255,255,255,0.2)}
.control-buttons{display:flex;gap:10px;align-items:center}
.control-btn{background:rgba(255,255,255,0.05);padding:6px;border-radius:6px;cursor:pointer;transition:background 0.4s;display:flex;gap:6px;border:none;outline:none}
.control-btn:hover{background:rgba(255,255,255,0.12)}
.control-btn svg{stroke:rgba(255,255,255,0.5);fill:none}

/* toggles & pagination */
.toggle-button svg{color:#fff;stroke:rgba(255,255,255,0.3);fill:none; transition: all 0.3s}
.toggle-button.active svg{stroke:var(--neon-success); filter: drop-shadow(0 0 5px var(--neon-success))}
.toggle-button.error svg{stroke:var(--neon-danger); filter: drop-shadow(0 0 5px var(--neon-danger))}
.pagination{display:flex;align-items:center;gap:10px}
.pagination button{background:none;border:none;font-size:1.2em;color:#6fe4fb;cursor:pointer;transition:transform 0.4s}
.pagination button:hover{transform:scale(1.2)}

/* ========== RESPONSE BLOCKS ========== */
.response-block{
  margin:1rem 0;padding:1.2rem;border-radius:12px;
  animation:fadeIn 1.8s ease forwards; transition:box-shadow 0.4s,transform 0.4s;
  line-height:1.5;position:relative;cursor:pointer;overflow:hidden;animation:pulse 6s infinite ease-in-out;
  background: linear-gradient(135deg, rgba(255,255,255,0.02), rgba(0,0,0,0.25));
  border: 1px solid rgba(255,255,255,0.03);
}
.response-block h3{margin-bottom:12px}
.response-block:hover{box-shadow:0 0 15px rgba(0,255,255,0.12)}
.response-block .meta{position:absolute;top:8px;right:8px;display:flex;gap:6px}
.crystal-btn{background:rgba(0,0,0,0.25);border-radius:6px;padding:6px;cursor:pointer;border:none;color:var(--neon-cyan)}
.response-block.clicked{animation:clickPulse 0.8s ease-out}
.response-block.expanded{transform:scale(1.03); background:rgba(0,0,0,0.6); z-index:2}
.intro{background:linear-gradient(135deg,rgba(0,255,255,0.08),rgba(0,100,100,0.04));border-left:4px solid #0ff}
.middle{background:linear-gradient(135deg,rgba(255,255,255,0.02),rgba(50,50,50,0.06));border-left:4px solid rgba(255,255,255,0.2)}
.ending{background:linear-gradient(135deg,rgba(255,0,255,0.06),rgba(100,0,100,0.04));border-left:4px solid #f0f}
.footer-text{margin-top:12px;font-size:0.78em;text-align:center;font-style:italic}

/* ========== INPUT CONTAINER (bottom) ========== */
.input-container{position:fixed;left:20px;right:20px;bottom:90px;display:flex;gap:10px;z-index:2;max-width:calc(100% - 40px)}
.input-container input{flex:1;padding:10px;border:none;border-radius:20px;background:rgba(255,255,255,0.1);color:inherit;outline:none;font-size:16px;transition:background 0.4s}
.input-container input:focus{background:rgba(255,255,255,0.2)}
.input-container button{width:60px;height:60px;border:none;border-radius:50%;background:linear-gradient(45deg,#111,#5e5c5e);color:#fff;font-size:1.5em;cursor:pointer;display:flex;justify-content:center;align-items:center;animation:pulse 2s infinite ease-in-out;transition:transform 0.4s}
.input-container button:hover{transform:scale(1.1)}

/* ========== GENERIC MODAL / PANEL / BOX ========== */
.modal, .panel { position: fixed; inset: 0; display: none; z-index: 9998; justify-content:center; align-items:center; }
.modal.active, .panel.active { display:flex }
.box{ background:#1a1a1a;padding:20px;border-radius:12px;border:1px solid rgba(255,255,255,0.06); width:90%;max-width:520px;box-shadow:0 8px 40px rgba(0,0,0,0.6); color:#fff; }
.box h3{color:var(--neon-cyan);margin-bottom:8px}
.row{display:flex;gap:10px;align-items:center}
.col{display:flex;flex-direction:column;gap:8px}
.input-group label{font-size:0.85em;color:#aaa;margin-left:4px}
.input-group input[type="text"], .input-group input[type="password"], .input-group input[type="file"]{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.08);background:rgba(0,0,0,0.5);color:#fff;outline:none}
.settings-actions{display:flex;gap:10px;margin-top:12px}
.btn{padding:10px;border-radius:8px;border:none;cursor:pointer;font-weight:600}
.btn-prim{background:var(--neon-cyan);color:#000}
.btn-sec{background:rgba(255,255,255,0.08);color:#fff}
.small{font-size:0.85em;color:#bbb}
.crystal-list{max-height:300px;overflow:auto;display:flex;flex-direction:column;gap:8px}
.crystal-item{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;display:flex;justify-content:space-between;gap:8px;align-items:flex-start}
.crystal-item .actions{display:flex;gap:6px}

/* ========== KEYS / DECODER / PULSOS ========== */
#decoderBox{position:fixed;left:50%;top:18%;transform:translateX(-50%);background:rgba(0,0,0,0.8);padding:12px;border-radius:12px;backdrop-filter:blur(6px);z-index:90;display:none}
#decoderBox input{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--text)}
#pulsos-container{position:fixed;left:50%;top:18%;transform:translateX(-50%);max-width:640px;width:78%;z-index:-1;pointer-events:none}
#pulsos{pointer-events:auto;background:rgba(0,0,0,0.45);padding:8px;border-radius:10px;max-height:220px;overflow:auto;color:var(--neon-cyan);font-family:monospace}

/* ========== FOOTER MANTRA & LOCK BUTTON ========== */
#mantra-toggle{
  position:fixed;bottom:54px;left:50%;transform:translateX(-50%);z-index:9781;background:rgba(15,15,15,0.4);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.06);padding:3px 8px;border-radius:100px;cursor:pointer;display:flex;align-items:center;justify-content:center;box-shadow:0 10px 40px rgba(0,0,0,0.6);transition:all 0.6s cubic-bezier(0.16, 1, 0.3, 1);min-width:220px;
}
#mantra-toggle:hover{background:rgba(25,25,25,0.9);border-color:rgba(255,255,255,0.15);transform:translateX(-50%) translateY(-2px)}
#mantra-text{font-style:italic;color:#777;font-size:0.78rem;white-space:nowrap;transition:all 0.4s ease}
#mantra-toggle.collapsed{background:transparent;border-color:rgba(255,215,0,0.3);box-shadow:0 0 20px rgba(255,215,0,0.05)}

.lock-button{
  position:fixed;bottom:21px;left:50%;transform:translateX(-50%);width:24px;height:24px;background:transparent;border:1px solid rgba(255,255,255,0.5);border-radius:50%;cursor:pointer;display:flex;align-items:center;justify-content:center;backdrop-filter:blur(4px);transition:background 0.3s ease,border-color 0.3s ease;z-index:12;
}
.lock-button:hover{background:rgba(255,255,255,0.1);border-color:rgba(255,255,255,0.8)}

/* zen-mode */
.fade-out{opacity:0;transform:translateY(5px)}
.fade-in{opacity:1;transform:translateY(0)}
body.zen-mode .response-container, body.zen-mode .input-container, body.zen-mode .top-info, body.zen-mode .svg-container{opacity:0;pointer-events:none;filter:blur(12px);transition:all 0.6s ease}

/* ========== SMALL LAYOUT / UTILITIES ========== */
.activation-wrap{display:flex;flex-direction:column;gap:8px}
.activation-card{background:rgba(0,0,0,0.25);border:1px solid rgba(255,255,255,0.04);padding:12px;border-radius:10px;overflow:hidden;transition:all 320ms var(--ease-smooth)}
.activation-pre{font-family:var(--font-code);white-space:pre-wrap;margin:0;padding:8px;background:rgba(0,0,0,0.12);border-radius:8px;border:1px dashed rgba(255,255,255,0.03);color:#fff;font-size:0.75rem}
.activation-hidden{max-height:0;opacity:0;padding:0 12px;pointer-events:none;margin-top:0}
.activation-open{max-height:567px;opacity:1;padding:12px;margin-top:4px}
.activation-toggle{display:flex;align-items:center;justify-content:space-between;padding:8px 4px;cursor:pointer;opacity:0.9;transition:0.2s}
.activation-toggle:hover{opacity:1}
.trigger-btn{width:100%;padding:12px;border:1px dashed rgba(255,255,255,0.1);border-radius:12px;background:rgba(255,255,255,0.02);color:rgba(255,255,255,0.5);font-size:0.75rem;letter-spacing:2px;text-transform:uppercase;cursor:pointer;display:flex;justify-content:center;align-items:center;gap:8px;transition:0.2s}
.trigger-btn:hover{background:rgba(255,255,255,0.04);color:#fff;border-color:rgba(255,255,255,0.3)}
.mode-btn{background:rgba(0,242,255,0.05);border-color:rgba(0,242,255,0.2);color:var(--neon-cyan)}
.mode-btn:hover{background:rgba(0,242,255,0.15);box-shadow:0 0 15px rgba(0,242,255,0.1)}
.mode-btn.active-mode{background:var(--neon-cyan);color:#000;box-shadow:0 0 20px rgba(0,242,255,0.4);border-color:transparent}

/* stats, progress, symbolbar, list-beauty, ascii */
.stats-grid{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;margin-top:10px}
.stat-box{background:rgba(255,255,255,0.03);border-radius:12px;padding:10px;text-align:center}
.stat-lbl{font-size:0.55rem;text-transform:uppercase;color:rgba(255,255,255,0.4);display:block;margin-bottom:4px}
.stat-val{font-family:var(--font-code);font-size:0.9rem;font-weight:700;color:var(--neon-cyan)}

.progress-container{background:rgba(0,0,0,0.2);padding:12px;border-radius:12px}
.bar-track{height:4px;background:rgba(255,255,255,0.1);border-radius:2px;overflow:hidden;margin:8px 0}
.bar-fill{height:100%;width:0%;background:linear-gradient(90deg,var(--neon-cyan),var(--neon-purple));box-shadow:0 0 10px var(--neon-cyan);transition:width 1.2s ease-out}
.bar-meta{display:flex;justify-content:space-between;font-size:0.6rem;color:rgba(255,255,255,0.4);font-family:var(--font-code)}

/* symbolbar / controls / iframe area */
.wrap{width:100%;height:100%;position:relative;overflow:hidden;display:flex;flex-direction:column}
.content{flex:1;position:relative;display:flex}
iframe#frame{width:100%;height:100%;border:0;transition:opacity .4s;opacity:1}
.symbol-bar{position:fixed;right:8px;top:33%;
  display:flex;flex-direction:column;gap:10px;z-index:60}
.symbol-button{width:28px;height:28px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:var(--card-bg);color:var(--text);display:flex;align-items:center;justify-content:center;cursor:pointer;backdrop-filter:blur(6px)}
.symbol-button:hover{transform:scale(1.06);box-shadow:0 6px 18px rgba(0,0,0,0.4)}
.controls{position:fixed;left:16px;top:120px;display:flex;flex-direction:column;gap:10px;z-index:60}
.btn{padding:8px 10px;border-radius:8px;background:var(--glass);border:1px solid rgba(255,255,255,0.06);cursor:pointer;color:var(--text)}
#decoderBox{display:none}

/* footer / pulsos / responsive */
.footer{position:fixed;left:20px;right:20px;bottom:12px;text-align:center;z-index:60;color:rgba(215,215,215,0.7);font-size:0.9em}
@media (max-width:600px){
  .symbol-bar{right:9px;top:56%}
  .controls{left:8px;top:90px}
  #pulsos{max-height:140px}
  .form-grid{grid-template-columns:1fr}
  .keys-card{padding:15px}
  .key-item{flex-direction:column;align-items:flex-start}
  .key-item .actions{width:100%;display:flex;justify-content:flex-end;margin-top:8px}
  .box{max-width:92%}
  .svg-container{width:120px;height:120px}
}

</style>

<style>
        :root {
          --z-base: 0;
          --z-content: 100;
          --z-widget: 500;
          --z-overlay: 1000;
          --z-system: 5000;
        }
      </style><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css"><style>
:root{--grad-a:#ff00ff;--grad-b:#00ffff;--bg:#07080c;--bg2:#0b0e16;--panel:#0e1220;--ink:#e8ecf6;--muted:#a2acc5;--gold:#f7d774;--cyan:#67e6ff;--blur:14px;--radius:18px;--maxw:900px;--pad:20px;--ring:0 0 0 1px rgba(255,255,255,.08) inset,0 0 40px rgba(102,255,255,.08);--glow:0 10px 30px rgba(0,0,0,.35),0 0 80px rgba(0,255,255,.08)}
.theme-gold{--grad-a:#ffd54a;--grad-b:#ff8a00;--cyan:#ffd97a;--gold:#ffe08a;--panel:#12100b;--bg:#0a0906;--ink:#fff6db;--muted:#d3c6a2}
.theme-thermal{--grad-a:#ff7ae6;--grad-b:#ff7a00;--cyan:#ffc29d;--gold:#ffc6f3;--panel:#160e15;--bg:#0b0710;--ink:#ffeefe;--muted:#d4bcd2}
*{box-sizing:border-box}html,body{height:100%;margin:0}body{background:var(--bg);color:var(--ink);font:400 16px/1.65 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow-x:hidden}
.nebula{position:fixed;inset:0;z-index:-1;pointer-events:none;background:radial-gradient(1200px 800px at 20% -10%, color-mix(in oklab, var(--grad-a) 20%, transparent), transparent 60%),radial-gradient(900px 700px at 110% 10%, color-mix(in oklab, var(--grad-b) 18%, transparent), transparent 50%)}
.wrap{max-width:var(--maxw);margin:0 auto;padding:calc(12px + env(safe-area-inset-top)) var(--pad) calc(100px + env(safe-area-inset-bottom))}
details.acc{border-radius:16px;background:linear-gradient(0deg,rgba(255,255,255,.02),rgba(255,255,255,.03)),var(--panel);border:1px solid rgba(255,255,255,.08);box-shadow:var(--glow);margin:14px 0}
summary{display:flex;align-items:center;gap:10px;padding:14px 16px;cursor:pointer}summary::-webkit-details-marker{display:none}.chev{width:10px;height:10px;border-right:2px solid var(--ink);border-bottom:2px solid var(--ink);transform:rotate(-45deg);transition:.2s}details[open] .chev{transform:rotate(45deg)}.sec{padding:0 16px 16px}
blockquote,.equation,.blockcoach{border-radius:12px;padding:12px 14px;margin:12px 0;position:relative}.copy-hint{position:absolute;right:10px;top:10px;font-size:.8rem;opacity:.6}blockquote{border-left:3px solid var(--cyan);background:rgba(255,255,255,.03)}.equation{background:rgba(255,255,255,.03);font-family:ui-monospace,monospace}
#fab{position:fixed;right:14px;bottom:14px;z-index:100;display:flex;flex-direction:column;gap:10px}.fab-btn{width:56px;height:56px;border-radius:50%;border:1px solid rgba(255,255,255,.14);background:linear-gradient(42deg,var(--grad-a),var(--grad-b));color:#000;font-weight:900;font-size:1.2rem;cursor:pointer;box-shadow:var(--ring)}.menu{display:none;position:absolute;right:62px;bottom:0;flex-direction:column;gap:8px}#fab.open .menu{display:flex}.btn{border:1px solid rgba(255,255,255,.14);border-radius:10px;padding:.55rem .8rem;background:linear-gradient(42deg,rgba(255,255,255,.06),rgba(255,255,255,.02));color:var(--ink);cursor:pointer}
#read-exit{position:fixed;top:12px;left:12px;z-index:120;display:none;padding:8px 10px;border-radius:10px;background:linear-gradient(42deg,var(--grad-a),var(--grad-b));color:#000;border:1px solid rgba(255,255,255,.18);cursor:pointer;box-shadow:var(--ring)}.reading #read-exit{display:block}
#imp{position:fixed;inset:0;display:none;z-index:50;background:rgba(0,0,0,.5);backdrop-filter:blur(10px)}.panel{position:absolute;bottom:0;left:0;right:0;background:var(--panel);border-top:1px solid rgba(255,255,255,.1);border-radius:20px 20px 0 0;padding:16px}
.tabs{display:flex;gap:10px;margin-bottom:10px}.tab{flex:1;text-align:center;padding:8px;border-radius:8px;background:rgba(255,255,255,.08);cursor:pointer}.tab.active{background:linear-gradient(42deg,var(--grad-a),var(--grad-b));color:#000;font-weight:700}.tab-content{display:none}.tab-content.active{display:block}
textarea{width:100%;height:160px;border-radius:10px;border:1px solid rgba(255,255,255,.1);background:#0a0e18;color:var(--ink);padding:12px}
#toasts{position:fixed;bottom:16px;left:50%;transform:translateX(-50%);display:flex;flex-direction:column;gap:6px;z-index:99}.toast{background:rgba(0,0,0,.7);color:#fff;padding:10px 14px;border-radius:10px;animation:fade 2s forwards}
@page{size:A4;margin:18mm}@media print{#fab,#imp,#toasts,.copy-hint,#read-exit{display:none!important}body{background:#fff;color:#000}details.acc{background:#fff;border-color:#ddd;box-shadow:none}}
.reading body{font-size:18px;line-height:1.85}.reading .wrap{max-width:780px;padding:20px 18px}.reading #fab,.reading #imp,.reading #toasts,.reading .copy-hint{display:none!important}


/* === Markdown+ blocks === */
pre.md-code{position:relative;background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.08);
  padding:12px 14px;border-radius:12px;overflow:auto;font:500 13px/1.5 ui-monospace,SFMono-Regular,Consolas,monospace;margin:12px 0}
pre.md-code .copy-hint{position:absolute;right:10px;top:10px;font-size:.8rem;opacity:.6}
code.code-inline{background:rgba(255,255,255,.06);padding:.1rem .3rem;border-radius:6px}

table.md-table{width:100%;border-collapse:collapse;margin:12px 0;border-radius:12px;overflow:hidden}
table.md-table th,table.md-table td{border:1px solid rgba(255,255,255,.12);padding:8px 10px;vertical-align:top}
table.md-table th{background:rgba(255,255,255,.06);font-weight:700}

ul.md-list,ol.md-list{padding-left:1.1rem;margin:10px 0}
ul.md-task{list-style:none;padding-left:0}
ul.md-task li{display:flex;gap:.5rem;align-items:flex-start;margin:6px 0}
ul.md-task input[type=checkbox]{accent-color:var(--cyan);pointer-events:none}

.callout{border-left:3px solid var(--cyan);background:rgba(255,255,255,.03);border-radius:12px;padding:12px;margin:12px 0}
.callout.warn{border-color:#ffda7a}
.callout.tip{border-color:#9ff7b9}

.hr{height:1px;border:0;background:linear-gradient(90deg,transparent,rgba(255,255,255,.2),transparent);margin:16px 0}
img.md-img{max-width:100%;display:block;margin:10px auto;border-radius:12px}
.kbd{font:600 12px ui-monospace,monospace;background:rgba(255,255,255,.06);padding:.1rem .35rem;border-radius:6px;border:1px solid rgba(255,255,255,.12)}


/* === PATCH EQ/QUOTE/FN === */
.equation{white-space:pre-wrap}
blockquote.bq{border-left:3px solid var(--cyan);background:rgba(255,255,255,.03);
  border-radius:12px;padding:10px 12px;margin:12px 0;position:relative}
blockquote.bq .bq-line{margin:6px 0}
blockquote.bq-l2{border-left-width:6px;opacity:.96}
blockquote.bq-l3{border-left-width:9px;opacity:.92}
.callout.note{border-left:3px solid #7ad0ff}
.callout.aside{border-left:3px solid var(--muted)}
.callout.success{border-left:3px solid #9ff7b9}
.callout.danger{border-left:3px solid #ff9f9f}
.callout.question{border-left:3px solid #b7a6ff}


/* === Welcome panel & inputs === */
.welcome{border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.03);
  border-radius:14px;padding:12px;margin:12px 0}
.welcome .row{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
.field{width:min(360px,100%);border:1px solid rgba(255,255,255,.12);background:#0a0e18;
  color:var(--ink);border-radius:10px;padding:8px 10px}
.small{font-size:.9rem;color:var(--muted)}
.equation{white-space:pre-wrap}


/* === Master Block (Topo do Documento) === */
.master-block{border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.03);
  border-radius:12px;padding:12px;margin:12px 0}
.master-block .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.master-block .title{flex:1;min-width:200px;border:1px solid rgba(255,255,255,.12);
  background:#0a0e18;color:var(--ink);border-radius:10px;padding:8px 10px}

/* === Stacks (Home) === */
.stack-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:10px;margin-top:10px}
.stack-card{border:1px solid rgba(255,255,255,.12);border-radius:12px;padding:10px;background:rgba(255,255,255,.03)}
.stack-card h4{margin:0 0 6px 0}
.stack-card .meta{font-size:.85rem;color:var(--muted);margin-bottom:8px}

</style><style id="ORB2D_CSS_V1">
:root{
  --orb-a: var(--grad-a);
  --orb-b: var(--grad-b);
  --orb-size: 64px;
  --orb-blur: 18px;
  --orb-ring: 0 0 0 1px rgba(255,255,255,.12) inset, 0 10px 30px rgba(0,0,0,.35);
}
#fab{ position:fixed; right:14px; bottom:14px; z-index:120; display:flex; flex-direction:column; gap:10px; }
#fab .fab-btn{ display:none !important; }
#orb2d{ width:var(--orb-size); height:var(--orb-size); border-radius:999px; border:1px solid rgba(255,255,255,.14);
  position:relative; cursor:pointer; box-shadow: var(--orb-ring);
  background:
    radial-gradient(120% 120% at 30% 20%, color-mix(in oklab, var(--orb-a) 65%, transparent), transparent 60%),
    radial-gradient(120% 120% at 80% 70%, color-mix(in oklab, var(--orb-b) 60%, transparent), transparent 50%),
    conic-gradient(from 0deg, color-mix(in oklab, var(--orb-b) 45%, transparent), transparent 40%, color-mix(in oklab, var(--orb-a) 45%, transparent));
  filter: saturate(1.1);
  animation: orb-spin 10s linear infinite, orb-breath 3.6s ease-in-out infinite;
  outline: none; -webkit-tap-highlight-color: transparent;
}
#orb2d::before{ /* inner glow */
  content:''; position:absolute; inset:6px; border-radius:inherit;
  background: radial-gradient(80% 80% at 50% 40%, rgba(255,255,255,.35), transparent 60%);
  mix-blend-mode: screen; pointer-events:none;
}
#orb2d::after{ /* rim highlight */
  content:''; position:absolute; inset:0; border-radius:inherit;
  box-shadow: inset 0 0 30px rgba(255,255,255,.12);
  pointer-events:none;
}
#fab.open #orb2d{ animation-duration: 6s; box-shadow: 0 0 0 1px rgba(255,255,255,.18) inset, 0 14px 40px rgba(0,0,0,.45), 0 0 80px color-mix(in oklab, var(--orb-b) 35%, transparent); }
#orb-picker{ position:absolute; right:72px; bottom:0; display:none; flex-direction:column; gap:6px; }
#fab.show-picker #orb-picker{ display:flex; }
#orb-picker .chip{ border:1px solid rgba(255,255,255,.14); border-radius:10px; padding:.45rem .7rem;
  background:linear-gradient(42deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); color:var(--ink); }
@keyframes orb-spin{ to { transform: rotate(360deg); } }
@keyframes orb-breath{ 0%,100% { filter:saturate(1) blur(0px); } 50% { filter:saturate(1.2) blur(1px); } }
</style><style id="FAB_BTN_TWEAKS_V3">
:root{ --fab-btn-opacity: .92; --fab-btn-bg: rgba(255,255,255,.10); --fab-btn-brd: rgba(255,255,255,.20); }
#fab .menu{ display:none; position:absolute; right:72px; bottom:0; gap:8px; flex-direction:column; }
#fab.open .menu{ display:flex; }
#fab .menu .btn, #fab .menu button, #fab .menu a{
  opacity: var(--fab-btn-opacity);
  border:1px solid var(--fab-btn-brd);
  background: linear-gradient(42deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
  color: var(--ink, #e8ecf6);
  border-radius: 12px;
  padding: .55rem .75rem;
  font: 600 14px/1.1 system-ui, sans-serif;
  box-shadow: 0 6px 20px rgba(0,0,0,.25);
}
#fab .menu .btn:active { transform: translateY(1px); opacity: 1; }
</style><style id="KOB_TTS_HIDE_OLD">
  .kob-tts-panel:not(.kob-tts-dock),
  [data-tts-panel-old],
  #ttsPanelOld,
  .tts-panel,
  [id*="tts-panel-old"] { display:none !important; }
</style><style id="KOB_TTS_DOCK_V32">
  :root{
    --tts-left: 8px;         /* posição lembrada (drag) */
    --tts-bottom: 240px;     /* idem */
  }
  .kob-tts-dock{
    position:fixed; z-index:9999; left:var(--tts-left);
    bottom:calc(var(--tts-bottom) + env(safe-area-inset-bottom,0px));
    display:flex; flex-direction:column; gap:8px;
    padding:6px; border-radius:14px;
    background:rgba(15,18,28,.38);
    border:1px solid rgba(255,255,255,.12);
    -webkit-backdrop-filter:blur(10px) saturate(1.1);
    backdrop-filter:blur(10px) saturate(1.1);
    box-shadow:0 12px 26px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.05);
    touch-action:none; cursor:grab;
  }
  .kob-tts-dock.is-drag{ cursor:grabbing; }
  .kob-tts-dock button{
    width:29px; height:29px; border-radius:9px;
    display:grid; place-items:center;
    font-size:16px; line-height:1; color:rgba(255,255,255,.85);
    border:1px solid rgba(255,255,255,.18);
    background:linear-gradient(180deg,rgba(255,255,255,.10),rgba(255,255,255,.02));
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.06);
    transition:transform .14s ease, box-shadow .14s ease, color .14s ease;
  }
  .kob-tts-dock button:hover{ transform:translateY(-1px); color:#fff; }
  .kob-tts-dock button[aria-pressed="true"]{
    outline:2px solid color-mix(in srgb, #00e28b 70%, #67e6ff 30%);
    box-shadow:0 8px 20px rgba(0,0,0,.35), 0 0 18px -2px rgba(103,230,255,.8);
  }
  #tts-status{
    margin-top:.1rem; font-size:11px; color:#eaf6ff; max-width:140px;
    display:block; white-space:normal; word-break:break-word;
  }
  [data-tts-current]{
    outline:2px dashed #00e28b;
    background:rgba(0,226,139,.06);
    border-radius:8px;
    transition:background .2s ease, outline .2s ease;
  }
  #kob-tts-outline{
    position:absolute; display:none; pointer-events:none; z-index:9998;
    border:2px dashed #00e28b; border-radius:10px;
  }
  @media print{ .kob-tts-dock,#kob-tts-outline{ display:none !important; } }
</style><style id="INFODOXY_OVERRIDE_V1">
:root{
  --grad-a:#78e3ff; --grad-b:#b978ff;
  --bg:#070b14; --panel:#0c1120;
  --ink:#eaf6ff; --muted:#9db0cc;
  --glow-in:#7af9ff; --glow-out:#b978ff;
  --radius:18px; --blur:18px;
}
body{
  background:radial-gradient(900px 700px at 50% 10%,rgba(123,243,255,.06),transparent 80%),
             radial-gradient(600px 600px at 70% 100%,rgba(180,120,255,.04),transparent 80%),
             var(--bg);
  color:var(--ink);
  font-family:"Inter","SF Pro",system-ui;
}
details.acc{
  background:rgba(255,255,255,.03);
  border:1px solid rgba(255,255,255,.1);
  box-shadow:0 0 20px rgba(120,240,255,.04) inset,0 0 60px rgba(180,120,255,.05);
  border-radius:var(--radius);
  transition:.25s all ease;
}
details.acc:hover{box-shadow:0 0 25px rgba(120,240,255,.08),0 0 80px rgba(180,120,255,.1);}
summary h2{color:var(--ink);text-shadow:0 0 12px rgba(120,240,255,.4);}
.btn{
  border:1px solid rgba(255,255,255,.15);
  background:linear-gradient(45deg,rgba(120,240,255,.15),rgba(180,120,255,.12));
  border-radius:12px;color:var(--ink);
  backdrop-filter:blur(8px);
  box-shadow:0 0 20px rgba(120,240,255,.15);
  transition:.25s ease;
}
.btn:hover{background:linear-gradient(45deg,rgba(120,240,255,.25),rgba(180,120,255,.2));}
#orb2d{
  background:radial-gradient(120% 120% at 30% 30%,rgba(120,240,255,.6),transparent 70%),
             radial-gradient(120% 120% at 70% 70%,rgba(180,120,255,.5),transparent 70%);
  box-shadow:0 0 25px rgba(120,240,255,.4),0 0 80px rgba(180,120,255,.2);
  animation:orb-spin 10s linear infinite,orb-breath 3.6s ease-in-out infinite;
}
#fab .menu .btn{
  background:linear-gradient(42deg,rgba(120,240,255,.15),rgba(180,120,255,.12));
  border:1px solid rgba(255,255,255,.15);
  color:var(--ink);
  border-radius:10px;
  box-shadow:0 6px 18px rgba(0,0,0,.25);
}
.toast{
  background:rgba(10,15,30,.8);
  color:var(--ink);
  box-shadow:0 0 18px rgba(120,240,255,.1);
}
img.md-img{border-radius:12px;box-shadow:0 0 25px rgba(120,240,255,.1);}
@keyframes orb-breath{
  0%,100%{filter:saturate(1) brightness(1);}
  50%{filter:saturate(1.3) brightness(1.2);}
}

</style><style id="KOB_VOICE_THEME_CSS_PATCH">
  :root{
    /* duração da transição de cor / glow */
    --kob-voice-theme-duration: 520ms;
  }

  /* Quem responde às mudanças de tema de voz */
  body,
  .nebula,
  details.acc,
  .btn,
  #fab,
  .kob-tts-dock,
  .kob-tts-panel.is-dock {
    transition:
      background var(--kob-voice-theme-duration) ease,
      box-shadow var(--kob-voice-theme-duration) ease,
      border-color var(--kob-voice-theme-duration) ease,
      color var(--kob-voice-theme-duration) ease;
  }

  /* Opcional: marcador visual do arquétipo atual */
  body[data-voice-arch] .nebula::before{
    content: attr(data-voice-arch);
    position:absolute;
    top:10px; right:14px;
    padding:4px 8px;
    font-size:11px;
    letter-spacing:.08em;
    text-transform:uppercase;
    border-radius:999px;
    background:rgba(0,0,0,.45);
    border:1px solid rgba(255,255,255,.20);
    color:var(--ink);
    backdrop-filter:blur(6px);
    pointer-events:none;
  }
</style><style id="KOBLLUX_VOICE_THEME_CSS">
:root{
  
  
  --kob-voice-primary:   #78e3ff;
  --kob-voice-secondary: #b978ff;
  --kob-voice-accent:    #ffffff;
  --kob-voice-bg-soft:radial-gradient(900px 700px at 50% 10%,rgba(123,243,255,.06),transparent 80%),
             radial-gradient(600px 600px at 70% 100%,rgba(180,120,255,.04),transparent 80%),
             var(--bg);
  --kob-voice-glow:      0 0 18px rgba(0,216,216,0.55);
}

/* Dock do TTS acompanha a voz atual */
.kob-tts-dock{
  background: var(--kob-voice-bg-soft);
  box-shadow: var(--kob-voice-glow);
  border-radius: 12px;
  backdrop-filter: blur(16px);
  border: 1px solid rgba(255,255,255,0.06);
}

.kob-tts-dock button[data-tts-btn="toggle"]{
  border: 1px solid var(--kob-voice-primary);
  color:  var(--kob-voice-accent);
}

.kob-tts-dock button[data-tts-btn="sel"],
.kob-tts-dock button[data-tts-btn="stop"]{
  border: 1px solid rgba(255,255,255,0.16);
}

/* Se você marcar algum bloco como "sendo lido" no futuro */
[data-being-read="true"]{
  outline: 1px solid var(--kob-voice-primary);
  background: var(--kob-voice-bg-soft);
}

/* Tema adicional por arquétipo (opcional, pra brincar com o body) */
body[data-voice-arch="kobllux"]{
  --kob-voice-primary:#00d8d8;
  --kob-voice-secondary:#d800d8;
}
body[data-voice-arch="nova"]{
  --kob-voice-primary:#FF6FB5;
  --kob-voice-secondary:#FFD6E8;
}
body[data-voice-arch="kaos"]{
  --kob-voice-primary:#FF5C8A;
  --kob-voice-secondary:#3D000F;
}
body[data-voice-arch="serena"]{
  --kob-voice-primary:#7AD3A8;
  --kob-voice-secondary:#154734;
}
body[data-voice-arch="vitalis"]{
  --kob-voice-primary:#00F5A0;
  --kob-voice-secondary:#00D9F5;
}
body[data-voice-arch="pulse"]{
  --kob-voice-primary:#A259FF;
  --kob-voice-secondary:#2D1B69;
}
body[data-voice-arch="atlas"]{
  --kob-voice-primary:#6CCFF6;
  --kob-voice-secondary:#1B4965;
}
body[data-voice-arch="lumine"]{
  --kob-voice-primary:#FFE066;
  --kob-voice-secondary:#FF9F1C;
}
body[data-voice-arch="rhea"]{
  --kob-voice-primary:#00B894;
  --kob-voice-secondary:#055E55;
}
body[data-voice-arch="solus"]{
  --kob-voice-primary:#4B6584;
  --kob-voice-secondary:#0B1420;
}
body[data-voice-arch="aion"]{
  --kob-voice-primary:#00A8E8;
  --kob-voice-secondary:#001F54;
}
body[data-voice-arch="cooplux"]{
  --kob-voice-primary:#39FFB6;
  --kob-voice-secondary:#00d8d8;
}
body[data-voice-arch="fitlux"]{
  --kob-voice-primary:#FFC857;
  --kob-voice-secondary:#FFE39A;
}
</style><style id="KOB_PATCH_TTS_DOCK_V1">

.kob-tts-dock{
  background:linear-gradient(
    42deg,
    color-mix(in srgb, var(--grad-a) 18%, transparent),
    color-mix(in srgb, var(--grad-b) 18%, transparent)
  ) !important;
  border:1px solid rgba(255,255,255,.10) !important;
  color:var(--ink) !important;
  box-shadow:0 0 18px rgba(0,0,0,.35) !important;
  backdrop-filter:blur(14px) !important;
}

.kob-tts-dock button{
  background:rgba(0,0,0,.25) !important;
  border:1px solid rgba(255,255,255,.18) !important;
  color:var(--ink) !important;
}

.kob-tts-dock{
  transform: scale(0.85);
  transform-origin: bottom right; /* ou onde você ancora o dock */
}

</style><style id="KOB_PATCH_FECHAR_LEFT">
/* Mover o botão "Fechar" do importer pro canto ESQUERDO */
button.btn[onclick="closeImporter()"]{
  margin-right:auto !important;  /* empurra o botão pra esquerda dentro do flex */
}
</style><style id="KOB_PATCH_IFRAME_VIDEO">
  /* Iframes dentro do conteúdo gerado (root / aninhado) */
  #root iframe,
  .lv-content iframe,
  .nested-view iframe{
    display:block;
    width:100%;
    max-width:100%;
    aspect-ratio:16/9;
    height:auto;
    border:none;
    border-radius:12px;
    margin:12px 0;
    box-shadow:0 12px 32px rgba(0,0,0,.55);
    background:#000;
  }

  /* Se estiver em coluna estreita, deixa um pouco mais compacto */
  @media (max-width: 480px){
    #root iframe,
    .lv-content iframe,
    .nested-view iframe{
      border-radius:10px;
      margin:10px 0;
    }
  }
</style><style>
        :root {
          --z-base: 0;
          --z-content: 100;
          --z-widget: 500;
          --z-overlay: 1000;
          --z-system: 5000;
        }
      </style><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&amp;family=JetBrains+Mono:wght@400;700&amp;display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.10.0/styles/github-dark.min.css" id="hljs-theme"><style>
    /* =========================
       SOLAR NEBULA PRO — CORE CSS
    ========================= */
    :root {
      --bg-deep: #050811; 
      --bg-day: radial-gradient(circle at 30% 20%, #ffffff 0%, #f2f8ff 18%, #d0e9ff 40%, #9ed0ff 65%, #6bb9ff 85%, #59a8ff 100%);
      --bg-sunset: linear-gradient(180deg, #fbcfe8 0%, #fb923c 20%, #4c1d95 60%, #111827 100%);
      --bg-night: radial-gradient(circle at 20% 0%, #0b1020 0%, #121c3b 40%, #1a237e 80%, #000000 100%);
      --bg-panel: rgba(10, 14, 24, 0.95);
      --primary: #00f5ff;
      --secondary: #ff4bff;
      --text-main: #e4ecff;
      --text-muted: #9aa4c8;
      --danger: #ff4b6b;
      --glass: blur(20px) saturate(180%);
    }

    /* Reset & Base */
    html, body { margin: 0; padding: 0; width: 100%; height: 100%; background: var(--bg-deep); color: var(--text-main); font-family: "Montserrat", sans-serif; overflow: hidden; transition: background 0.8s cubic-bezier(0.4, 0, 0.2, 1); }
    
    /* Modos Solares */
    body.mode-day { background: var(--bg-day) !important; color: #1a1a1a !important; }
    body.mode-sunset { background: var(--bg-sunset) !important; color: #fff !important; }
    body.mode-night { background: var(--bg-night) !important; color: var(--text-main) !important; }

    /* Adaptação UI Day */
    body.mode-day .msg-block.ai { background: rgba(0,0,0,0.05); color: #222; border-color: rgba(0,0,0,0.1); }
    body.mode-day .glass-input { background: rgba(255,255,255,0.8); color: #000; border-color: #ccc; }
    body.mode-day .btn-icon { color: #333; border-color: rgba(0,0,0,0.2); }
    body.mode-day .cockpit-item, body.mode-day .deck-item { background: rgba(0,0,0,0.05); color: #000; }
    body.mode-day .cockpit-input { color: #000; border-bottom-color: rgba(0,0,0,0.3); }
    body.mode-day .drawer-content { background: #fff; color: #222; }
    
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    /* Fundo */
    .sky-layer { position: fixed; inset: 0; z-index: 0; pointer-events: none; }
    .sun-background { position: absolute; width: 300px; height: 300px; border-radius: 50%; background: radial-gradient(circle at 30% 30%, #fffde7 0%, #fff176 40%, #ffb300 100%); filter: blur(60px); opacity: 0; transition: opacity 2s; animation: sun-orbit 60s linear infinite; }
    body.mode-day .sun-background { opacity: 0.5; }
    @keyframes sun-orbit { 0% { transform: translate(-20vw, 10vh); } 50% { transform: translate(80vw, -10vh); } 100% { transform: translate(-20vw, 10vh); } }
    #particles-js { position: fixed; inset: 0; z-index: 1; opacity: 0.3; pointer-events: none; }
    body.mode-day #particles-js { opacity: 0.1; }
    #bg-fake-custom { position: fixed; inset: 0; z-index: 2; opacity: 0.2; background-size: cover; background-position: center; pointer-events: none; }

    /* Header Orb */
    .header-orb { position: fixed; top: 40px; left: 50%; transform: translateX(-50%); width: 70px; height: 70px; z-index: 15; animation: floatOrb 6s ease-in-out infinite; cursor: pointer; transition: all 0.5s ease; }
    .header-orb svg { width: 100%; height: 100%; transition: fill 0.5s ease; filter: drop-shadow(0 0 10px rgba(0,245,255,0.5)); }
    body.mode-day .header-orb svg { fill: #fff176; filter: drop-shadow(0 0 20px #ffb300); }
    body.mode-sunset .header-orb svg { fill: #ffb74d; filter: drop-shadow(0 0 30px #e65100); }
    body.mode-night .header-orb svg { fill: white; filter: drop-shadow(0 0 15px var(--primary)); }
    @keyframes floatOrb { 0%,100%{transform:translate(-50%,0)} 50%{transform:translate(-50%,-8px)} }
    
    #usernameDisplay { position: fixed; top: 120px; left: 50%; transform: translateX(-50%); z-index: 10; font-size: 0.75rem; color: var(--text-muted); opacity: 0.6; pointer-events: none; text-transform: uppercase; letter-spacing: 2px; }
    #nv-toast { position: fixed; bottom: 200px; left: 50%; transform: translateX(-50%) translateY(20px); background: rgba(0,0,0,0.8); color: #fff; padding: 10px 20px; border-radius: 50px; backdrop-filter: blur(10px); opacity: 0; transition: 0.4s; z-index: 9999; font-size: 0.8rem; pointer-events: none; border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
    #nv-toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
    #modeIndicator { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); font-size: 0.65rem; font-weight: bold; opacity: 0.5; z-index: 20; text-transform: uppercase; letter-spacing: 1px; }

    /* Chat Area */
    .top-bar { position: fixed; top: 0; left: 0; right: 0; padding: 15px; display: flex; justify-content: space-between; z-index: 20; pointer-events: none; }
    .top-grp { display: flex; gap: 10px; pointer-events: auto; }
    #chat-container { position: absolute; top: 0; left: 0; right: 0; bottom: 0; padding: 140px 16px 100px 16px; z-index: 5; overflow-y: auto; display: flex; flex-direction: column; gap: 16px; transition: opacity 0.4s ease; scroll-behavior: smooth; }
    #chat-container.collapsed { opacity: 0; pointer-events: none; }

    .msg-block { max-width: 88%; padding: 12px 16px; border-radius: 12px; position: relative; animation: slideIn 0.3s ease-out; line-height: 1.5; font-size: 0.95rem; word-wrap: break-word; }
    .msg-block.user { align-self: flex-end; background: rgba(0,245,255,0.08); border-right: 2px solid var(--primary); text-align: right; }
    .msg-block.ai { align-self: flex-start; background: rgba(255,255,255,0.05); border-left: 2px solid var(--secondary); }
    .msg-block.system { align-self: center; font-size: 0.75rem; opacity: 0.8; text-align: center; border: 1px dashed rgba(255,255,255,0.2); background: transparent; padding: 6px 12px; font-style: italic; }
    @keyframes slideIn { from{opacity:0; transform:translateY(10px)} to{opacity:1; transform:translateY(0)} }

    /* Code & Preview */
    pre { position: relative; background: rgba(0,0,0,0.4); border-radius: 8px; margin: 10px 0; overflow: hidden; border: 1px solid rgba(255,255,255,0.1); }
    code { font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; }
    .copy-code-btn { position: absolute; top: 8px; right: 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: var(--primary); font-size: 0.7rem; padding: 4px 8px; border-radius: 4px; cursor: pointer; z-index: 10; opacity: 0.7; transition: 0.2s; }
    .copy-code-btn:hover { opacity: 1; background: var(--primary); color: #000; }

    /* VISUALIZADOR HTML (Atualizado) */
    .html-viewer { margin-top: 10px; border: 1px solid rgba(255,255,255,0.2); border-radius: 10px; overflow: hidden; background: #000; display: flex; flex-direction: column; }

    .html-viewer-bar { display: flex; background: rgba(255,255,255,0.1); padding: 8px; gap: 8px; position: sticky; top: 0; z-index: 10; }

    .html-viewer-btn { background: transparent; border: none; color: var(--text-muted); padding: 6px 12px; font-size: 0.75rem; cursor: pointer; border-radius: 4px; transition: 0.2s; display: flex; align-items: center; gap: 6px; }

    .html-viewer-btn.active { background: var(--primary); color: #000; font-weight: bold; }

    .html-viewer-btn:hover:not(.active) { background: rgba(255,255,255,0.1); color: #fff; }

    /* Layout Mobile Preview */
    .html-viewer-content { position: relative; width: 100%; height: 450px; border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; overflow: hidden; }

    /* Simulação mobile */
    .html-viewer.mobile .html-viewer-content { width: 100%; max-width: 390px; height: 844px; margin: 0 auto; background: #000; border: 12px solid #1a1a1a; border-radius: 28px; box-shadow: 0 20px 40px rgba(0,0,0,0.5); }

    .html-viewer-content iframe { width: 100%; height: 100%; border: none; background: white; }

    .html-viewer-code { display: none; width: 100%; height: 100%; overflow: auto; background: #1e1e1e; padding: 10px; }

    .html-viewer.show-code .html-viewer-content iframe { display: none; }

    .html-viewer.show-code .html-viewer-code { display: block; }

    /* Ícones */
    .svg-icon { width: 14px; height: 14px; stroke: currentColor; stroke-width: 2; fill: none; }

    /* Modo tela cheia */
    .html-viewer.fullscreen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100vw; height: 100vh; z-index: 9999; background: #000; border-radius: 0; }

    .html-viewer.fullscreen .html-viewer-content { height: calc(100vh - 48px); }

    /* Mobile Toggle */
    .mobile-toggle { margin-left: auto; display: flex; gap: 8px; }

    /* Preview Files */
    .file-msg { border-left: 3px solid var(--secondary) !important; background: rgba(255,255,255,0.05); }
    .file-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; font-size: 0.8rem; }
    .file-meta { font-size: 0.7rem; color: var(--text-muted); }

    .msg-tools { display: flex; gap: 10px; justify-content: flex-end; margin-top: 5px; opacity: 0.5; }
    .msg-block.ai .msg-tools { justify-content: flex-start; }
    .tool-btn { background: none; border: none; color: inherit; padding: 0; cursor: pointer; }
    .tool-btn:hover { color: var(--primary); opacity: 1; }
    .tool-btn svg { width: 14px; height: 14px; stroke: currentColor; stroke-width: 2; fill: none; }

    /* Input Dock */
    .input-dock { position: fixed; bottom: 0; left: 0; right: 0; padding: 16px; background: linear-gradient(to top, var(--bg-deep) 18%, transparent); z-index: 30; display: flex; flex-direction: column; align-items: center; }
    body.mode-day .input-dock { background: linear-gradient(to top, rgba(0,0,0,0.4) 18%, transparent); }
    #filePreview { display: none; width: 100%; max-width: 400px; background: rgba(0,0,0,0.8); border: 1px solid var(--primary); border-radius: 12px; padding: 10px; margin-bottom: 10px; align-items: center; justify-content: space-between; backdrop-filter: blur(10px); }
    #filePreview.active { display: flex; animation: slideIn 0.3s; }
    .file-info { font-size: 0.8rem; color: #fff; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 200px; }
    .file-actions { display: flex; gap: 10px; }
    .btn-preview { background: rgba(255,255,255,0.1); border: none; color: #fff; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 0.7rem; }
    .btn-preview.primary { background: var(--primary); color: #000; }
    #field-toggle-handle { display: flex; align-items: center; justify-content: center; gap: 8px; font-size: 0.8rem; opacity: 0.9; cursor: pointer; padding-bottom: 12px; text-transform: lowercase; letter-spacing: 1px; transition: 0.3s; }
    #field-toggle-handle:hover { color: var(--primary); transform: scale(1.02); }
    .footer-dot{ width:8px; height:8px; border-radius:50%; background:var(--secondary); animation:pulse 2s infinite; }
    @keyframes pulse{50%{opacity:.4; box-shadow: 0 0 10px currentColor;}}
    .input-row { display: flex; width: 100%; gap: 10px; align-items: center; max-width: 800px; }
    .glass-input { flex: 1; background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); color: inherit; padding: 14px 20px; border-radius: 99px; outline: none; transition: 0.3s; }
    .glass-input:focus { background: rgba(0,0,0,0.5); border-color: var(--primary); box-shadow: 0 0 15px rgba(0,245,255,0.2); }
    body.mode-day .glass-input:focus { background: white; }
    .btn-icon { width: 44px; height: 44px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.05); color: inherit; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: 0.2s; backdrop-filter: blur(5px); }
    .btn-icon:hover { background: rgba(255,255,255,0.2); transform: scale(1.05); border-color: var(--primary); }
    .btn-icon svg { width: 20px; height: 20px; stroke: currentColor; stroke-width: 2; fill: none; }
    .btn-primary { background: var(--primary); color: #000 !important; border: none; box-shadow: 0 0 10px rgba(0, 245, 255, 0.4); }
    #btnVoice.listening { background: var(--danger); box-shadow: 0 0 15px var(--danger); animation: pulse 1s infinite; color: white !important; }

    /* Drawers */
    .drawer { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(8px); z-index: 100; opacity: 0; pointer-events: none; transition: opacity 0.3s; display: flex; align-items: center; justify-content: center; }
    .drawer.open { opacity: 1; pointer-events: auto; }
    .drawer-content { width: 90%; max-width: 450px; max-height: 85vh; background: var(--bg-panel); border: 1px solid rgba(255,255,255,0.1); border-radius: 20px; display: flex; flex-direction: column; overflow: hidden; box-shadow: 0 20px 50px rgba(0,0,0,0.5); transform: scale(0.9); transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
    .drawer.open .drawer-content { transform: scale(1); }
    .drawer-header { padding: 15px 20px; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.02); }
    .drawer-header h3 { margin: 0; font-size: 1.1rem; display: flex; align-items: center; gap: 10px; }
    .drawer-body { padding: 20px; overflow-y: auto; flex: 1; }
    
    /* Cockpit */
    .cockpit-grid { display: flex; flex-direction: column; gap: 15px; }
    .cockpit-item { background: rgba(255,255,255,0.03); padding: 10px 15px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.05); display: flex; flex-direction: column; }
    .cockpit-label { font-size: 0.7rem; color: var(--primary); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px; }
    .cockpit-input { background: transparent; border: none; color: white; font-family: 'JetBrains Mono', monospace; font-size: 1rem; outline: none; width: 100%; border-bottom: 1px dashed rgba(255,255,255,0.1); padding-bottom: 5px; transition: 0.3s; }
    .cockpit-input:focus { border-bottom-color: var(--secondary); }
    .control-row { display: flex; gap: 10px; margin-top: 20px; }
    .btn-block { flex: 1; padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.05); color: inherit; cursor: pointer; font-size: 0.85rem; font-weight: 600; transition: 0.2s; }
    .btn-block:hover { background: rgba(255,255,255,0.15); border-color: var(--primary); }
    
    /* Deck Items */
    .deck-item { background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px; margin-bottom: 10px; border: 1px solid rgba(255,255,255,0.05); display: flex; justify-content: space-between; align-items: center; }
    .deck-info h4 { margin: 0 0 5px 0; font-size: 0.9rem; }
    .deck-info span { font-size: 0.7rem; opacity: 0.7; }
    .form-group { margin-bottom: 15px; }
    .form-group label { display: block; margin-bottom: 5px; font-size: 0.8rem; color: var(--text-muted); }
    .glass-textarea { width: 100%; background: rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.2); color: inherit; padding: 10px; border-radius: 8px; min-height: 80px; }
  </style><style id="custom-styles"></style><style id="TEXT_BEAUTY_V3">
:root{
  --txt-card: color-mix(in oklab, var(--panel, #0e1220) 92%, black);
  --txt-bd: color-mix(in oklab, var(--ink, #e8ecf6) 16%, transparent);
  --txt-shadow: 0 6px 24px rgba(0,0,0,.25), inset 0 0 0 1px var(--txt-bd);
  --chip-bg: linear-gradient(42deg, var(--grad-a, #7effa1), var(--grad-b, #67e6ff));
  --chip-ink: #000;
  --paren-ink: color-mix(in oklab, var(--ink, #e8ecf6) 92%, white);
}

/* Tipografia base do texto corrido (aplicamos quando detectado bloco .flow-text) */
.flow-text p{
  text-wrap: pretty;
  line-height: 1.65;
  letter-spacing: .01em;
  margin: .65rem 0;
  hyphens: auto;
}

/* Heading leve detectado por “Titulo:” */
.flow-text .kv-head{
  font-weight: 800;
  letter-spacing:.02em;
  margin: 1.2rem 0 .4rem;
}

/* Parênteses → realce sutil */
.span-paren{
  padding: .05rem .35rem;
  border-radius: .55rem;
  border: 1px solid var(--txt-bd);
  color: var(--paren-ink);
  background: color-mix(in oklab, var(--txt-card) 86%, transparent);
}

/* Chips (colchetes) clicáveis */
.chip, .chip-btn{
  display:inline-grid; place-items:center;
  padding:.25rem .6rem; border-radius:999px;
  background: var(--chip-bg); color: var(--chip-ink);
  font-weight: 700; letter-spacing:.02em;
  box-shadow: 0 2px 10px rgba(0,0,0,.35);
  cursor: pointer; user-select: none;
}
.chip + .chip{ margin-left:.35rem; }

/* Pergunta → card */
.q-card{
  background: var(--txt-card);
  border: 1px solid var(--txt-bd);
  box-shadow: var(--txt-shadow);
  border-radius: 14px;
  padding: .85rem 1rem;
  margin: .9rem 0;
  display:grid; grid-template-columns:auto 1fr; gap:.65rem; align-items:start;
}
.q-card .q-ico{
  inline-size:1.65rem; block-size:1.65rem; border-radius:50%;
  display:grid; place-items:center; font-weight:800; color:#000;
  background: var(--chip-bg);
}
.q-card .q-body{ line-height:1.55; }

/* Overlay de copiar nas listas (usa .list-card do patch anterior) */
.list-card{ position:relative; }
.list-card .copy-badge{
  position:absolute; top:.35rem; right:.35rem;
  font-size:.8rem; padding:.2rem .45rem; border-radius:999px;
  background: color-mix(in oklab, #fff 12%, var(--txt-card));
  border: 1px solid var(--txt-bd);
  color: var(--ink, #e8ecf6); opacity:.65; transition:.2s; user-select:none;
}
.list-card:hover .copy-badge{ opacity:1; }

/* Área que receberá HTML “desescapado” */
.raw-html-card{
  background: var(--txt-card); border: 1px dashed var(--txt-bd);
  border-radius: 14px; padding: .85rem 1rem; margin: .9rem 0;
}
.raw-html-card .raw-note{ color: color-mix(in oklab, var(--ink) 62%, transparent); font-size:.85em; margin-bottom:.35rem; }
</style><style id="LIST_BEAUTY_V2">
/* sem conflito: usa escopo mais específico, preservando V1 */
:root{
  --list-bg: color-mix(in oklab, var(--panel, #0e1220) 90%, black);
  --list-border: color-mix(in oklab, var(--ink, #e8ecf6) 16%, transparent);
  --list-shadow: 0 6px 24px rgba(0,0,0,.25), inset 0 0 0 1px var(--list-border);
  --list-radius: 16px;
  --list-marker-size: 1.65rem;
  --list-muted: color-mix(in oklab, var(--ink, #e8ecf6) 62%, transparent);
}

/* wrapper visual */
.list-card{ background:var(--list-bg); border-radius:var(--list-radius);
  box-shadow:var(--list-shadow); border:1px solid var(--list-border);
  padding:clamp(.6rem,.9rem,1rem); margin:.85rem 0; }
.list-card ul, .list-card ol{ margin:.25rem 0; padding:0; list-style:none; }
.list-card li{ display:grid; grid-template-columns:auto 1fr; gap:.65rem; align-items:start; padding:.35rem .25rem; }
.list-card li > ul, .list-card li > ol{ margin-top:.35rem; margin-left:1.85rem; }

/* ========= OL: numeração hierárquica ========= */
.list-card ol.ol-neo{ counter-reset:item; }
.list-card ol.ol-neo li{ counter-increment:item; }
.list-card ol.ol-neo li::before{
  /* hierarquia: 1, 1.1, 1.1.1 */
  content:counters(item, ".");
  inline-size:auto; min-inline-size: var(--list-marker-size);
  block-size: var(--list-marker-size);
  padding:0 .55rem; display:grid; place-items:center;
  font-weight:700; font-variant-numeric: tabular-nums;
  border-radius:12px;
  background:linear-gradient(42deg, var(--grad-a, #7effa1), var(--grad-b, #67e6ff));
  color:#000; box-shadow:0 2px 10px rgba(0,0,0,.35);
}
/* reseta contador em sub-listas para formar 1.1, 1.2, etc. */
.list-card ol.ol-neo ol{ counter-reset:item; }

/* ========= UL: bullets padrão (diamante) ========= */
.list-card ul.ul-neo:not(.style-dash):not([data-bullet="dash"]) > li::before{
  content:"";
  inline-size:.9rem; block-size:.9rem; border-radius:8px;
  background:linear-gradient(42deg, var(--grad-a, #7effa1), var(--grad-b, #67e6ff));
  box-shadow:0 1px 6px rgba(0,0,0,.35), 0 0 0 1px color-mix(in oklab, #fff 14%, transparent);
  translate:0 .15rem;
}

/* ========= UL: variante “traço-cápsula” ========= */
.list-card ul.ul-neo.style-dash > li::before,
.list-card ul.ul-neo[data-bullet="dash"] > li::before{
  content: attr(data-marker, "–"); /* pode trocar por texto: data-marker="TIP" */
  display:inline-grid; place-items:center;
  inline-size:auto; min-inline-size:1.35rem; block-size:1.35rem;
  padding:0 .6rem; border-radius:999px; font-weight:700;
  letter-spacing:.02em;
  background:linear-gradient(42deg, var(--grad-a, #7effa1), var(--grad-b, #67e6ff));
  color:#000; box-shadow:0 2px 10px rgba(0,0,0,.35);
}

/* dica/legenda leve */
.list-card .hint{ color:var(--list-muted); font-size:.9em; }

/* ========= ASCII card (igual V1, com leve glow) ========= */
.ascii-card{ background:var(--list-bg); border-radius:calc(var(--list-radius) + 2px);
  border:1px solid var(--list-border); box-shadow:var(--list-shadow),
  0 0 0 1px color-mix(in oklab, var(--grad-b, #67e6ff) 20%, transparent);
  margin:1rem 0; overflow:auto; }
.ascii-card pre{ margin:0; padding:1rem 1.1rem; line-height:1.35;
  font:500 13.5px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; white-space:pre; tab-size:2; }
.ascii-card .ascii-cap{ padding:.55rem .9rem .6rem; border-top:1px dashed var(--list-border);
  color:var(--list-muted); font-size:.85em; }
</style><style> #fab .menu [data-action="katex"]{ display:none !important; }</style><style id="TEXT_BEAUTY_V3">
:root{
  --txt-card: color-mix(in oklab, var(--panel, #0e1220) 92%, black);
  --txt-bd: color-mix(in oklab, var(--ink, #e8ecf6) 16%, transparent);
  --txt-shadow: 0 6px 24px rgba(0,0,0,.25), inset 0 0 0 1px var(--txt-bd);
  --chip-bg: linear-gradient(42deg, var(--grad-a, #7effa1), var(--grad-b, #67e6ff));
  --chip-ink: #000;
  --paren-ink: color-mix(in oklab, var(--ink, #e8ecf6) 92%, white);
}

/* Tipografia base do texto corrido (aplicamos quando detectado bloco .flow-text) */
.flow-text p{
  text-wrap: pretty;
  line-height: 1.65;
  letter-spacing: .01em;
  margin: .65rem 0;
  hyphens: auto;
}

/* Heading leve detectado por “Titulo:” */
.flow-text .kv-head{
  font-weight: 800;
  letter-spacing:.02em;
  margin: 1.2rem 0 .4rem;
}

/* Parênteses → realce sutil */
.span-paren{
  padding: .05rem .35rem;
  border-radius: .55rem;
  border: 1px solid var(--txt-bd);
  color: var(--paren-ink);
  background: color-mix(in oklab, var(--txt-card) 86%, transparent);
}

/* Chips (colchetes) clicáveis */
.chip, .chip-btn{
  display:inline-grid; place-items:center;
  padding:.25rem .6rem; border-radius:999px;
  background: var(--chip-bg); color: var(--chip-ink);
  font-weight: 700; letter-spacing:.02em;
  box-shadow: 0 2px 10px rgba(0,0,0,.35);
  cursor: pointer; user-select: none;
}
.chip + .chip{ margin-left:.35rem; }

/* Pergunta → card */
.q-card{
  background: var(--txt-card);
  border: 1px solid var(--txt-bd);
  box-shadow: var(--txt-shadow);
  border-radius: 14px;
  padding: .85rem 1rem;
  margin: .9rem 0;
  display:grid; grid-template-columns:auto 1fr; gap:.65rem; align-items:start;
}
.q-card .q-ico{
  inline-size:1.65rem; block-size:1.65rem; border-radius:50%;
  display:grid; place-items:center; font-weight:800; color:#000;
  background: var(--chip-bg);
}
.q-card .q-body{ line-height:1.55; }

/* Overlay de copiar nas listas (usa .list-card do patch anterior) */
.list-card{ position:relative; }
.list-card .copy-badge{
  position:absolute; top:.35rem; right:.35rem;
  font-size:.8rem; padding:.2rem .45rem; border-radius:999px;
  background: color-mix(in oklab, #fff 12%, var(--txt-card));
  border: 1px solid var(--txt-bd);
  color: var(--ink, #e8ecf6); opacity:.65; transition:.2s; user-select:none;
}
.list-card:hover .copy-badge{ opacity:1; }

/* Área que receberá HTML “desescapado” */
.raw-html-card{
  background: var(--txt-card); border: 1px dashed var(--txt-bd);
  border-radius: 14px; padding: .85rem 1rem; margin: .9rem 0;
}
.raw-html-card .raw-note{ color: color-mix(in oklab, var(--ink) 62%, transparent); font-size:.85em; margin-bottom:.35rem; }
</style><style>
  /* =======================================================================
     KOBLLUX — TTS Dock (Nebula Pro + Base Madeira)
     MOBILE-FIRST VERTICAL HARD-LOCK
     ======================================================================= */

  /* Destaque do bloco atual lido */
  [data-tts-current]{
    outline:2px dashed var(--cyan,#4cf);
    background:rgba(76,240,255,.06);
    border-radius:8px;
    transition:background .25s ease, outline .25s ease;
  }

  /* Tokens */
  :root{
    --tts-dock-left: 8px;         /* ajuste livre */
    --tts-dock-bottom: 269px;     /* ajuste livre */
    --tts-gap: 10px;

    --tts-glass-bg: rgba(15,18,28,.38);
    --tts-glass-bd: rgba(255,255,255,.12);
    --tts-glow:     rgba(76,240,255,.85);   /* ciano (Nebula) */
    --tts-ink:      rgba(255,255,255,.92);
    --tts-ink-dim:  rgba(255,255,255,.68);
    --tts-accent:   color-mix(in srgb, #00e28b 55%, var(--tts-glow) 45%); /* Base Madeira + ciano */
  }

  /* Base inline (fallback) */
  .kob-tts-panel{
    display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;margin:.5rem 0
  }
  .kob-tts-panel button{
    padding:.5rem .75rem;
    border:1px solid rgba(255,255,255,.2);
    background:rgba(255,255,255,.05);
    backdrop-filter:saturate(1.2) blur(2px);
    border-radius:10px
  }
  .kob-tts-panel small{opacity:.8}

  /* Dock vertical fixo */
  .kob-tts-panel.is-dock{
    position: fixed;
    left: var(--tts-dock-left);
    bottom: calc(var(--tts-dock-bottom) + env(safe-area-inset-bottom, 0px));
    z-index: 9999;
    display: flex;
    flex-direction: column;
    gap: var(--tts-gap);
    align-items: stretch;

    padding: .6rem;
    border-radius: 16px;
    background: var(--tts-glass-bg);
    border: 1px solid var(--tts-glass-bd);
    -webkit-backdrop-filter: blur(10px) saturate(1.15);
    backdrop-filter: blur(10px) saturate(1.15);
    box-shadow: 0 12px 26px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.05);

    touch-action: none; /* habilita drag suave */
    cursor: grab;
  }
  .kob-tts-panel.is-dock.is-dragging{
    cursor: grabbing;
    transition: none !important;
  }

  .kob-tts-panel.is-dock button{
    width: 48px; height: 48px;
    border-radius: 14px;
    display: grid; place-items: center;

    color: var(--tts-ink-dim);
    font-size: 20px; line-height: 1; font-weight: 600;

    border: 1px solid rgba(255,255,255,.18);
    background:
      linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.02)) padding-box,
      linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.05)) border-box;

    box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
    cursor: pointer;
    transition: transform .16s ease, box-shadow .16s ease, color .16s ease, background .16s ease;
  }
  .kob-tts-panel.is-dock button:hover{
    transform: translateY(-1px);
    color: var(--tts-ink);
    box-shadow: 0 8px 18px rgba(0,0,0,.32), inset 0 0 0 1px rgba(255,255,255,.10);
  }
  .kob-tts-panel.is-dock button:active{ transform: translateY(0); }

  .kob-tts-panel.is-dock button[aria-pressed="true"]{
    color: var(--tts-ink);
    background:
      radial-gradient(120% 120% at 50% 0%, color-mix(in srgb, var(--tts-glow), transparent 65%) 0%, transparent 60%) padding-box,
      linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,.08)) border-box;
    outline: 2px solid color-mix(in srgb, var(--tts-glow) 70%, var(--tts-accent) 30%);
    box-shadow:
      0 0 18px -2px color-mix(in srgb, var(--tts-glow) 70%, var(--tts-accent) 30%),
      0 10px 26px rgba(0,0,0,.38),
      inset 0 0 0 1px rgba(255,255,255,.10);
  }

  /* micro-ripple sem JS */
  .kob-tts-panel.is-dock button::after{
    content:""; position:absolute; inset:0; border-radius:inherit; opacity:0;
    box-shadow: 0 0 0 0 var(--tts-glow);
    transition: box-shadow .4s ease, opacity .4s ease;
  }
  .kob-tts-panel.is-dock button:active::after{
    opacity:.4; box-shadow: 0 0 0 10px transparent;
  }

  .kob-tts-panel.is-dock small[data-tts-status]{
    margin-top: .15rem; font-size: 11px; letter-spacing: .2px;
    opacity: .78; color: var(--tts-ink); max-width: 172px; text-wrap: balance;
  }

  .kob-tts-panel.is-dock button:focus-visible{
    outline: 2px solid var(--tts-accent); outline-offset: 2px;
  }

  @supports not ((backdrop-filter: blur(10px))){
    .kob-tts-panel.is-dock{ background: rgba(20,22,28,.85); }
  }
  @media (prefers-reduced-motion: reduce){
    .kob-tts-panel.is-dock, .kob-tts-panel.is-dock button{ transition: none !important; }
  }
  @media print{ .kob-tts-panel.is-dock{ display:none !important; } }

  /* Espaço opcional no conteúdo quando o dock existir */
  body.kob-tts-dock-padding{ padding-left: calc(var(--tts-dock-left) + 72px); }
</style><style>
  .ascii-anim{position:relative;display:block;margin:12px 0}
  .ascii-anim .ascii-frame{transition:opacity .25s ease}
  .ascii-anim .anim-ctrl{
    position:absolute;top:-10px;left:50%;transform:translate(-50%,-100%);
    padding:.4rem .7rem;border:1px solid var(--muted,#89a);
    background:rgba(0,0,0,.3);border-radius:999px;backdrop-filter:blur(4px)
  }
</style><style id="TEXT_BEAUTY_V3">
:root{
  --txt-card: color-mix(in oklab, var(--panel, #0e1220) 92%, black);
  --txt-bd: color-mix(in oklab, var(--ink, #e8ecf6) 16%, transparent);
  --txt-shadow: 0 6px 24px rgba(0,0,0,.25), inset 0 0 0 1px var(--txt-bd);
  --chip-bg: linear-gradient(42deg, var(--grad-a, #7effa1), var(--grad-b, #67e6ff));
  --chip-ink: #000;
  --paren-ink: color-mix(in oklab, var(--ink, #e8ecf6) 92%, white);
}

/* Tipografia base do texto corrido (aplicamos quando detectado bloco .flow-text) */
.flow-text p{
  text-wrap: pretty;
  line-height: 1.65;
  letter-spacing: .01em;
  margin: .65rem 0;
  hyphens: auto;
}

/* Heading leve detectado por “Titulo:” */
.flow-text .kv-head{
  font-weight: 800;
  letter-spacing:.02em;
  margin: 1.2rem 0 .4rem;
}

/* Parênteses → realce sutil */
.span-paren{
  padding: .05rem .35rem;
  border-radius: .55rem;
  border: 1px solid var(--txt-bd);
  color: var(--paren-ink);
  background: color-mix(in oklab, var(--txt-card) 86%, transparent);
}

/* Chips (colchetes) clicáveis */
.chip, .chip-btn{
  display:inline-grid; place-items:center;
  padding:.25rem .6rem; border-radius:999px;
  background: var(--chip-bg); color: var(--chip-ink);
  font-weight: 700; letter-spacing:.02em;
  box-shadow: 0 2px 10px rgba(0,0,0,.35);
  cursor: pointer; user-select: none;
}
.chip + .chip{ margin-left:.35rem; }

/* Pergunta → card */
.q-card{
  background: var(--txt-card);
  border: 1px solid var(--txt-bd);
  box-shadow: var(--txt-shadow);
  border-radius: 14px;
  padding: .85rem 1rem;
  margin: .9rem 0;
  display:grid; grid-template-columns:auto 1fr; gap:.65rem; align-items:start;
}
.q-card .q-ico{
  inline-size:1.65rem; block-size:1.65rem; border-radius:50%;
  display:grid; place-items:center; font-weight:800; color:#000;
  background: var(--chip-bg);
}
.q-card .q-body{ line-height:1.55; }

/* Overlay de copiar nas listas (usa .list-card do patch anterior) */
.list-card{ position:relative; }
.list-card .copy-badge{
  position:absolute; top:.35rem; right:.35rem;
  font-size:.8rem; padding:.2rem .45rem; border-radius:999px;
  background: color-mix(in oklab, #fff 12%, var(--txt-card));
  border: 1px solid var(--txt-bd);
  color: var(--ink, #e8ecf6); opacity:.65; transition:.2s; user-select:none;
}
.list-card:hover .copy-badge{ opacity:1; }

/* Área que receberá HTML “desescapado” */
.raw-html-card{
  background: var(--txt-card); border: 1px dashed var(--txt-bd);
  border-radius: 14px; padding: .85rem 1rem; margin: .9rem 0;
}
.raw-html-card .raw-note{ color: color-mix(in oklab, var(--ink) 62%, transparent); font-size:.85em; margin-bottom:.35rem; }
</style>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#000000">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<link rel="apple-touch-icon" href="icon-192.png"></head>
<body>

  <div id="snap-zone"></div>
  <div class="ambient-light"><div class="blob blob-1"></div><div class="blob blob-2"></div></div>
  <div id="particles-js"><canvas class="particles-js-canvas-el"></canvas></div>

  <div class="top-info" id="topInfo">
    <span id="displayUser">Dual: —</span> · <span id="displayInfodose">Infodose: —</span>
  </div>

  <div class="container">
    <div class="fusion-card closed" id="mainCard">

      <div class="card-header" id="cardHeader">
        <div class="avatar-slot" id="avatarTarget" title="Gerenciar Chaves (Cofre)"></div>
        <div class="text-block">
          <div class="greeting-row">
            <span class="txt-thin" id="lblHello">Oi,</span>
            <span class="txt-heavy" id="lblName">Convidado</span>
          </div>
          <div class="brand-dual">DUAL</div>
        </div>
        <div class="clock-widget">
          <div class="time-display" id="clockTime">00:00</div>
          <span class="status-led">ONLINE</span>
        </div>
        <button class="hud-menu-btn" id="hudMenuBtn" title="Menu Rápido"><i data-lucide="menu"></i></button>
      </div>
      
      <div class="orb-menu-trigger" id="orbMenuTrigger" title="Menu Rápido">●●●</div>
      <div class="drag-handle"></div>

      <div class="small-preview" id="smallPreview" title="Gerenciar Chaves">
        <div class="mini-avatar" id="smallMiniAvatar"></div>
        <div class="small-text" id="smallText">Aguardando ativação...</div>
        <div class="ident-badge" id="smallIdent">--</div>
      </div>

      <div class="card-body" id="cardBody">
        <div class="input-wrapper stagger-item">
          <input type="text" class="cyber-input" id="inputUser" placeholder="Identifique-se..." autocomplete="off">
        </div>

        <div class="activation-wrap stagger-item">
          <div class="activation-toggle" onclick="toggleSection('activationCard')">
            <div style="display:flex;align-items:center;gap:8px">
              <div style="width:10px;height:10px;border-radius:99px;background:var(--neon-cyan)"></div>
              <strong style="letter-spacing:1px;font-size:0.9rem">Ativação ASCII</strong>
            </div>
            <div style="margin-left:auto;font-size:0.82rem;color:rgba(255,255,255,0.6)">BASE v1</div>
          </div>
          <div id="activationCard" class="activation-card activation-hidden">
            <div style="display:flex;align-items:flex-start;gap:10px">
              <div style="display:flex;align-items:center;gap:8px">
                <div class="mini-avatar" id="actMiniAvatar"></div>
                <div><div style="font-weight:700">CÉREBRO</div><div style="font-size:0.78rem;opacity:0.6"><span id="actName">User</span></div></div>
              </div>
              <div class="activation-badge" id="actBadge" style="margin-left:auto">v:--</div>
            </div>
            <pre id="actPre" class="activation-pre">Carregando...</pre>
            <div class="activation-controls" style="display:flex;gap:8px;margin-top:8px">
              <button class="trigger-btn" id="copyActBtn">COPIAR</button>
              <button class="trigger-btn" id="downloadActBtn">PNG</button>
            </div>
          </div>
        </div>

        <div class="activation-wrap stagger-item">
            <div class="activation-toggle" onclick="toggleSection('systemCard')">
                <div style="display:flex;align-items:center;gap:8px">
                  <div style="width:10px;height:10px;border-radius:99px;background:var(--neon-purple)"></div>
                  <strong style="letter-spacing:1px;font-size:0.9rem">SYSTEM &amp; NEURAL</strong>
                </div>
                <div style="margin-left:auto;font-size:0.82rem;color:rgba(255,255,255,0.6)">REACTIVE</div>
            </div>
            <div id="systemCard" class="activation-card activation-hidden">
                <div class="col">
                   <div class="section-title">IDENTIDADE DA INFODOSE</div>
                   <input type="text" id="infodoseNameInput" placeholder="Nome: World System..." style="width:100%;margin-bottom:8px;padding:8px;border-radius:6px;background:rgba(0,0,0,0.3);border:1px solid rgba(255,255,255,0.1);color:#fff">
                   
                   <div class="section-title" style="margin-top:8px">CONEXÃO NEURAL (SK)</div>
                   <input type="password" id="apiKeyInput" placeholder="sk-or-..." autocomplete="off" style="width:100%;margin-bottom:6px;padding:8px;border-radius:6px;background:rgba(0,0,0,0.3);border:1px solid rgba(255,255,255,0.1);color:#fff">
                   <input type="text" id="modelInput" placeholder="Modelo AI..." style="width:100%;margin-bottom:8px;padding:8px;border-radius:6px;background:rgba(0,0,0,0.3);border:1px solid rgba(255,255,255,0.1);color:#fff">
                   
                  <div class="model-toggle">
  <select id="modelSelect" class="btn btn-sec">
    <option value="" disabled="">Modelo</option>
    <option value="allenai/molmo-2-8b:free">MolMo</option>
    <option value="nvidia/nemotron-3-nano-30b-a3b:free">NemoTron</option>
    <option value="mistralai/devstral-2512:free">DevStral</option>
    <option value="openai/gpt-oss-120b:free">OSS120b</option>
    <option value="custom-model">Custom</option>
  </select>
</div>
                   <div class="section-title" style="margin-top:8px">TREINAMENTO</div>
                   <div style="display:flex;gap:6px">
                       <input type="file" id="trainingUpload" accept=".txt" style="display:none">
                       <button class="trigger-btn" onclick="document.getElementById('trainingUpload').click()" style="padding:8px;flex:1">UPLOAD .TXT</button>
                       <button id="exportTrainingBtn" class="trigger-btn" style="padding:8px;flex:1">BAIXAR</button>
                   </div>
                   <div id="trainingFileName" class="small" style="margin-top:4px;color:#9bd;font-size:0.75rem">Vazio</div>

                   <div class="panel-divider" style="margin:10px 0"></div>

                   <div style="display:flex; flex-direction:column; gap:6px;">
                        <div style="display:flex;align-items:center;gap:6px;font-size:0.85rem">
                            <input type="checkbox" id="assistantActiveCheckbox"> <label>Infodose Ativa</label>
                        </div>
                        <div style="display:flex;align-items:center;gap:6px;font-size:0.85rem">
                            <input type="checkbox" id="trainingActiveCheckbox"> <label>Treinamento Ativo</label>
                        </div>
                        <div style="display:flex;align-items:center;gap:6px;font-size:0.85rem">
                            <input type="checkbox" id="zenModeCheckbox"> <label>Modo Zen</label>
                        </div>
                   </div>

                   <button id="saveSystemBtn" class="trigger-btn" style="margin-top:12px;background:var(--neon-cyan);color:#000;border:none;font-weight:700">SALVAR (MANUAL)</button>
                </div>
            </div>
        </div>

        <div class="stagger-item" style="margin-top:4px">
            <div class="stat-lbl" style="margin-bottom:6px">INTERFACE MODE</div>
            <div style="display:flex; gap:8px;">
                <button class="trigger-btn mode-btn active-mode" id="btnModeCard" onclick="setMode('card')" style="flex:1" title="Modo Padrão">CARD</button>
                <button class="trigger-btn mode-btn" id="btnModeOrb" onclick="setMode('orb')" style="flex:1" title="Flutuante">ORB</button>
                <button class="trigger-btn mode-btn" id="btnModeHud" onclick="setMode('hud')" style="flex:1" title="Barra de Topo">HUD</button>
            </div>
        </div>

      </div>

    </div>
  </div>

  <div class="toaster-wrap" id="toasterWrap"></div>

  <div id="keysModal" class="modal-overlay" aria-hidden="true">
    <div class="keys-card" role="dialog">
      <div class="keys-header">
        <div>
          <div id="keysTitle" style="font-weight:800;font-size:1.1rem;color:var(--neon-cyan)">USER KEYS MANAGER</div>
          <div style="color:rgba(255,255,255,0.6);font-size:0.85rem">Gerencie suas chaves API com segurança local (Cofre).</div>
        </div>
        <button id="closeKeysBtn" class="small-btn">X</button>
      </div>
      <div class="key-list" id="keyList"></div>
      <div class="form-section">
        <div class="form-grid">
          <input id="keyNameInput" placeholder="Nome da chave (ex: Principal)">
          <input id="keyTokenInput" type="password" placeholder="Token / ESK (Opcional)">
        </div>
        <div class="form-row">
          <input id="keyWebhookInput" placeholder="Webhook URL (https://...)" style="flex:1">
          <button id="testWebhookBtn" class="small-btn" title="Testar Conexão">PING</button>
        </div>
        <button id="addKeyBtn" class="small-btn" style="width:100%;margin-top:8px;background:rgba(255,255,255,0.1)">ADICIONAR CHAVE</button>
      </div>
      <div style="display:flex;gap:8px;justify-content:space-between;margin-top:15px;border-top:1px solid rgba(255,255,255,0.05);padding-top:12px">
        <div style="font-size:0.7rem;color:rgba(255,255,255,0.4);display:flex;align-items:center;gap:5px">
          <i data-lucide="shield-check" style="width:14px"></i> <span id="vaultStatusText">Cofre Aberto</span>
        </div>
        <div style="display:flex;gap:8px">
          <button id="lockVaultBtn" class="small-btn danger">BLOQUEAR</button>
          <button id="exportKeysBtn" class="small-btn">Export</button>
          <button id="importKeysBtn" class="small-btn">Import</button>
          <input id="importFileInput" type="file" accept="application/json" style="display:none">
        </div>
      </div>
    </div>
  </div>

  <div id="vaultModal" class="modal-overlay" aria-hidden="true">
    <div class="keys-card">
      <div class="vault-icon"><i data-lucide="lock" style="width:24px;height:24px"></i></div>
      <h3 style="margin:0 0 10px 0;font-weight:800">ACESSO AO COFRE</h3>
      <p style="margin:0 0 15px 0;font-size:0.9rem;color:rgba(255,255,255,0.6)">Seus dados estão criptografados. Digite a senha para desbloquear.</p>
      <input type="password" id="vaultPassInput" class="cyber-input" style="text-align:center;margin-bottom:12px" placeholder="Senha...">
      <div style="display:flex;gap:8px;justify-content:center">
         <button id="vaultCancelBtn" class="small-btn">Cancelar</button>
         <button id="vaultUnlockBtn" class="small-btn active-btn">DESBLOQUEAR</button>
      </div>
    </div>
  </div>

  <div class="response-container" id="response">
    <div class="page initial active">
      <strong>Clique no ◉ e diga “Oi, Dual”.</strong><br>
      <em>Sempre único. Sempre seu.</em>
    </div>
    <div class="response-controls">
      <div class="control-buttons">
        <button class="control-btn copy-button" title="Copiar tudo">
          <svg viewBox="0 0 24 24" width="20"><circle cx="12" cy="12" r="10"></circle><rect x="6" y="6" width="12" height="12"></rect></svg>
        </button>
        <button class="control-btn paste-button" title="Colar">
          <svg viewBox="0 0 24 24" width="20"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="4" x2="12" y2="20"></line></svg>
        </button>
        <button id="toggleBtn" class="control-btn toggle-button" title="Check Connection &amp; Training">
          <svg viewBox="0 0 24 24" width="20" height="20" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path>
            <line x1="12" y1="2" x2="12" y2="12"></line>
          </svg>
        </button>
        <button id="crystalBtn" class="control-btn" title="Cristalizados">
          <svg viewBox="0 0 24 24" width="20" height="20"><path d="M12 2l2.9 6.3L21 10l-5 3.6L17.8 21 12 17.7 6.2 21 7 13.6 2 10l6.1-1.7L12 2z"></path></svg>
        </button>
      </div>
      <div class="pagination">
        <button data-action="prev">⟵</button>
        <span id="pageIndicator">1 / 1</span>
        <button data-action="next">⟶</button>
      </div>
    </div>
  </div>

  <div class="input-container">
    <input id="userInput" type="text" placeholder="Diga: 'oi, Dual'...">
    <button id="sendBtn" title="Enviar">➤</button>
    <button id="voiceBtn" title="Falar">
      <object data="Reset_buttom_Dual-Infodose.svg" type="image/svg+xml" width="36" height="36" style="pointer-events: none;"></object>
    </button>
  </div>

  <div id="crystalModal" class="modal">
    <div class="box">
      <h3>Cristalizados</h3>
      <div class="row" style="margin-bottom:8px">
        <button id="exportAllCrystal" class="btn btn-prim">Exportar todos</button>
        <button id="clearAllCrystal" class="btn btn-sec">Limpar tudo</button>
      </div>
      <div class="crystal-list" id="crystalList"></div>
      <div style="margin-top:12px;display:flex;justify-content:flex-end;gap:8px">
        <button id="closeCrystal" class="btn btn-sec">Fechar</button>
      </div>
    </div>
  </div>

  <div id="mantra-toggle">
    <span id="mantra-text">Do seu jeito. <strong>Sempre</strong> único. <strong>Sempre</strong> seu.</span>
  </div>


  <script>
    lucide.createIcons();

    const els = {
      card: document.getElementById('mainCard'),
      header: document.getElementById('cardHeader'),
      avatarTgt: document.getElementById('avatarTarget'),
      input: document.getElementById('inputUser'),
      lblHello: document.getElementById('lblHello'),
      lblName: document.getElementById('lblName'),
      clock: document.getElementById('clockTime'),
      smallPreview: document.getElementById('smallPreview'),
      smallMiniAvatar: document.getElementById('smallMiniAvatar'),
      smallText: document.getElementById('smallText'),
      smallIdent: document.getElementById('smallIdent'),
      actCard: document.getElementById('activationCard'),
      actPre: document.getElementById('actPre'),
      actName: document.getElementById('actName'),
      actMiniAvatar: document.getElementById('actMiniAvatar'),
      actBadge: document.getElementById('actBadge'),
      securityStatus: document.getElementById('securityStatus'),
      // Buttons
      btnModeCard: document.getElementById('btnModeCard'),
      btnModeOrb: document.getElementById('btnModeOrb'),
      btnModeHud: document.getElementById('btnModeHud'),
      orbMenuTrigger: document.getElementById('orbMenuTrigger'),
      hudMenuBtn: document.getElementById('hudMenuBtn'),
      snapZone: document.getElementById('snap-zone'),
      // Keys UI
      keysModal: document.getElementById('keysModal'),
      keyList: document.getElementById('keyList'),
      keyName: document.getElementById('keyNameInput'),
      keyToken: document.getElementById('keyTokenInput'),
      keyWebhook: document.getElementById('keyWebhookInput'),
      addKeyBtn: document.getElementById('addKeyBtn'),
      closeKeysBtn: document.getElementById('closeKeysBtn'),
      testWebhookBtn: document.getElementById('testWebhookBtn'),
      exportKeysBtn: document.getElementById('exportKeysBtn'),
      importKeysBtn: document.getElementById('importKeysBtn'),
      importFileInput: document.getElementById('importFileInput'),
      lockVaultBtn: document.getElementById('lockVaultBtn'),
      vaultStatusText: document.getElementById('vaultStatusText'),
      // Vault UI
      vaultModal: document.getElementById('vaultModal'),
      vaultPass: document.getElementById('vaultPassInput'),
      vaultUnlock: document.getElementById('vaultUnlockBtn'),
      vaultCancel: document.getElementById('vaultCancelBtn'),
      // New System UI
      systemCard: document.getElementById('systemCard'),
      toggleBtn: document.getElementById('toggleBtn')
    };

    // --- CRYPTO UTILS ---
    const CRYPTO = {
      algo: { name: 'AES-GCM', length: 256 },
      pbkdf2: { name: 'PBKDF2', hash: 'SHA-256', iterations: 100000 },
      salt: window.crypto.getRandomValues(new Uint8Array(16)), 
      async getKey(password, salt) {
        const enc = new TextEncoder();
        const keyMaterial = await window.crypto.subtle.importKey("raw", enc.encode(password), "PBKDF2", false, ["deriveKey"]);
        return window.crypto.subtle.deriveKey({ ...this.pbkdf2, salt: salt }, keyMaterial, this.algo, false, ["encrypt", "decrypt"]);
      },
      async encrypt(data, password) {
        const salt = window.crypto.getRandomValues(new Uint8Array(16));
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const key = await this.getKey(password, salt);
        const encoded = new TextEncoder().encode(JSON.stringify(data));
        const encrypted = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, key, encoded);
        const bundle = { s: Array.from(salt), iv: Array.from(iv), d: Array.from(new Uint8Array(encrypted)) };
        return JSON.stringify(bundle);
      },
      async decrypt(bundleStr, password) {
        try {
          const bundle = JSON.parse(bundleStr);
          const salt = new Uint8Array(bundle.s);
          const iv = new Uint8Array(bundle.iv);
          const data = new Uint8Array(bundle.d);
          const key = await this.getKey(password, salt);
          const decrypted = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, key, data);
          return JSON.parse(new TextDecoder().decode(decrypted));
        } catch(e) { throw new Error("Senha incorreta ou dados corrompidos"); }
      }
    };

    // --- STATE & PERSISTENCE ---
    const STORAGE_KEY = 'fusion_os_data_v2';
    const UI_STATE_KEY = 'fusion_os_ui_state';
    
    let STATE = {
      keys: [], 
      user: 'Convidado',
      isEncrypted: false,
      encryptedData: null
    };
    let SESSION_PASSWORD = null;

    function saveUIState() {
        const mode = state.isOrb ? 'orb' : (state.isHud ? 'hud' : 'card');
        const uiState = {
            mode: mode,
            left: els.card.style.left,
            top: els.card.style.top,
            zen: document.body.classList.contains('zen-mode')
        };
        localStorage.setItem(UI_STATE_KEY, JSON.stringify(uiState));
    }
    
    function loadUIState() {
        const raw = localStorage.getItem(UI_STATE_KEY);
        if(!raw) return;
        try {
            const ui = JSON.parse(raw);
            if(ui.zen) {
                document.body.classList.add('zen-mode');
                document.getElementById('mantra-toggle').classList.add('collapsed');
                if(document.getElementById('zenModeCheckbox')) document.getElementById('zenModeCheckbox').checked = true;
            }
            if (ui.mode === 'orb' || ui.mode === 'hud') {
                els.card.style.transition = 'none'; 
                if (ui.mode === 'orb') {
                    if(ui.left) els.card.style.left = ui.left;
                    if(ui.top) els.card.style.top = ui.top;
                    window.setMode('orb', true);
                } else {
                    window.setMode('hud', true);
                }
                setTimeout(() => els.card.style.transition = '', 200);
            }
        } catch(e) { console.error("UI Load Error", e); }
    }

    function saveData() {
      const payload = { keys: STATE.keys, user: STATE.user };
      if (SESSION_PASSWORD) {
        CRYPTO.encrypt(payload, SESSION_PASSWORD).then(enc => {
          localStorage.setItem(STORAGE_KEY, JSON.stringify({ isEncrypted: true, data: enc }));
          STATE.isEncrypted = true;
          STATE.encryptedData = enc;
          updateSecurityUI();
        });
      } else {
        localStorage.setItem(STORAGE_KEY, JSON.stringify({ isEncrypted: false, data: payload }));
      }
    }

    async function loadData() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (parsed.isEncrypted) {
        STATE.isEncrypted = true;
        STATE.encryptedData = parsed.data;
        updateSecurityUI();
      } else {
        STATE.keys = parsed.data.keys || [];
        STATE.user = parsed.data.user || 'Convidado';
        
        // --- REACTIVE BRIDGE ---
        // Se houver uma chave ativa no cofre, sincroniza com o FusionEngine
        const active = STATE.keys.find(k=>k.active);
        if(active && active.token) {
           FusionEngine.set('apiKey', active.token);
        }
        
        if(STATE.user !== 'Convidado') {
           if(document.getElementById('inputUser')) document.getElementById('inputUser').value = STATE.user;
           updateInterface(STATE.user);
        }

        renderKeysList();
      }
    }

    const hashStr = s => { let h=0xdeadbeef; for(let i=0;i<s.length;i++){h=Math.imul(h^s.charCodeAt(i),2654435761);} return (h^h>>>16)>>>0; };
    const createSvg = (id,sz) => `<svg viewBox="0 0 100 100" width="${sz}" height="${sz}"><defs><linearGradient id="g${id}"><stop offset="0%" stop-color="#00f2ff"/><stop offset="100%" stop-color="#bd00ff"/></linearGradient></defs><circle cx="50" cy="50" r="48" fill="#080b12" stroke="rgba(255,255,255,0.1)"/><circle cx="50" cy="50" r="20" fill="url(#g${id})" opacity="0.9"/></svg>`;
    const createMiniSvg = (name,sz=30) => {
      const s = hashStr(name||'D'); const h1=s%360; const h2=(s*37)%360;
      const grad = `<linearGradient id="gm${s}" x1="0" y1="0" x2="1" y2="1"><stop offset="0" stop-color="hsl(${h1},90%,50%)"/><stop offset="1" stop-color="hsl(${h2},90%,50%)"/></linearGradient>`;
      return `<svg width="${sz}" height="${sz}" viewBox="0 0 32 32"><defs>${grad}</defs><rect width="32" height="32" rx="8" fill="#0a1016"/><circle cx="16" cy="16" r="6" fill="url(#gm${s})"/></svg>`;
    };

    function updateInterface(name){
      const safe = name || 'Convidado';
      els.lblName.innerText = safe;
      els.input.value = safe;
      const activeKey = STATE.keys.find(k=>k.active);
      els.smallIdent.innerText = activeKey ? activeKey.name : '--';
      els.actBadge.innerText = activeKey ? `key:${activeKey.name}` : 'v:--';
      els.smallMiniAvatar.innerHTML = createMiniSvg(safe);
      els.actMiniAvatar.innerHTML = createMiniSvg(safe,36);
      els.actName.innerText = safe;
      els.avatarTgt.innerHTML = createSvg('Main',64);
      const phrases = ["Foco estável.","Ritmo criativo.","Percepção sutil."];
      els.smallText.innerText = activeKey ? `${activeKey.name} [ATIVO]` : (safe==='Convidado'?'Aguardando...':`${safe} · ${phrases[safe.length%phrases.length]}`);
      const line = `+${'-'.repeat(safe.length+4)}+`;
      els.actPre.innerText = `${line}\n| ${safe.toUpperCase()} |\n${line}\nID: ${hashStr(safe).toString(16)}`;

      const tiUser = document.getElementById('displayUser');
      if(tiUser) tiUser.innerText = 'User: ' + safe;
    }

    function updateSecurityUI() {
      if (SESSION_PASSWORD) {
        els.securityStatus.innerText = "COFRE DESTRANCADO"; els.securityStatus.style.color = "var(--neon-success)";
        els.vaultStatusText.innerText = "Cofre Protegido (Destrancado)"; els.lockVaultBtn.innerText = "TRANCAR";
      } else if (STATE.isEncrypted) {
        els.securityStatus.innerText = "CRIPTOGRAFADO"; els.securityStatus.style.color = "var(--neon-gold)";
        els.vaultStatusText.innerText = "Cofre Trancado"; els.lockVaultBtn.innerText = "REDEFINIR";
      } else {
        els.securityStatus.innerText = "SEM PROTEÇÃO"; els.securityStatus.style.color = "rgba(255,255,255,0.5)";
        els.vaultStatusText.innerText = "Cofre Aberto (Sem senha)"; els.lockVaultBtn.innerText = "CRIAR SENHA";
      }
    }

    function renderKeysList(){
      els.keyList.innerHTML = '';
      if(STATE.keys.length===0){ els.keyList.innerHTML = '<div style="color:rgba(255,255,255,0.3);text-align:center;padding:20px">Nenhuma chave armazenada.</div>'; return; }
      STATE.keys.forEach(k=>{
        const div = document.createElement('div');
        div.className = `key-item ${k.active?'active-item':''}`;
        const typeInfo = k.webhook ? '<span style="color:var(--neon-purple)">WEBHOOK</span>' : 'API KEY';
        div.innerHTML = `
          <div class="meta"><div style="font-weight:700;font-size:0.9rem">${escapeHtml(k.name)}</div><div style="font-size:0.75rem;color:rgba(255,255,255,0.5)">${typeInfo}</div></div>
          <div class="actions">
            ${!k.active ? `<button class="small-btn" onclick="setActiveKey('${k.id}')">ATIVAR</button>` : `<span style="font-size:0.7rem;font-weight:700;color:var(--neon-cyan);margin-right:10px">ATIVA</span>`}
            <button class="small-btn danger" onclick="removeKey('${k.id}')"><i data-lucide="trash-2" style="width:14px"></i></button>
          </div>`;
        els.keyList.appendChild(div);
      });
      lucide.createIcons();
    }

    function addKey() {
      const name = els.keyName.value.trim();
      const token = els.keyToken.value.trim();
      const webhook = els.keyWebhook.value.trim();
      if(!name){ showToaster('Nome obrigatório','error'); return; }
      const newKey = { id: Date.now().toString(36), name, token, webhook, active: STATE.keys.length===0 };
      STATE.keys.push(newKey);
      
      // Auto-activate bridge to reactive engine if it's the first key
      if(newKey.active && newKey.token) {
         FusionEngine.set('apiKey', newKey.token);
      }
      saveData(); renderKeysList(); updateInterface(STATE.user);
      els.keyName.value=''; els.keyToken.value=''; els.keyWebhook.value='';
      showToaster('Chave adicionada!', 'success');
    }

    window.removeKey = (id) => {
      if(confirm('Remover chave permanentemente?')){
        STATE.keys = STATE.keys.filter(k=>k.id!==id);
        saveData(); renderKeysList(); updateInterface(STATE.user);
      }
    };

    window.setActiveKey = (id) => {
      let activatedToken = null;
      STATE.keys.forEach(k=> {
        k.active = (k.id===id);
        if(k.active) activatedToken = k.token;
      });
      if(activatedToken) {
        FusionEngine.set('apiKey', activatedToken);
        if(document.getElementById('apiKeyInput')) document.getElementById('apiKeyInput').value = activatedToken;
        showToaster('Chave sincronizada com o Chat.', 'success');
      }
      saveData(); renderKeysList(); updateInterface(STATE.user);
    };

    // --- VAULT EVENTS ---
    els.testWebhookBtn.addEventListener('click', async () => { showToaster('Ping enviado (simulado)','success'); });
    function openManager() {
      if (STATE.isEncrypted && !SESSION_PASSWORD) { els.vaultModal.style.display='flex'; els.vaultPass.focus(); } 
      else { els.keysModal.style.display='flex'; }
    }
    els.vaultUnlock.addEventListener('click', async () => {
      const pass = els.vaultPass.value;
      try {
        const decrypted = await CRYPTO.decrypt(STATE.encryptedData, pass);
        SESSION_PASSWORD = pass; STATE.keys = decrypted.keys; STATE.user = decrypted.user;
        
        const active = STATE.keys.find(k=>k.active);
        if(active && active.token) { 
            FusionEngine.set('apiKey', active.token); 
        }
        
        els.vaultModal.style.display='none'; els.keysModal.style.display='flex'; els.vaultPass.value='';
        renderKeysList(); updateSecurityUI(); showToaster('Cofre destrancado.', 'success');
      } catch(e) { showToaster('Senha incorreta.', 'error'); }
    });
    els.lockVaultBtn.addEventListener('click', () => {
       if (!SESSION_PASSWORD && !STATE.isEncrypted) {
         const newPass = prompt("Defina uma senha para o Cofre:");
         if(newPass) { SESSION_PASSWORD=newPass; saveData(); showToaster("Cofre trancado.", 'success'); }
       } else if (SESSION_PASSWORD) {
         SESSION_PASSWORD=null; els.keysModal.style.display='none'; showToaster("Sessão do cofre encerrada.", 'success');
       } else {
         showToaster("Cofre já criptografado. Desbloqueie para redefinir.", 'error');
       }
       updateSecurityUI();
    });
    els.vaultCancel.addEventListener('click', ()=> els.vaultModal.style.display='none');
    els.closeKeysBtn.addEventListener('click', ()=> els.keysModal.style.display='none');
    els.addKeyBtn.addEventListener('click', addKey);

    // --- CINEMATIC GESTURES & MODES (REFINED V7) ---

    let state = {
        isOrb: false,
        isHud: false,
        isDragging: false,
        timer: null,
        startX: 0,
        startY: 0,
        dragOffsetX: 0,
        dragOffsetY: 0,
        pointerId: null
    };

    const HUD_SNAP_THRESHOLD = 60; // Distância do topo para snapar
    const SWIPE_DOWN_THRESHOLD = 80; // Distância para puxar HUD
    const LONG_PRESS_MS = 350; // Tempo para virar Orb via long press

    // Passive: false para permitir preventDefault() se necessário
    els.card.addEventListener('pointerdown', handleStart, { passive: false });
    window.addEventListener('pointermove', handleMove, { passive: false });
    window.addEventListener('pointerup', handleEnd, { passive: false });

    // Opening Configs
    els.avatarTgt.addEventListener('click', (e)=>{ if(!state.isOrb && !state.isHud) openManager(); });
    els.orbMenuTrigger.addEventListener('click', (e)=>{ e.stopPropagation(); window.setMode('card'); toggleSection('systemCard', true); });
    els.hudMenuBtn.addEventListener('click', (e)=>{ e.stopPropagation(); window.setMode('card'); toggleSection('systemCard', true); });
    
    // Open Config from Header click in HUD Mode
    els.header.addEventListener('click', (e) => {
        if(state.isHud && !state.isDragging && !e.target.closest('.hud-menu-btn')) {
             window.setMode('card');
             toggleSection('systemCard', true);
        }
    });

    els.card.addEventListener('contextmenu', (e)=>{
        if(state.isOrb || state.isHud) { e.preventDefault(); window.setMode('card'); }
    });

    function handleStart(e) {
      // Ignorar interações internas (inputs, textareas)
      if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || (e.target.tagName === 'BUTTON' && !e.target.closest('.orb-menu-trigger'))) return;
      
      // No modo Card, só permitir arrastar pelo Header
      if(!state.isOrb && !state.isHud && !els.header.contains(e.target)) return;

      state.startX = e.clientX;
      state.startY = e.clientY;
      state.pointerId = e.pointerId;

      // Se já for Orb/Hud -> Iniciar arraste imediato
      if(state.isOrb || state.isHud) {
          state.isDragging = true;
          try { els.card.setPointerCapture(e.pointerId); } catch(err){}
          
          const rect = els.card.getBoundingClientRect();
          state.dragOffsetX = e.clientX - rect.left;
          state.dragOffsetY = e.clientY - rect.top;
          els.card.style.transition = 'none';
          return;
      }

      // Se for Card: Iniciar timer de Long Press, mas monitorar movimento para "swipe up"
      state.timer = setTimeout(() => {
          transmuteToOrb(e);
          saveUIState();
      }, LONG_PRESS_MS);
    }
    
    function handleMove(e) {
      // Detecção de Swipe Up / Side Drag no modo Card antes do timer acabar
      if(!state.isOrb && !state.isHud && state.timer) {
          const dx = e.clientX - state.startX;
          const dy = e.clientY - state.startY;
          const dist = Math.hypot(dx, dy);
          
          // Se moveu o suficiente (swipe), cancelar timer e virar Orb imediatamente
          // Lógica: Se arrastar pra cima (dy < -10) ou muito pros lados (dx > 18)
          if (dist > 12 && (dy < -10 || Math.abs(dx) > 18)) { 
              clearTimeout(state.timer); state.timer = null;
              
              // Transmutar e continuar arrastando
              transmuteToOrb(e); 
              
              // Recalcular offset para o drag não "pular"
              const rect = els.card.getBoundingClientRect();
              state.dragOffsetX = e.clientX - rect.left;
              state.dragOffsetY = e.clientY - rect.top;
              try { els.card.setPointerCapture(e.pointerId); } catch(err){}
              els.card.style.transition = 'none';
          }
          
          // Se foi um movimento pequeno (jitter), talvez cancelar se for scroll? 
          // Deixamos o browser decidir o scroll se não for drag.
      }
    
      if(!state.isDragging) return;

      e.preventDefault(); // Prevenir scroll da página enquanto arrasta o Orb/HUD

      if(state.isOrb) {
          const x = e.clientX - state.dragOffsetX;
          const y = e.clientY - state.dragOffsetY;
          els.card.style.left = `${x}px`;
          els.card.style.top = `${y}px`;
          
          if(y < HUD_SNAP_THRESHOLD) els.snapZone.classList.add('active');
          else els.snapZone.classList.remove('active');

      } else if (state.isHud) {
          const deltaY = e.clientY - state.startY;
          if(deltaY > 0) {
             els.card.style.transform = `translateX(-50%) translateY(${deltaY * 0.4}px)`;
             if(deltaY > SWIPE_DOWN_THRESHOLD) els.snapZone.classList.add('active');
             else els.snapZone.classList.remove('active');
          }
      }
    }
    
    function handleEnd(e) {
      if(state.timer){ clearTimeout(state.timer); state.timer=null; }
      
      if(state.isDragging) {
          state.isDragging = false;
          try { els.card.releasePointerCapture && els.card.releasePointerCapture(state.pointerId); } catch(err){}
          els.card.style.transition = ''; 
          els.snapZone.classList.remove('active');

          if(state.isOrb) {
              const rect = els.card.getBoundingClientRect();
              if(rect.top < HUD_SNAP_THRESHOLD) {
                  setMode('hud');
              } else {
                  saveUIState();
              }
          } else if (state.isHud) {
              const deltaY = e.clientY - state.startY;
              if (deltaY > SWIPE_DOWN_THRESHOLD) {
                  const x = e.clientX - 34; 
                  const y = e.clientY - 10;
                  els.card.style.left = `${x}px`;
                  els.card.style.top = `${y}px`;
                  setMode('orb');
              } else {
                  els.card.style.transform = `translateX(-50%) translateY(0)`;
              }
          }
      } else {
          // Clique simples no header do Card (Toggle)
          if(!state.isOrb && !state.isHud && els.header.contains(e.target)) {
               toggleCardState();
          }
      }
      state.pointerId = null;
    }
    
    function transmuteToOrb(eOrX) {
      // Aceita evento ou coordenadas, mas preferimos evento para capturar pointer
      let x, y, ev;
      if(eOrX && eOrX.clientX !== undefined) { ev = eOrX; x = ev.clientX; y = ev.clientY; }
      else { return; } // Precisa de evento para fluidez total

      if(navigator.vibrate) navigator.vibrate(40);
      els.card.classList.add('orb','closed'); 
      els.card.classList.remove('content-visible');
      
      // Centralizar visualmente (será sobrescrito pelo drag move imediato)
      els.card.style.left = (x - 34) + 'px'; 
      els.card.style.top = (y - 34) + 'px';
      
      state.isOrb=true; state.isHud=false;
      
      // Iniciar drag imediatamente
      state.isDragging = true;
      if(ev && ev.pointerId) {
          state.pointerId = ev.pointerId;
          try { els.card.setPointerCapture(ev.pointerId); } catch(e){}
          const rect = els.card.getBoundingClientRect();
          state.dragOffsetX = x - rect.left;
          state.dragOffsetY = y - rect.top;
      }

      updateModeButtons('orb');
    }

    function revertToCard() {
      state.isOrb=false; state.isHud=false;
      els.card.style.transition='all 0.5s var(--ease-smooth)'; 
      els.card.style.left=''; els.card.style.top=''; 
      els.card.style.width=''; els.card.style.height=''; 
      els.card.style.transform='';
      els.card.classList.remove('orb','hud','closed'); 
      setTimeout(()=>els.card.classList.add('content-visible'),300);
    }
    
    window.setMode = (mode, isInitialLoad = false) => {
        updateModeButtons(mode);

        if(mode === 'card') {
            revertToCard();
        } else if (mode === 'orb') {
            state.isOrb = true; state.isHud = false;
            els.card.classList.add('orb', 'closed');
            els.card.classList.remove('hud', 'content-visible');
            els.card.style.transform = 'none';
        } else if (mode === 'hud') {
            state.isHud = true; state.isOrb = false;
            els.card.classList.add('hud', 'closed'); 
            els.card.classList.remove('orb', 'content-visible');
            els.card.style.top = ''; 
            els.card.style.left = ''; 
            els.card.style.transform = '';
        }
        
        if(!isInitialLoad) saveUIState();
    };

    function updateModeButtons(mode) {
        [els.btnModeCard, els.btnModeOrb, els.btnModeHud].forEach(b=>b.classList.remove('active-mode'));
        if(mode==='card') els.btnModeCard.classList.add('active-mode');
        if(mode==='orb') els.btnModeOrb.classList.add('active-mode');
        if(mode==='hud') els.btnModeHud.classList.add('active-mode');
    }

    function toggleCardState() {
      if(els.card.classList.contains('animating')) return;
      const isClosed=els.card.classList.contains('closed'); els.card.classList.add('animating');
      if(isClosed) { els.card.classList.remove('closed'); els.card.animate([{transform:'scale(0.95)',opacity:0.8},{transform:'scale(1)',opacity:1}],{duration:400}).onfinish=()=>{els.card.classList.remove('animating');els.card.classList.add('content-visible');} }
      else { els.card.classList.remove('content-visible'); els.card.animate([{transform:'translateY(0)',opacity:1},{transform:'translateY(10px)',opacity:1}],{duration:200}).onfinish=()=>{els.card.classList.add('closed');els.card.classList.remove('animating');} }
    }
    
    // Helpers
    function escapeHtml(s){ return s ? s.replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])) : ''; }
    function showToaster(txt,type='default'){ const t=document.createElement('div'); t.className=`toaster ${type}`; t.innerText=txt; document.getElementById('toasterWrap').appendChild(t); setTimeout(()=>t.classList.add('show'),10); setTimeout(()=>{t.classList.remove('show');setTimeout(()=>t.remove(),300)},2500); }
    function toggleSection(id, forceOpen = false){ 
        const el = document.getElementById(id);
        const h = el.classList.contains('activation-hidden'); 
        if(forceOpen && !h) return; // Already open
        el.classList.toggle('activation-hidden', !forceOpen && !h); 
        el.classList.toggle('activation-open', forceOpen || h); 
    }
    window.toggleActivation = () => toggleSection('activationCard');

    // Logic Init
    els.input.addEventListener('input', (e)=>{ 
       STATE.user=e.target.value; 
       updateInterface(e.target.value); 
       saveData(); 
    });
    
    // INITIAL LOAD
    setTimeout(()=>{ 
        els.card.classList.add('active'); 
        els.avatarTgt.classList.add('shown'); 
        loadData(); 
        loadUIState(); 
        // FusionEngine is now handled in its own script block
    }, 100);
    setInterval(()=>{ els.clock.innerText = new Date().toLocaleTimeString('pt-BR',{hour:'2-digit',minute:'2-digit'}); },1000);
  </script>

  <script>
    /**
     * FUSION ENGINE (Reactive Store)
     * Centraliza estado e reage automaticamente a mudanças.
     */
    const FusionEngine = {
        state: {
            apiKey: '',
            infodoseName: '',
            modelName: 'nvidia/nemotron-3-nano-30b-a3b:free',
            assistantEnabled: false,
            trainingActive: false,
            zenMode: false,
            trainingText: '',
            trainingFileName: ''
        },
        
        // Loads from localStorage + Defaults
        init() {
            this.state.apiKey = localStorage.getItem('di_apiKey') || '';
            this.state.infodoseName = localStorage.getItem('di_infodoseName') || '';
            this.state.modelName = localStorage.getItem('di_modelName') || this.state.modelName;
            this.state.assistantEnabled = (localStorage.getItem('di_assistantEnabled') === '1');
            this.state.trainingActive = (localStorage.getItem('di_trainingActive') !== '0'); 
            this.state.trainingText = localStorage.getItem('di_trainingText') || '';
            this.state.trainingFileName = localStorage.getItem('di_trainingFileName') || '';
            this.state.zenMode = document.body.classList.contains('zen-mode');

            this.render(); // Initial UI Sync
            this.bindEvents();
            console.log("Fusion Engine v8: Reactive Core Active");
        },

        // Update State & Trigger Reactivity
        set(key, value) {
            this.state[key] = value;
            
            // Persist
            if(key === 'apiKey') localStorage.setItem('di_apiKey', value);
            if(key === 'infodoseName') localStorage.setItem('di_infodoseName', value);
            if(key === 'modelName') localStorage.setItem('di_modelName', value);
            if(key === 'assistantEnabled') localStorage.setItem('di_assistantEnabled', value ? '1' : '0');
            if(key === 'trainingActive') localStorage.setItem('di_trainingActive', value ? '1' : '0');
            if(key === 'trainingText') localStorage.setItem('di_trainingText', value);
            if(key === 'trainingFileName') localStorage.setItem('di_trainingFileName', value);

            // Special Effects
            if(key === 'zenMode') {
                 if(value) {
                     document.body.classList.add('zen-mode');
                     document.getElementById('mantra-toggle').classList.add('collapsed');
                 } else {
                     document.body.classList.remove('zen-mode');
                     document.getElementById('mantra-toggle').classList.remove('collapsed');
                 }
                 // save UI state handles this in main script, but we sync here
            }

            this.render();
            this.triggerVisualPulse();
        },

        // Sync DOM with State
        render() {
             // Top Info
             const iEl = document.getElementById('displayInfodose');
             if(iEl) iEl.innerText = 'Infodose: ' + (this.state.infodoseName || '—');

             // Inputs (if not focused to avoid cursor jumping, or force update if needed)
             const setVal = (id, v) => {
                 const el = document.getElementById(id);
                 if(el && document.activeElement !== el) el.value = v;
             };
             
             setVal('apiKeyInput', this.state.apiKey);
             setVal('modelInput', this.state.modelName);
             setVal('infodoseNameInput', this.state.infodoseName);
             setVal('modelSelect', this.state.modelName); // Select box

             // Toggles
             const setCheck = (id, v) => { const el = document.getElementById(id); if(el) el.checked = v; };
             setCheck('assistantActiveCheckbox', this.state.assistantEnabled);
             setCheck('trainingActiveCheckbox', this.state.trainingActive);
             setCheck('zenModeCheckbox', this.state.zenMode);

             // Labels
             const tLabel = document.getElementById('trainingFileName');
             if(tLabel) tLabel.innerText = this.state.trainingFileName || 'Vazio';

             // Main Toggle Button Logic
             const btn = document.getElementById('toggleBtn');
             if(btn) {
                if(this.state.assistantEnabled) {
                    btn.classList.add('active');
                    btn.title = "Assistant ON";
                } else {
                    btn.classList.remove('active');
                    btn.title = "Assistant OFF";
                }
             }
        },

        // Auto-bind inputs to state (Two-way binding feeling)
        bindEvents() {
            const bind = (id, key, type='text') => {
                const el = document.getElementById(id);
                if(!el) return;
                if(type === 'text' || type === 'select') {
                    el.addEventListener('input', (e) => this.set(key, e.target.value));
                } else if (type === 'checkbox') {
                    el.addEventListener('change', (e) => this.set(key, e.target.checked));
                }
            };

            bind('apiKeyInput', 'apiKey');
            bind('infodoseNameInput', 'infodoseName');
            bind('modelInput', 'modelName');
            bind('modelSelect', 'modelName', 'select');
            bind('assistantActiveCheckbox', 'assistantEnabled', 'checkbox');
            bind('trainingActiveCheckbox', 'trainingActive', 'checkbox');
            bind('zenModeCheckbox', 'zenMode', 'checkbox');

            // Special: Main Toggle Button
            document.getElementById('toggleBtn')?.addEventListener('click', () => {
                this.set('assistantEnabled', !this.state.assistantEnabled);
                showToaster(this.state.assistantEnabled ? 'Assistant ON' : 'Assistant OFF', 'default');
            });
            
            // Visual trigger on Top Info click
            document.getElementById('topInfo')?.addEventListener('click', () => {
                this.triggerVisualPulse();
                this.render(); // Force re-sync
            });
        },

        triggerVisualPulse() {
            const bar = document.getElementById('topInfo');
            if(bar) {
                bar.classList.remove('pulse-update');
                void bar.offsetWidth; // trigger reflow
                bar.classList.add('pulse-update');
            }
        },
        
        // Helper for AI Calls to get current snapshot
        getSnapshot() {
            return { ...this.state };
        }
    };

    // Global Chat Logic (Consuming the Engine)
    const API_ENDPOINT = 'https://openrouter.ai/api/v1/chat/completions';
    const TEMPERATURE = 0.2;
    let conversation = [];
    let pages = [], currentPage = 0, autoAdvance = true;
    const CRYSTAL_KEY = 'di_cristalizados';

    const createEl = (tag, cls, html) => { const e = document.createElement(tag); if (cls) e.className = cls; if (html) e.innerHTML = html; return e; };

    // --- PATCH JS: substituir splitBlocks + renderPaginatedResponse + speakPage/changePage/showLoading ---

    /* simples parser markdown leve */
    function mdToHtml(md){
        if(!md) return '';
        md = md.replace(/```([^`]*)```/gs, (_, code) => '<pre><code>' + escapeHtml(code) + '</code></pre>');
        md = md.replace(/`([^`]+)`/g, (_, c) => '<code>' + escapeHtml(c) + '</code>');
        md = md.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
        md = md.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
        md = md.replace(/\*([^*]+)\*/g, '<em>$1</em>');
        md = md.replace(/(^|\n)[\-\*]\s+(.+?)(?=\n|$)/g, (_, pre, item) => pre + '<li>' + item + '</li>');
        md = md.replace(/(<li>.*<\/li>)/gs, '<ul>$1</ul>');
        const paras = md.split(/\n{2,}/).map(p => p.trim()).filter(Boolean);
        return paras.map(p => '<p>' + p.replace(/\n/g,'<br>') + '</p>').join('');
    }

    const splitBlocks = text => {
        if (!text || !text.trim()) return [['Sem conteúdo.','','']];
        let paras = text.split(/\n\s*\n/).map(p=>p.trim()).filter(Boolean);
        if (paras.length < 3 || paras.length % 3 !== 0) {
            const sens = text.match(/[^\.!\?]+[\.!\?]+/g) || [text];
            paras = sens.map(s=>s.trim()).filter(Boolean);
        }
        const groups = [];
        for (let i=0;i<paras.length;i+=3) groups.push(paras.slice(i,i+3));
        return groups;
    };

    const renderPaginatedResponse = text => {
        try { speechSynthesis.cancel(); } catch(e){}
        autoAdvance = true;
        const respEl = document.getElementById('response');
        Array.from(respEl.querySelectorAll('.page')).forEach(p => { if (!p.classList.contains('initial')) p.remove(); });
        pages = [];
        const groups = splitBlocks(text);
        const titles = ['🎁 Recompensa Inicial','👁️ Exploração e Curiosidade','⚡ Antecipação Vibracional'];

        groups.forEach((tris, gi) => {
            const page = createEl('div', gi===0 ? 'page active' : 'page');
            tris.forEach((body, j) => {
                const cls = j===0 ? 'intro' : j===1 ? 'middle' : 'ending';
                const htmlBody = mdToHtml(body);
                const b = createEl('div','response-block '+cls, `<h3>${titles[j]}</h3><div class="block-body">${htmlBody}</div>`);
                const meta = createEl('div','meta');
                const crystalBtn = createEl('button','crystal-btn','✶');
                crystalBtn.title = 'Cristalizar';
                crystalBtn.addEventListener('click', (ev)=>{
                    ev.stopPropagation();
                    cristalizar({ title: titles[j], content: body });
                    crystalBtn.innerText = '✓'; setTimeout(()=> crystalBtn.innerText = '✶', 1200);
                });
                meta.appendChild(crystalBtn);
                b.appendChild(meta);
                b.dataset.state = '';
                b.addEventListener('click', (ev) => {
                    if (ev.target.closest('.meta')) return;
                    const alreadySpoken = b.dataset.state === 'spoken';
                    if (!alreadySpoken) {
                        try { speechSynthesis.cancel(); } catch(e){}
                        const textToSpeak = b.querySelector('.block-body') ? b.querySelector('.block-body').innerText : body;
                        speakText(textToSpeak);
                        b.classList.add('clicked'); b.dataset.state = 'spoken';
                    } else {
                        b.classList.add('expanded'); b.dataset.state = '';
                        if (!FusionEngine.state.assistantEnabled) FusionEngine.set('assistantEnabled', true);
                        const blockText = `${titles[j]}\n\n${body}`;
                        showLoading('Pulso em Expansão...');
                        speakText('Pulso em Expansão...');
                        conversation.push({ role:'user', content: blockText });
                        callAI();
                    }
                });
                page.appendChild(b);
            });
            page.appendChild(createEl('p','footer-text',`<em>Do seu jeito. <strong>Sempre</strong> único. <strong>Sempre</strong> seu.</em>`));
            const controls = respEl.querySelector('.response-controls');
            if (controls && controls.parentNode) respEl.insertBefore(page, controls);
            else respEl.appendChild(page);
            pages.push(page);
        });
        currentPage = 0;
        const pi = document.getElementById('pageIndicator');
        if (pi) pi.textContent = `1 / ${pages.length}`;
        speakPage(0);
    };

    const speakText = (txt, onend)=> {
      if (!txt) { if (onend) onend(); return; }
      const u = new SpeechSynthesisUtterance(txt);
      u.lang = 'pt-BR'; u.rate = 0.99; u.pitch = 1.1;
      if (window._vozes) u.voice = window._vozes.find(v=>v.lang==='pt-BR') || window._vozes[0];
      if (onend) u.onend = onend;
      speechSynthesis.speak(u);
    };

    const speakPage = i => {
        const page = pages[i]; if (!page) return;
        const body = Array.from(page.querySelectorAll('.block-body')).map(n => n.innerText).join(' ');
        speakText(body, () => {
            if (!autoAdvance) return;
            if (i < pages.length - 1) { changePage(1); speakPage(i+1); } else { speakText('Sempre único, sempre seu.'); }
        });
    };

    const changePage = offset => {
        const np = currentPage + offset; if (np<0 || np>=pages.length) return;
        if (pages[currentPage]) pages[currentPage].classList.remove('active');
        if (pages[np]) pages[np].classList.add('active');
        currentPage = np;
        const pi = document.getElementById('pageIndicator');
        if (pi) pi.textContent = `${currentPage+1} / ${pages.length}`;
    };

    const showLoading = msg => {
        const respEl = document.getElementById('response');
        const controls = respEl.querySelector('.response-controls');
        respEl.querySelectorAll('.page').forEach(p => { if(!p.classList.contains('initial')) p.remove(); });
        const page = createEl('div','page active'); page.appendChild(createEl('p','footer-text',msg));
        if (controls && controls.parentNode) respEl.insertBefore(page, controls);
        else respEl.appendChild(page);
        pages = [page];
        currentPage = 0;
        const pi = document.getElementById('pageIndicator');
        if (pi) pi.textContent = '…';
    };

    async function callAI() {
      const cfg = FusionEngine.getSnapshot();
      if (!cfg.apiKey) {
        alert('Nenhuma API Key ativa! Ative uma chave no Card (Cofre) ou no Painel.');
        return;
      }
      const bodyObj = { model: cfg.modelName, messages: conversation.slice(), temperature: TEMPERATURE };
      const messagesToSend = [];
      if (cfg.assistantEnabled && cfg.trainingActive && cfg.trainingText) messagesToSend.push({ role:'system', content: cfg.trainingText });
      conversation.forEach(m => { if (m.role !== 'system') messagesToSend.push(m); });
      bodyObj.messages = messagesToSend;

      try {
        const resp = await fetch(API_ENDPOINT, {
          method:'POST', headers:{ 'Authorization':`Bearer ${cfg.apiKey}`, 'Content-Type':'application/json' },
          body: JSON.stringify(bodyObj)
        });
        if (!resp.ok) throw new Error('Erro API: ' + resp.status);
        const data = await resp.json();
        const answer = (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) ? data.choices[0].message.content.trim() : 'Resposta vazia';
        conversation.push({ role:'assistant', content: answer });
        renderPaginatedResponse(answer);
      } catch (err) {
        console.error(err);
        const errorMsg = 'Falha na conexão. Verifique se a chave está ativa.';
        conversation.push({ role:'assistant', content: errorMsg });
        renderPaginatedResponse(errorMsg);
      }
    }

    async function sendMessage(){
      const respEl = document.getElementById('response');
      const initPage = respEl.querySelector('.page.initial');
      if (initPage) initPage.remove();
      const input = document.getElementById('userInput');
      const raw = input.value.trim(); if (!raw) return;
      input.value = '';
      speechSynthesis.cancel(); speakText('');

      const cfg = FusionEngine.getSnapshot();

      if (raw.toLowerCase().includes('oi dual')) {
        FusionEngine.set('assistantEnabled', true);
        showLoading('Conectando Dual Infodose...');
        if (cfg.trainingText && cfg.trainingActive) conversation.unshift({ role:'system', content: cfg.trainingText });
      } else { showLoading('Processando...'); }
      conversation.push({ role:'user', content: raw });
      callAI();
    }
    
    function cristalizar({ title, content }) {
      const list = JSON.parse(localStorage.getItem(CRYSTAL_KEY) || '[]');
      const cfg = FusionEngine.getSnapshot();
      list.unshift({ id: Date.now(), title, content, user: document.getElementById('inputUser').value, infodose: cfg.infodoseName, at: new Date().toISOString() });
      localStorage.setItem(CRYSTAL_KEY, JSON.stringify(list)); refreshCrystalList();
    }
    function refreshCrystalList() {
      const list = JSON.parse(localStorage.getItem(CRYSTAL_KEY) || '[]');
      const el = document.getElementById('crystalList'); el.innerHTML = '';
      if (!list.length) { el.innerHTML = '<div class="small">Vazio.</div>'; return; }
      list.forEach(it => {
        const row = createEl('div','crystal-item');
        const left = createEl('div','','<strong>'+it.title+'</strong><div class="small">'+(it.infodose||'')+'</div><div style="margin-top:4px;font-size:0.8em">'+it.content.slice(0,100)+'...</div>');
        const actions = createEl('div','actions');
        const copyBtn = createEl('button','btn btn-sec','Copy'); copyBtn.onclick=()=>navigator.clipboard.writeText(it.content);
        const delBtn = createEl('button','btn btn-sec','Del'); delBtn.onclick=()=>{ 
            const arr=JSON.parse(localStorage.getItem(CRYSTAL_KEY)||'[]'); 
            localStorage.setItem(CRYSTAL_KEY, JSON.stringify(arr.filter(x=>x.id!==it.id))); refreshCrystalList(); 
        };
        actions.append(copyBtn, delBtn); row.append(left, actions); el.appendChild(row);
      });
    }

    // --- SETUP EVENTS ---
    document.addEventListener('DOMContentLoaded', async () => {
      speechSynthesis.onvoiceschanged = () => { window._vozes = speechSynthesis.getVoices(); };

      // Engine Start
      FusionEngine.init();

      try {
        particlesJS('particles-js',{ particles:{ number:{value:24},color:{value:['#0ff','#f0f']}, shape:{type:'circle'},opacity:{value:0.4},size:{value:2.4}, move:{enable:true,speed:1.5} }, retina_detect:true });
      } catch(e) { console.warn('particlesJS init failed', e); }

      document.getElementById('sendBtn').addEventListener('click', sendMessage);
      document.getElementById('userInput').addEventListener('keypress', e => { if (e.key==='Enter') sendMessage(); });
      document.querySelector('[data-action="prev"]').addEventListener('click', () => changePage(-1));
      document.querySelector('[data-action="next"]').addEventListener('click', () => changePage(1));

      // Button "Save Manual" just closes the modal now, since state is reactive
      document.getElementById('saveSystemBtn').addEventListener('click', () => {
         toggleSection('systemCard', false);
         showToaster('Configurações Persistidas', 'success');
      });

      // Crystal
      document.getElementById('crystalBtn').addEventListener('click', ()=>{ refreshCrystalList(); document.getElementById('crystalModal').classList.add('active'); });
      document.getElementById('closeCrystal').addEventListener('click', ()=>document.getElementById('crystalModal').classList.remove('active'));
      document.getElementById('exportAllCrystal').addEventListener('click', ()=>{
          const list = JSON.parse(localStorage.getItem(CRYSTAL_KEY)||'[]');
          if(!list.length) return alert('Nada.');
          const b = new Blob([JSON.stringify(list,null,2)], {type:'application/json'});
          const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download='crystals.json'; a.click();
      });
      document.getElementById('clearAllCrystal').addEventListener('click', ()=>{ localStorage.removeItem(CRYSTAL_KEY); refreshCrystalList(); });

      // Copy/Paste Utils
      const copyBtn = document.querySelector('.control-btn.copy-button');
      if (copyBtn) copyBtn.addEventListener('click', async () => {
        try {
          const text = document.getElementById('response').innerText.trim();
          await navigator.clipboard.writeText(text);
          showToaster('Texto copiado', 'success');
        } catch (e) { showToaster('Falha ao copiar', 'error'); }
      });
      const pasteBtn = document.querySelector('.control-btn.paste-button');
      if (pasteBtn) pasteBtn.addEventListener('click', async () => {
        try {
          const txt = await navigator.clipboard.readText();
          const ui = document.getElementById('userInput');
          if (ui) { ui.value = txt; ui.focus(); showToaster('Conteúdo colado', 'success'); }
        } catch (e) { showToaster('Falha ao colar', 'error'); }
      });

      // Training Upload
      const trainingInput = document.getElementById('trainingUpload');
      const exportTrainingBtn = document.getElementById('exportTrainingBtn');
      if (trainingInput) {
        trainingInput.addEventListener('change', async (ev) => {
          const f = ev.target.files && ev.target.files[0];
          if (!f) return;
          const txt = await f.text();
          FusionEngine.set('trainingText', txt);
          FusionEngine.set('trainingFileName', f.name);
          showToaster('Treinamento carregado e salvo', 'success');
        });
      }
      if (exportTrainingBtn) {
        exportTrainingBtn.addEventListener('click', () => {
          const cfg = FusionEngine.getSnapshot();
          if (!cfg.trainingText) { showToaster('Nenhum treinamento', 'error'); return; }
          const b = new Blob([cfg.trainingText], { type: 'text/plain' });
          const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = (cfg.trainingFileName||'training.txt'); a.click();
        });
      }

      // Keys Export
      const exportKeysBtn = document.getElementById('exportKeysBtn');
      if (exportKeysBtn) exportKeysBtn.addEventListener('click', () => {
        const b = new Blob([JSON.stringify(STATE.keys || [], null, 2)], { type: 'application/json' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = 'keys.json'; a.click();
      });
      // Keys Import
      const importKeysBtn = document.getElementById('importKeysBtn');
      const importFileInput = document.getElementById('importFileInput');
      if (importKeysBtn && importFileInput) {
        importKeysBtn.addEventListener('click', () => importFileInput.click());
        importFileInput.addEventListener('change', async (ev) => {
          const f = ev.target.files && ev.target.files[0];
          if (!f) return;
          try {
            const txt = await f.text();
            const parsed = JSON.parse(txt);
            if (!Array.isArray(parsed)) throw new Error('Formato inválido');
            STATE.keys = parsed;
            saveData(); renderKeysList(); showToaster('Chaves importadas', 'success');
          } catch (e) { showToaster('Erro ao importar', 'error'); }
        });
      }
    });

    // Mantra Toggle
    const mantraBtn = document.getElementById('mantra-toggle');
    const mantraText = document.getElementById('mantra-text');
    let mantraCollapsed = false;
    mantraBtn.addEventListener('click', () => {
      mantraCollapsed = !mantraCollapsed;
      if (mantraCollapsed) {
        mantraBtn.classList.add('collapsed'); document.body.classList.add('zen-mode');
        mantraText.classList.add('fade-out'); setTimeout(()=>{ mantraText.innerHTML = 'USE · TRANSFORME · DEVOLVA'; mantraText.classList.remove('fade-out'); },300);
      } else {
        mantraBtn.classList.remove('collapsed'); document.body.classList.remove('zen-mode');
        mantraText.classList.add('fade-out'); setTimeout(()=>{ mantraText.innerHTML = 'Do seu jeito. <strong>Sempre</strong> único. <strong>Sempre</strong> seu.'; mantraText.classList.remove('fade-out'); },300);
      }
    });
  </script>


<div id="fusion-soft-layer"></div>
<div id="navRoot"></div> 
<script src="https://kodux78k.github.io/oiDual-0i/0RB-0S17.js"></script>



<div class="nebula"></div>
<button id="read-exit" title="Sair do modo leitura (Esc)">← Voltar</button>
<div class="wrap" id="root"><details class="acc" open=""><summary><span class="chev"></span><h2>✨ Builder v2 – Áudio + PDF</h2></summary><div class="sec"><p>Abra o painel “Auto‑Gerar” pelo botão +.</p><div class="demo-cta" style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px"><button class="btn" data-action="demo">Gerar Demo</button><button class="btn" data-action="importar">Auto‑Gerar</button><button class="btn" data-action="md">Exportar .md</button><button class="btn" data-action="pdf">Imprimir (PDF)</button></div></div></details></div>
<div id="toasts"></div>
<div id="fab"><div class="menu">
    <button class="btn" data-action="home">Home</button>
    <button class="btn" data-action="back">Voltar</button>

    <button class="btn" id="btn-tts" data-action="tts">Voz: Off</button>
    <button class="btn" id="btn-tts-sel" data-action="tts-sel">Ler seleção</button>
    <button class="btn" id="btn-tts-stop" data-action="tts-stop">Parar voz</button>
  <button class="btn" data-action="demo">Gerar Demo</button>
    <button class="btn" id="btn-imp" data-action="importar">Auto‑Gerar</button>
  <button class="btn" id="btn-md" data-action="md">Exportar .md</button>
  <button class="btn" id="btn-pdf" data-action="pdf">Imprimir (PDF)</button>
  <button class="btn" id="btn-theme" data-action="theme">Tema: Blue‑1</button>
  <button class="btn" id="btn-reading" data-action="reading">Modo Leitura</button>
</div><button class="fab-btn" id="fab-toggle">＋</button></div>
<div id="imp"><div class="panel">
  <div class="tabs"><div class="tab active" data-tab="text">📝 enviar</div><div class="tab" data-tab="audio">🎙️ Áudio→Texto</div><div class="tab" data-tab="file">📄 Arquivo (PDF/TXT/MD)</div></div>
  <div id="tab-text" class="tab-content active"><textarea id="srcText" placeholder="# PRÓLOGO
Texto aqui..."></textarea><button class="btn" onclick="autoBuild(document.getElementById('srcText').value)">Gerar Livro</button> <button class="btn" onclick="autoBuildNested(document.getElementById('srcText').value)">Gerar (aninhado)</button> <button class="btn" onclick="pasteSrcText()">Colar</button> <button class="btn" id="btn-converter">Converter</button></div>
  <div id="tab-audio" class="tab-content"><textarea id="audioOutput" placeholder="Transcrição aqui..."></textarea><div style="display:flex;gap:8px;margin-top:8px"><button class="btn" id="startRec">🎤 Iniciar</button><button class="btn" id="stopRec">⏹ Parar</button><button class="btn" onclick="autoBuild(document.getElementById('audioOutput').value)">Usar Transcrição</button></div></div>
  <div id="tab-file" class="tab-content"><input type="file" id="fileInput" accept=".pdf,.txt,.md,.rtf, .html"><div id="filePreview" style="margin-top:10px;color:var(--muted);font-size:.9rem"></div></div>
  <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:12px"><button class="btn" onclick="closeImporter()">Fechar</button></div>
</div></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>
const $=(q,r=document)=>r.querySelector(q), $$=(q,r=document)=>[...r.querySelectorAll(q)];
const toast=(m)=>{const t=document.createElement('div');t.className='toast';t.textContent=m;document.body.querySelector('#toasts').appendChild(t);setTimeout(()=>t.remove(),2000)}
/* Reading */
function toggleReading(force){const el=document.documentElement; const will = typeof force==='boolean'? force : !el.classList.contains('reading'); el.classList.toggle('reading', will); localStorage.setItem('tl_reading', will?'1':'0'); toast(will?'Modo leitura':'Modo editor');}
document.getElementById('btn-reading').onclick=()=> toggleReading();
document.getElementById('read-exit').onclick=()=> toggleReading(false);
window.addEventListener('keydown',(e)=>{ if(e.key==='Escape') toggleReading(false); if(e.key.toLowerCase()==='r') toggleReading(); if(e.key.toLowerCase()==='t') cycleTheme(); });
/* Theme cycle */
const THEMES=['blue','gold','thermal'];
function setTheme(name){document.documentElement.classList.remove('theme-gold','theme-thermal'); if(name==='gold') document.documentElement.classList.add('theme-gold'); if(name==='thermal') document.documentElement.classList.add('theme-thermal'); localStorage.setItem('tl_theme',name); updateThemeLabel();}
function currentTheme(){return localStorage.getItem('tl_theme')||'blue'} function updateThemeLabel(){const map={blue:'Blue‑1',gold:'Gold',thermal:'Thermal'}; document.getElementById('btn-theme').textContent='Tema: '+map[currentTheme()];}
function cycleTheme(){const i=(THEMES.indexOf(currentTheme())+1)%THEMES.length; setTheme(THEMES[i]); toast('Tema: '+(THEMES[i]==='blue'?'Blue‑1':THEMES[i]==='gold'?'Gold':'Thermal'));}
document.getElementById('btn-theme').onclick=cycleTheme;
/* FAB & Tabs */
document.getElementById('fab-toggle').onclick=()=> document.getElementById('fab').classList.toggle('open');
document.getElementById('btn-imp').onclick=()=> openImporter(); document.getElementById('btn-pdf').onclick=()=> window.print();
function openImporter(){document.getElementById('imp').style.display='block'} function closeImporter(){document.getElementById('imp').style.display='none'}
document.querySelectorAll('.tab').forEach(t=>t.onclick=()=>{document.querySelectorAll('.tab,.tab-content').forEach(e=>e.classList.remove('active'));t.classList.add('active');document.getElementById('tab-'+t.dataset.tab).classList.add('active')})
/* Audio */
let rec;if('webkitSpeechRecognition' in window||'SpeechRecognition' in window){const SR=window.SpeechRecognition||window.webkitSpeechRecognition;rec=new SR();rec.lang='pt-BR';rec.continuous=true;rec.interimResults=true;rec.onresult=(e)=>{let txt='';for(let i=e.resultIndex;i<e.results.length;++i)txt+=e.results[i][0].transcript+(e.results[i].isFinal?'. ':'');document.getElementById('audioOutput').value=txt;};rec.onerror=()=>toast('Erro/Permissão negada');}else toast('STT não suportado.');
document.getElementById('startRec').onclick=()=>{try{rec.start();toast('Gravando...')}catch{toast('Não suportado')}};document.getElementById('stopRec').onclick=()=>{try{rec.stop();toast('Parado')}catch{}}
/* Files */

// Removed explicit onclick handler: md button is handled via data-action="md" and window.exportMD
// Legacy duplicate export function retained for reference but unused
function exportMD_deprecated(){
  const parts=[];
  document.querySelectorAll('#root details.acc').forEach(d=>{
    const h=d.querySelector('summary h2'); if(h) parts.push('# '+h.textContent.trim());
    d.querySelectorAll('.sec > *').forEach(node=>{
      if(node.matches('p')) parts.push(node.innerText.trim());
      else if(node.matches('blockquote')) parts.push('> '+node.innerText.replace('Copiar','').trim());
      else if(node.matches('pre.md-code')) parts.push('```\n'+(node.querySelector('code')?.textContent||'')+'\n```');
      else if(node.matches('.equation')) parts.push('$$\n'+node.innerText.replace('Copiar','').trim()+'\n$$');
      else if(node.matches('ul.md-task')){
        node.querySelectorAll('li').forEach(li=>{
          const chk=li.querySelector('input[type=checkbox]'); const t=li.innerText.replace('Copiar','').trim();
          parts.push(`- [${chk&&chk.checked?'x':' '}] ${t}`);
        });
      }else if(node.matches('ul,ol')){
        const isOl=node.matches('ol'); let idx=1;
        node.querySelectorAll('li').forEach(li=>{
          const txt=li.innerText.trim();
          parts.push((isOl? (idx++)+'. ' : '- ')+txt);
        });
      }else if(node.matches('table.md-table')){
        const rows=[...node.querySelectorAll('tr')].map(tr=>[...tr.children].map(td=>td.innerText.trim()));
        if(rows.length){
          parts.push('| '+rows[0].join(' | ')+' |');
          parts.push('| '+rows[0].map(()=> '---').join(' | ')+' |');
          rows.slice(1).forEach(r=>parts.push('| '+r.join(' | ')+' |'));
        }
      }
    });
  });
  const blob=new Blob([parts.join('\n\n')],{type:'text/markdown'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='export.md'; a.click(); URL.revokeObjectURL(a.href);
  toast('.md exportado');
}

document.getElementById('fileInput').addEventListener('change',async e=>{const f=e.target.files[0];if(!f)return;document.getElementById('filePreview').textContent='Lendo '+f.name+'...'; if(f.name.endsWith('.pdf')){const buf=await f.arrayBuffer();const pdf=await pdfjsLib.getDocument({data:buf}).promise;let txt='';for(let i=1;i<=pdf.numPages;i++){const p=await pdf.getPage(i);const c=await p.getTextContent();txt+=c.items.map(it=>it.str).join(' ')+'\n';}autoBuild(txt);} else {autoBuild(await f.text());}});
/* Builder */


/* Builder (Markdown+ → DOM com seções) */

function autoBuild(text){
  closeImporter();
  const root = document.getElementById('root');
  root.innerHTML = '';

  const AUTO_SPLIT_EVERY = 14;
  let sectionCount = 0, blocksInSection = 0;
  let sec = null;

  function newSection(title){
    sectionCount++;
    const details = document.createElement('details');
    details.className = 'acc';
    details.open = false;
    const sum = document.createElement('summary');
    sum.innerHTML = '<span class="chev"></span><h2>'+ (title || ('Seção '+sectionCount)) +'</h2>';
    const cont = document.createElement('div'); cont.className = 'sec';
    details.append(sum, cont);
    root.appendChild(details);
    blocksInSection = 0;
    return details;
  }
  function ensureSection(titleIfNew){
    if(!sec) sec = newSection(titleIfNew||'Seção 1');
    if(blocksInSection >= AUTO_SPLIT_EVERY){
      sec = newSection((getSummary(sec)+' (cont.)'));
    }
    return sec;
  }
  function getSummary(details){
    const h = details.querySelector('summary h2');
    return h ? h.textContent : 'Seção';
  }
  function appendToSection(el){ ensureSection(); sec.lastChild.appendChild(el); blocksInSection++; }

  const lines = text.replace(/\r\n?/g,'\n').split('\n');
  let i = 0, inCode = false, codeLang = '', buf = [];
  let inFn = false, fnDepth = 0;

  const flushParagraph = ()=>{
    if(!buf.length) return;
    const content = buf.join(' ').trim();
    if(/^\s*(?:export\s+)?function\s+\w+\s*\([^)]*\)\s*\{[^]*\}\s*$/.test(content)){
      const div = document.createElement('div');
      div.className = 'equation copyable fn';
      div.innerHTML = '<span class="copy-hint">Copiar</span>' + content;
      div.onclick = ()=>copy(div);
      appendToSection(div);
      buf.length = 0;
      return;
    }
    const p = document.createElement('p');
    p.innerHTML = inlineMD(content);
    appendToSection(p);
    buf.length = 0;
  };

  while(i < lines.length){
    let line = lines[i];
    let norm = line.replace(/[’‘]/g, "'");

    // cercas de código: ``` e '''
    const mFenceOpen = norm.match(/^\s*(?:```|''')([\w-]+)?\s*$/);
    if(!inCode && mFenceOpen){
      flushParagraph();
      inCode = true; codeLang = (mFenceOpen[1]||'').toLowerCase();
      i++; continue;
    }
    if(inCode){
      const mFenceClose = norm.match(/^\s*(?:```|''')+\s*$/);
      if(mFenceClose){
        const pre = document.createElement('pre');
        pre.className = 'md-code copyable';
        const hint = document.createElement('span'); hint.className = 'copy-hint'; hint.textContent = 'Copiar';
        const code = document.createElement('code');
        if(codeLang) code.className = 'lang-'+codeLang;
        code.textContent = buf.join('\n');
        pre.append(hint, code);
        pre.onclick = ()=>copy(pre);
        appendToSection(pre);
        buf.length = 0; inCode = false; codeLang = '';
      }else{
        buf.push(line);
      }
      i++; continue;
    }

    // função JS multi-linha sem cercas
    if(!inFn){
      const mFnStart = norm.match(/^\s*(?:export\s+)?function\s+\w+\s*\([^)]*\)\s*\{\s*$/);
      if(mFnStart){
        flushParagraph();
        inFn = true; fnDepth = 1; buf.length = 0; i++; continue;
      }
    }
    if(inFn){
      buf.push(line);
      const open = (line.match(/\{/g) || []).length;
      const close = (line.match(/\}/g) || []).length;
      fnDepth += open - close;
      i++;
      if(fnDepth <= 0){
        const div = document.createElement('div');
        div.className = 'equation copyable fn';
        div.innerHTML = '<span class="copy-hint">Copiar</span>' + escapeHtml(buf.join('\\n'));
        div.onclick = ()=>copy(div);
        appendToSection(div);
        buf.length = 0; inFn = false; fnDepth = 0;
      }
      continue;
    }

    // headings
    const mH = line.match(/^\s*(#{1,6})\s+(.+?)\s*$/);
    if(mH){
      flushParagraph();
      sec = newSection(mH[2].trim());
      i++; continue;
    }

    // hr
    if(/^\s*(?:---|\*\*\*)\s*$/.test(line)){
      flushParagraph();
      const hr = document.createElement('div'); hr.className = 'hr';
      appendToSection(hr); i++; continue;
    }

    // blockquotes aninhados
    if(/^\s*>+/.test(line)){
      flushParagraph();
      const items = [];
      while(i < lines.length && /^\s*>+/.test(lines[i])){
        const m = lines[i].match(/^\s*(>+)\s?(.*)$/);
        items.push({ level: m[1].length, text: m[2] });
        i++;
      }
      const rootBQ = document.createElement('blockquote');
      rootBQ.className = 'bq copyable bq-l1';
      rootBQ.innerHTML = '<span class="copy-hint">Copiar</span>';
      let currentLevel = 1;
      const stack = [rootBQ];
      items.forEach(({level, text})=>{
        while(level > currentLevel){
          const inner = document.createElement('blockquote');
          inner.className = 'bq bq-l' + Math.min(currentLevel+1,3);
          stack[stack.length-1].appendChild(inner);
          stack.push(inner);
          currentLevel++;
        }
        while(level < currentLevel){
          stack.pop();
          currentLevel--;
        }
        const div = document.createElement('div');
        div.className = 'bq-line';
        div.innerHTML = inlineMD(text);
        stack[stack.length-1].appendChild(div);
      });
      rootBQ.onclick = ()=>copy(rootBQ);
      appendToSection(rootBQ);
      continue;
    }

    // callouts estendidos
    const mCallAny = norm.match(/^\s*(::(info|warn|tip|note|success|danger)|::\.|:|\?)\s+(.*)$/i);
    if(mCallAny){
      flushParagraph();
      let kind = 'note';
      if(mCallAny[1] === '::.') kind = 'aside';
      else if(mCallAny[1] === ':') kind = 'note';
      else if(mCallAny[1] === '?') kind = 'question';
      else kind = (mCallAny[2] || 'info').toLowerCase();

      let textBuf = [mCallAny[3]];
      let j = i + 1;
      while (j < lines.length) {
        const nextLine = lines[j];
        const nextNorm = nextLine.replace(/[’‘]/g, "'").trim();
        // stop if blank line or another callout marker encountered
        if (nextNorm === '') break;
        if (/^\s*(::(info|warn|tip|note|success|danger)|::\.|:|\?)\s+/i.test(nextNorm)) break;
        textBuf.push(nextLine.trim());
        j++;
      }
      i = j;
      const div = document.createElement('div');
      div.className = 'callout copyable ' + kind;
      div.innerHTML = '<span class="copy-hint">Copiar</span>' + inlineMD(textBuf.join(' '));
      div.onclick = ()=>copy(div);
      appendToSection(div);
      continue;
    }

    // math $$ … $$
    if(/^\s*\$\$\s*$/.test(line)){
      flushParagraph(); i++;
      let math = '';
      while(i<lines.length && !/^\s*\$\$\s*$/.test(lines[i])){ math += lines[i++] + '\\n'; }
      const eq = document.createElement('div');
      eq.className = 'equation copyable';
      eq.innerHTML = '<span class="copy-hint">Copiar</span>'+ escapeHtml(math.trim());
      eq.onclick = ()=>copy(eq);
      appendToSection(eq);
      if(i<lines.length) i++;
      continue;
    }

    // table
    if(/^\s*\|.*\|\s*$/.test(line)){
      flushParagraph();
      let rows = [ line ];
      while(i+1<lines.length && /^\s*\|.*\|\s*$/.test(lines[i+1])){ rows.push(lines[++i]); }
      const tbl = document.createElement('table'); tbl.className='md-table';
      rows.forEach((r,idx)=>{
        const tr = document.createElement('tr');
        const cells = r.trim().slice(1,-1).split('|').map(c=>c.trim());
        const isSep = (idx===1 && cells.every(x=>/^:?-{3,}:?$/.test(x)));
        if(isSep) return;
        cells.forEach(c=>{
          const cell = document.createElement((idx===0)?'th':'td');
          cell.innerHTML = inlineMD(c);
          tr.appendChild(cell);
        });
        tbl.appendChild(tr);
      });
      appendToSection(tbl); i++; continue;
    }

    // listas
    const mLi = line.match(/^\s*(?:([-*+])\s+|\d+\.\s+)(.+)$/);
    if(mLi){
      flushParagraph();
      const ordered = /^\s*\d+\.\s+/.test(line);
      const list = document.createElement(ordered?'ol':'ul');
      list.className = 'md-list';
      while(i<lines.length){
        const l = lines[i];
        if(!/^\s*(?:[-*+]\s+|\d+\.\s+)/.test(l)) break;
        const raw = l.replace(/^\s*(?:[-*+]\s+|\d+\.\s+)/,'');
        const task = raw.match(/^\s*\[( |x|X)\]\s*(.*)$/);
        const li = document.createElement('li');
        li.className = 'md-li';
        if(task){
          if(!list.classList.contains('md-task')) list.classList.add('md-task');
          const box = document.createElement('input'); box.type='checkbox'; box.checked = /x/i.test(task[1]); box.disabled = true;
          const span = document.createElement('span'); span.innerHTML = inlineMD(task[2]);
          li.append(box, span);
        }else{
          li.innerHTML = inlineMD(raw);
        }
        list.appendChild(li); i++;
      }
      appendToSection(list); continue;
    }

    // parágrafos
    if(line.trim()===''){ flushParagraph(); i++; continue; }
    buf.push(line.trim()); i++;
  }
  flushParagraph();
  toast('Livro gerado!');
}


/* ===== Helpers p/ Markdown inline & util ===== */
function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function autoLink(url){
  try{ const u = new URL(url); return `<a href="${u.href}" target="_blank" rel="noopener">${u.href}</a>`; }catch{return url;}
}

function inlineMD(s){
  s = escapeHtml(s);
  // imagens ![alt](src)
  s = s.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (_,a,src)=>`<img class="md-img" alt="${a}" src="${src}">`);
  // links [txt](url)
  s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (_,t,href)=>`<a href="${href}" target="_blank" rel="noopener">${t}</a>`);
  // inline code
  s = s.replace(/`([^`]+)`/g, (_,c)=> `<code class="code-inline">${c}</code>`);
  // strong + em
  s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  s = s.replace(/(^|[^*])\*([^*]+)\*(?!\*)/g, '$1<em>$2</em>');
  // strike
  s = s.replace(/~~([^~]+)~~/g, '<del>$1</del>');
  // autolink
  s = s.replace(/\bhttps?:\/\/[^\s)]+/g, m => autoLink(m));
  // action buttons: [[btn:act|Label]] and [Label](action:act)
  s = s.replace(/\[\[btn:([a-z0-9_-]+)(?:\|([^\]]+))?\]\]/gi, (_,a,label)=>`<button class="btn action" data-action="${a}">${label?escapeHtml(label):a}</button>`);
  s = s.replace(/\[([^\]]+)\]\(action:([a-z0-9_-]+)\)/gi, (_,label,act)=>`<button class="btn action" data-action="${act}">${escapeHtml(label)}</button>`);
  return s;
}




/* Restore */
(function(){ setTheme(localStorage.getItem('tl_theme')||'blue'); if(localStorage.getItem('tl_reading')==='1') document.documentElement.classList.add('reading'); })();

// ====== TTS (SpeechSynthesis) ======
(function(){
  if(!('speechSynthesis' in window)){ console.warn('SpeechSynthesis não suportado'); return; }
  window.__tts_on = false;
  let __tts_voice = null;
  function pickPTBRVoice(){
    const voices = speechSynthesis.getVoices();
    const cand = voices.find(v => /pt[-_]BR/i.test(v.lang)) || voices.find(v => /pt/i.test(v.lang));
    return cand || voices[0] || null;
  }
  function ensureVoice(){
    if(!__tts_voice){ __tts_voice = pickPTBRVoice(); }
  }
  function speakText(text){
    if(!window.__tts_on) { if(window.toast) toast('Ative a Voz'); return; }
    if(!text || !text.trim()) return;
    ensureVoice();
    speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(text);
    if(__tts_voice) u.voice = __tts_voice;
    u.lang = (__tts_voice && __tts_voice.lang) || 'pt-BR';
    u.rate = 1.0; u.pitch = 1.0; u.volume = 1.0;
    speechSynthesis.speak(u);
  }
  function stopTTS(){ speechSynthesis.cancel(); }
  function getSelectedText(){ return (window.getSelection && String(window.getSelection())) || ''; }
  function setTTS(on){
    window.__tts_on = !!on;
    const b = document.getElementById('btn-tts');
    if(b) b.textContent = 'Voz: ' + (window.__tts_on ? 'On' : 'Off');
    if(window.toast) toast(window.__tts_on ? 'Voz ativada' : 'Voz desativada');
  }
  document.addEventListener('click',(e)=>{
    if(e.target && e.target.id==='btn-tts'){ setTTS(!window.__tts_on); return; }
    if(e.target && e.target.id==='btn-tts-sel'){ const t=getSelectedText(); if(t) speakText(t); else if(window.toast) toast('Selecione um trecho primeiro'); return; }
    if(e.target && e.target.id==='btn-tts-stop'){ stopTTS(); return; }
    if(!window.__tts_on) return;
    const block = e.target.closest('p, li, blockquote, .coach, .callout, .equation, pre, td, th');
    if(!block) return;
    if(e.target.closest('button,a,.emoji-btn,.chip,.btn,#fab,.menu,#ttsDock')) return;
    let text = block.innerText || '';
    text = text.replace('Copiar','').trim();
    if(text) speakText(text);
  });
  if('speechSynthesis' in window){
    speechSynthesis.onvoiceschanged = () => { if(!__tts_voice) __tts_voice = pickPTBRVoice(); };
  }
  window.__tts = { set:setTTS, speak:speakText, stop:stopTTS };
})();
// ====================================

async function copy(el){
  const txt=(el.innerText||'').replace('Copiar','').trim();
  try{ await navigator.clipboard.writeText(txt); toast('Copiado'); }
  catch(e){ console.warn('copy fail', e); }
}

  // Allow pasting clipboard content into the Auto‑Gerar textarea.
  async function pasteSrcText(){
    try{
      const text = await navigator.clipboard.readText();
      const ta = document.getElementById('srcText');
      if(ta){
        ta.value = text || '';
        toast('Colado do clipboard');
      }
    }catch(e){
      console.warn('paste fail', e);
      toast('Falha ao colar');
    }
  }

</script>
<script id="STORAGE_FORCE_BRUTE_V1">
(()=>{ 'use strict';
const NS_VER = 'infodose::v3::';
const SUSPECT = ['infodose','book','reject','metalux','kodux','livro','tl_','LIVRO_LIB_V','LIVRO_CUR_V'];
function isSuspect(k){ return SUSPECT.some(p=>k.toLowerCase().includes(p)); }
function now(){return new Date().toISOString().replace(/[:.]/g,'-');}
function backupKey(k){
  const v = localStorage.getItem(k);
  if(v!==null){ localStorage.setItem(`backup::${k}::${Date.now()}`, v); }
}
function migrateAndClean(){
  try{
    // Migrate JSON suspect keys into namespaced infodose::v3::<safe>
    const keys = Object.keys(localStorage);
    for(const k of keys){
      if(k.startsWith(NS_VER)) continue;
      if(!isSuspect(k)) continue;
      const raw = localStorage.getItem(k);
      try{
        const val = JSON.parse(raw);
        // save under safe key
        const safeKey = k.replace(/[^a-z0-9]/gi,'_').toLowerCase();
        localStorage.setItem(`${NS_VER}${safeKey}`, JSON.stringify(Object.assign({}, val, {version:3})));
        backupKey(k);
      }catch(e){
        // not JSON, backup then remove
        backupKey(k);
      }
    }
    // Now remove suspect keys that are outside namespace
    for(const k of Object.keys(localStorage)){
      if(k.startsWith(NS_VER)) continue;
      if(isSuspect(k)){
        // Already backed up above; remove to avoid old code pulling it
        localStorage.removeItem(k);
      }
    }
    // Mark done
    localStorage.setItem(`${NS_VER}__migration_done`, now());
    console.info('[FORCE_BRUTE] migration+clean done');
  }catch(e){
    console.error('[FORCE_BRUTE] failed', e);
  }
}
window.addEventListener('DOMContentLoaded', ()=>{
  try{
    const done = localStorage.getItem(`${NS_VER}__migration_done`);
    if(!done){
      // run migration/clean
      migrateAndClean();
      // reload to let app start fresh
      try{ location.reload(); }catch(e){ console.warn('reload failed', e); }
    }
  }catch(e){ console.error(e); }
});
})();

function autoBuildNested(text){
  closeImporter();
  const root = document.getElementById('root');
  root.innerHTML = '';

  const stack = [];
  function newSectionAt(level, title){
    const details = document.createElement('details');
    details.className = 'acc';
    details.open = false;
    const sum = document.createElement('summary');
    sum.innerHTML = '<span class="chev"></span><h2>'+ title +'</h2>';
    const cont = document.createElement('div'); cont.className = 'sec';
    details.append(sum, cont);
    const parentContainer = stack.length ? stack[stack.length-1].container : root;
    parentContainer.appendChild(details);
    stack.push({level, details, container: cont});
  }
  function currentContainer(){ return stack.length ? stack[stack.length-1].container : root; }

  const lines = text.replace(/\r\n?/g,'\n').split('\n');
  let i = 0, inCode = false, codeLang = '', buf = [];
  let inFn = false, fnDepth = 0;
  // RAW HTML inline (iframe, video, etc.) para o builder aninhado
  const RX_RAW_INLINE = /^\s*<\s*(iframe|video|audio|img|figure|div|section|article|embed|object|svg)\b/i;
    const flushParagraph = ()=>{
    if(!buf.length) return;
    const content = buf.join(' ').trim();

    // Bloco de função inteira (continua igual)
    if(/^\s*(?:export\s+)?function\s+\w+\s*\([^)]*\)\s*\{[^]*\}\s*$/.test(content)){
      const div = document.createElement('div');
      div.className = 'equation copyable fn';
      div.innerHTML = '<span class="copy-hint">Copiar</span>' + content;
      div.onclick = ()=>copy(div);
      currentContainer().appendChild(div);
      buf.length = 0;
      return;
    }

    // 🔥 HTML inline (iframe, video, etc.) — renderiza como HTML real
    if(/^\s*</.test(content) && RX_RAW_INLINE.test(content)){
      const wrap = document.createElement('div');
      wrap.innerHTML = content;
      currentContainer().appendChild(wrap);
      buf.length = 0;
      return;
    }

    // Padrão: parágrafo markdown
    const p = document.createElement('p');
    p.innerHTML = inlineMD(content);
    currentContainer().appendChild(p);
    buf.length = 0;
  };

  while(i < lines.length){
    let line = lines[i];
    let norm = line.replace(/[’‘]/g, "'");

    // headings aninhados
    const mH = line.match(/^\s*(#{1,6})\s+(.+?)\s*$/);
    if(mH){
      flushParagraph();
      const level = mH[1].length, title = mH[2].trim();
      while(stack.length && stack[stack.length-1].level >= level) stack.pop();
      newSectionAt(level, title);
      i++; continue;
    }

    // code fences
    const mFenceOpen = norm.match(/^\s*(?:```|''')([\w-]+)?\s*$/);
    if(!inCode && mFenceOpen){
      flushParagraph();
      inCode = true; codeLang = (mFenceOpen[1]||'').toLowerCase();
      i++; continue;
    }
    if(inCode){
      const mFenceClose = norm.match(/^\s*(?:```|''')+\s*$/);
      if(mFenceClose){
        const pre = document.createElement('pre');
        pre.className = 'md-code copyable';
        const hint = document.createElement('span'); hint.className = 'copy-hint'; hint.textContent = 'Copiar';
        const code = document.createElement('code');
        if(codeLang) code.className = 'lang-'+codeLang;
        code.textContent = buf.join('\n');
        pre.append(hint, code);
        pre.onclick = ()=>copy(pre);
        currentContainer().appendChild(pre);
        buf.length = 0; inCode = false; codeLang = '';
      }else{
        buf.push(line);
      }
      i++; continue;
    }

    // função multi-linha
    if(!inFn){
      const mFnStart = norm.match(/^\s*(?:export\s+)?function\s+\w+\s*\([^)]*\)\s*\{\s*$/);
      if(mFnStart){
        flushParagraph();
        inFn = true; fnDepth = 1; buf.length = 0; i++; continue;
      }
    }
    if(inFn){
      buf.push(line);
      const open = (line.match(/\{/g) || []).length;
      const close = (line.match(/\}/g) || []).length;
      fnDepth += open - close;
      i++;
      if(fnDepth <= 0){
        const div = document.createElement('div');
        div.className = 'equation copyable fn';
        div.innerHTML = '<span class="copy-hint">Copiar</span>' + escapeHtml(buf.join('\\n'));
        div.onclick = ()=>copy(div);
        currentContainer().appendChild(div);
        buf.length = 0; inFn = false; fnDepth = 0;
      }
      continue;
    }

    // hr
    if(/^\s*(?:---|\*\*\*)\s*$/.test(line)){
      flushParagraph();
      const hr = document.createElement('div'); hr.className = 'hr';
      currentContainer().appendChild(hr); i++; continue;
    }

    // blockquotes aninhados
    if(/^\s*>+/.test(line)){
      flushParagraph();
      const items = [];
      while(i < lines.length && /^\s*>+/.test(lines[i])){
        const m = lines[i].match(/^\s*(>+)\s?(.*)$/);
        items.push({ level: m[1].length, text: m[2] });
        i++;
      }
      const rootBQ = document.createElement('blockquote');
      rootBQ.className = 'bq copyable bq-l1';
      rootBQ.innerHTML = '<span class="copy-hint">Copiar</span>';
      let currentLevel = 1;
      const stackBQ = [rootBQ];
      items.forEach(({level, text})=>{
        while(level > currentLevel){
          const inner = document.createElement('blockquote');
          inner.className = 'bq bq-l' + Math.min(currentLevel+1,3);
          stackBQ[stackBQ.length-1].appendChild(inner);
          stackBQ.push(inner);
          currentLevel++;
        }
        while(level < currentLevel){
          stackBQ.pop();
          currentLevel--;
        }
        const divLine = document.createElement('div');
        divLine.className = 'bq-line';
        divLine.innerHTML = inlineMD(text);
        stackBQ[stackBQ.length-1].appendChild(divLine);
      });
      rootBQ.onclick = ()=>copy(rootBQ);
      currentContainer().appendChild(rootBQ);
      continue;
    }

    // callouts estendidos
    const mCallAny = norm.match(/^\s*(::(info|warn|tip|note|success|danger)|::\.|:|\?)\s+(.*)$/i);
    if(mCallAny){
      flushParagraph();
      let kind = 'note';
      if(mCallAny[1] === '::.') kind = 'aside';
      else if(mCallAny[1] === ':') kind = 'note';
      else if(mCallAny[1] === '?') kind = 'question';
      else kind = (mCallAny[2] || 'info').toLowerCase();

      let textBuf = [mCallAny[3]];
      let j = i + 1;
      while (j < lines.length) {
        const nextLine = lines[j];
        const nextNorm = nextLine.replace(/[’‘]/g, "'").trim();
        if (nextNorm === '') break;
        if (/^\s*(::(info|warn|tip|note|success|danger)|::\.|:|\?)\s+/i.test(nextNorm)) break;
        textBuf.push(nextLine.trim());
        j++;
      }
      i = j;
      const div = document.createElement('div');
      div.className = 'callout copyable ' + kind;
      div.innerHTML = '<span class="copy-hint">Copiar</span>' + inlineMD(textBuf.join(' '));
      div.onclick = ()=>copy(div);
      currentContainer().appendChild(div);
      continue;
    }

    // math $$ … $$
    if(/^\s*\$\$\s*$/.test(line)){
      flushParagraph(); i++;
      let math = '';
      while(i<lines.length && !/^\s*\$\$\s*$/.test(lines[i])){ math += lines[i++] + '\\n'; }
      const eq = document.createElement('div');
      eq.className = 'equation copyable';
      eq.innerHTML = '<span class="copy-hint">Copiar</span>'+ escapeHtml(math.trim());
      eq.onclick = ()=>copy(eq);
      currentContainer().appendChild(eq);
      if(i<lines.length) i++;
      continue;
    }

    // table
    if(/^\s*\|.*\|\s*$/.test(line)){
      flushParagraph();
      let rows = [ line ];
      while(i+1<lines.length && /^\s*\|.*\|\s*$/.test(lines[i+1])){ rows.push(lines[++i]); }
      const tbl = document.createElement('table'); tbl.className='md-table';
      rows.forEach((r,idx)=>{
        const tr = document.createElement('tr');
        const cells = r.trim().slice(1,-1).split('|').map(c=>c.trim());
        const isSep = (idx===1 && cells.every(x=>/^:?-{3,}:?$/.test(x)));
        if(isSep) return;
        cells.forEach(c=>{
          const cell = document.createElement((idx===0)?'th':'td');
          cell.innerHTML = inlineMD(c);
          tr.appendChild(cell);
        });
        tbl.appendChild(tr);
      });
      currentContainer().appendChild(tbl); i++; continue;
    }

    // listas
    const mLi = line.match(/^\s*(?:([-*+])\s+|\d+\.\s+)(.+)$/);
    if(mLi){
      flushParagraph();
      const ordered = /^\s*\d+\.\s+/.test(line);
      const list = document.createElement(ordered?'ol':'ul');
      list.className = 'md-list';
      while(i<lines.length){
        const l = lines[i];
        if(!/^\s*(?:[-*+]\s+|\d+\.\s+)/.test(l)) break;
        const raw = l.replace(/^\s*(?:[-*+]\s+|\d+\.\s+)/,'');
        const task = raw.match(/^\s*\[( |x|X)\]\s*(.*)$/);
        const li = document.createElement('li');
        li.className = 'md-li';
        if(task){
          if(!list.classList.contains('md-task')) list.classList.add('md-task');
          const box = document.createElement('input'); box.type='checkbox'; box.checked = /x/i.test(task[1]); box.disabled = true;
          const span = document.createElement('span'); span.innerHTML = inlineMD(task[2]);
          li.append(box, span);
        }else{
          li.innerHTML = inlineMD(raw);
        }
        list.appendChild(li); i++;
      }
      currentContainer().appendChild(list); continue;
    }

    // parágrafos
    if(line.trim()===''){ flushParagraph(); i++; continue; }
    buf.push(line.trim()); i++;
  }
  flushParagraph();
  toast('Livro (aninhado) gerado!');
}

</script>

<script>
const DEMO_MD = "# Demo \u2014 A\u00e7\u00f5es e Blocos\n\n[[btn:gerar|Gerar (texto do editor)]] [[btn:nested|Gerar (aninhado)]] [[btn:md|Salvar .md]] [[btn:pdf|Imprimir PDF]]\n\n: Esta p\u00e1gina demonstra **bot\u00f5es inline** que executam as MESMAS a\u00e7\u00f5es dos bot\u00f5es do topo.\n\n## Fun\u00e7\u00e3o em aspas (render == equa\u00e7\u00e3o)\n\u201cfunction pulse(t){ return Math.cos(t) * 0.369; }\u201d\n\n## Cita\u00e7\u00f5es\n> n\u00edvel 1\n>> n\u00edvel 2\n>>> n\u00edvel 3\n\n## Callouts\n: Nota simples\n::warn Aten\u00e7\u00e3o\n::. Aside\n? Pergunta\n\n## Lista de tarefas\n- [ ] pendente\n- [x] feita\n\n## Tabela\n| A | B |\n|---|---|\n| 1 | 2 |\n\n## C\u00f3digo (aspas)\n'''js\nconsole.log(\"ok das aspas\");\n'''\n";
const ACTIONS = {
  demo(){ autoBuild(DEMO_MD); },
  gerar(){ const v = (document.getElementById('srcText')?.value||'').trim(); autoBuild(v || DEMO_MD); },
  nested(){ const v = (document.getElementById('srcText')?.value||'').trim(); if(typeof autoBuildNested==='function') autoBuildNested(v || DEMO_MD); else autoBuild(v || DEMO_MD); },
  importar(){ if(typeof openImporter==='function') openImporter(); },
  md(){
    // Call the global exportMD implementation if available.
    if(typeof window.exportMD === 'function') window.exportMD();
  },
  pdf(){ window.print(); },
  reading(){ if(typeof toggleReading==='function') toggleReading(); },
  theme(){ if(typeof cycleTheme==='function') cycleTheme(); },
  limpar(){ const r=document.getElementById('root'); if(r) r.innerHTML=''; toast && toast('Limpou'); },
  tts(){ document.getElementById('btn-tts')?.click(); },
  'tts-sel'(){ document.getElementById('btn-tts-sel')?.click(); },
  'tts-stop'(){ document.getElementById('btn-tts-stop')?.click(); }
};
document.addEventListener('click', (e)=>{
  const a = e.target.closest('[data-action]');
  if(!a) return;
  const act = a.dataset.action;
  if(act && ACTIONS[act]){ e.preventDefault(); ACTIONS[act](a); }
});
</script>


<script>
/* ===== Biblioteca local (Stacks) ===== */
const LIB_NS = 'tl_library_v1';
function libLoad(){ try{ return JSON.parse(localStorage.getItem(LIB_NS)||'[]'); }catch{return []} }
function libSave(arr){ localStorage.setItem(LIB_NS, JSON.stringify(arr)); }
function libAdd(doc){ const arr=libLoad(); arr.unshift(doc); libSave(arr); }
function libDel(id){ libSave(libLoad().filter(d=>d.id!==id)); }
function libUpdate(id, patch){ libSave(libLoad().map(d=> d.id===id? Object.assign({}, d, patch): d)); }
function analyzeMD(md){
  const words=(md.match(/\S+/g)||[]).length;
  const headings=(md.match(/^\s*#/gm)||[]).length;
  const code=(md.match(/^\s*```/gm)||[]).length;
  const quotes=(md.match(/^\s*>/gm)||[]).length;
  return {words, headings, code, quotes};
}

/* ===== Helpers de MD ===== */
function buildMDFromDOM(){
  const parts=[];
  document.querySelectorAll('#root details.acc').forEach(d=>{
    const h=d.querySelector('summary h2'); if(h) parts.push('# '+h.textContent.trim());
    d.querySelectorAll('.sec > *').forEach(node=>{
      if(node.matches('p')) parts.push(node.innerText.trim());
      else if(node.matches('blockquote')) parts.push('> '+node.innerText.replace('Copiar','').trim());
      else if(node.matches('pre.md-code')) parts.push('```\n'+(node.querySelector('code')?.textContent||'')+'\n```');
      else if(node.matches('.equation')) parts.push('$$\n'+node.innerText.replace('Copiar','').trim()+'\n$$');
      else if(node.matches('ul.md-task')){
        node.querySelectorAll('li').forEach(li=>{
          const chk=li.querySelector('input[type=checkbox]'); const t=li.innerText.replace('Copiar','').trim();
          parts.push(`- [${chk&&chk.checked?'x':' '}] ${t}`);
        });
      }else if(node.matches('ul,ol')){
        const isOl=node.matches('ol'); let idx=1;
        node.querySelectorAll('li').forEach(li=>{
          const txt=li.innerText.trim();
          parts.push((isOl? (idx++)+'. ' : '- ')+txt);
        });
      }else if(node.matches('table.md-table')){
        const rows=[...node.querySelectorAll('tr')].map(tr=>[...tr.children].map(td=>td.innerText.trim()));
        if(rows.length){
          parts.push('| '+rows[0].join(' | ')+' |');
          parts.push('| '+rows[0].map(()=> '---').join(' | ')+' |');
          rows.slice(1).forEach(r=>parts.push('| '+r.join(' | ')+' |'));
        }
      }
    });
  });
  return parts.join('\n\n');
}
function getCurrentMarkdown(){ return (window.__current_md && window.__current_md.trim()) ? window.__current_md : buildMDFromDOM(); }
window.exportMD = function(){
  const md = buildMDFromDOM();
  const blob=new Blob([md],{type:'text/markdown'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob);
  const basename = (window.__current_title||'export').replace(/[\\\/:*?"<>|]+/g,'-').slice(0,80)||'export';
  a.download= basename + '.md'; a.click(); URL.revokeObjectURL(a.href);
  toast && toast('.md exportado');
};

/* ===== Bloco Mestre (sempre topo) ===== */
function ensureMasterBlock(){
  const root=document.getElementById('root'); if(!root) return;
  let mb=document.getElementById('masterBlock');
  if(!mb){
    mb=document.createElement('div'); mb.id='masterBlock'; mb.className='master-block';
    root.prepend(mb);
  }
  const safeTitle=(window.__current_title||'').replace(/[<>&]/g, s=>({ '<':'&lt;','>':'&gt;','&':'&amp;' }[s]));
  mb.innerHTML = `<div class="row">
    <input id="docTitle" class="title" placeholder="Título do documento" value="${safeTitle}">
    <button class="btn" data-action="copiar-tudo">Copiar tudo</button>
    <button class="btn" data-action="tts">TTS On/Off</button>
    <button class="btn" data-action="md">Exportar .md</button>
    <button class="btn" data-action="pdf">Imprimir (PDF)</button>
    <button class="btn" data-action="abrir-tudo">Abrir tudo</button>
    <button class="btn" data-action="fechar-tudo">Fechar tudo</button>
    <button class="btn" data-action="save">Salvar</button>
  </div>`;
}

/* ===== Comandos do Bloco Mestre ===== */
function openAll(){ document.querySelectorAll('#root details.acc').forEach(d=> d.open=true); }
function closeAll(){ document.querySelectorAll('#root details.acc').forEach(d=> d.open=false); }
async function copyAll(){
  const md=getCurrentMarkdown();
  try{ await navigator.clipboard.writeText(md); toast && toast('Conteúdo copiado'); }catch(e){ console.warn(e); }
}
function saveCurrent(){
  const md=getCurrentMarkdown();
  const titleInput=document.getElementById('docTitle');
  const title=(titleInput&&titleInput.value.trim()) || (md.match(/^\s*#\s+(.+)$/m)?.[1]) || 'Sem título';
  const now=new Date().toISOString();
  const id='doc_'+Date.now();
  const doc={id,title,md,createdAt:now,updatedAt:now,bytes:md.length};
  libAdd(doc);
  localStorage.setItem('tl_last_doc_id', id);
  toast && toast('Salvo em Stacks');
}

/* ===== Pré-processamento (arrow => $$, aside normalizado) ===== */
function preprocessMD(text){
  const lines = String(text||'').replace(/\r\n?/g,'\n').split('\n');
  const out=[]; let i=0;
  while(i<lines.length){
    let l=lines[i];
    let norm=l.replace(/[’‘]/g,"'").replace(/[“”]/g,'"');

    // ::aside -> ::. ; e garante "::. " (com espaço) quando vazio
    if(/^\s*::aside\b/i.test(norm)){ l = l.replace(/^\s*::aside\b/i, '::.'); norm=l.replace(/[’‘]/g,"'").replace(/[“”]/g,'"'); }
    if(/^\s*::\.\s*$/.test(norm)){ l = '::. '; norm = l; }

    // Arrow block multilinha com chaves
    if(/^\s*(?:const|let|var)\s+[A-Za-z_$][\w$]*\s*=\s*(?:\([^)]*\)|[A-Za-z_$][\w$]*)\s*=>\s*\{\s*$/.test(norm)){
      const buf=[l]; let depth=((l.match(/\{/g)||[]).length - (l.match(/\}/g)||[]).length); i++;
      while(i<lines.length){
        buf.push(lines[i]);
        depth += ((lines[i].match(/\{/g)||[]).length - (lines[i].match(/\}/g)||[]).length);
        i++;
        if(depth<=0) break;
      }
      out.push('$$'); out.push(...buf); out.push('$$'); continue;
    }
    // Função citada "function ... { ... }"
    let m = norm.match(/^[\"']\s*((?:export\s+)?function\s+[A-Za-z_$][\w$]*\s*\([^)]*\)\s*\{[^}]*\})\s*[\"']\s*$/);
    if(m){ out.push('$$'); out.push(m[1]); out.push('$$'); i++; continue; }
    // Arrow citada "const f = ... => ..."
    let m2 = norm.match(/^[\"']\s*((?:const|let|var)\s+[A-Za-z_$][\w$]*\s*=\s*(?:\([^)]*\)|[A-Za-z_$][\w$]*)\s*=>\s*(?:\{[^}]*\}|[^;]+;?))\s*[\"']\s*$/);
    if(m2){ out.push('$$'); out.push(m2[1]); out.push('$$'); i++; continue; }
    // Arrow one-liner
    if(/^\s*(?:const|let|var)\s+[A-Za-z_$][\w$]*\s*=\s*(?:\([^)]*\)|[A-Za-z_$][\w$]*)\s*=>\s*(?:\{[^}]*\}|[^;]+;?)\s*$/.test(norm)){
      out.push('$$'); out.push(l); out.push('$$'); i++; continue;
    }
    out.push(l); i++;
  }
  return out.join('\n');
}

/* ===== Envelopa os builders para usar preprocess + bloco mestre ===== */
(function(){
  if(typeof window.autoBuild==='function'){
    const __orig = window.autoBuild;
    window.autoBuild = function(text){
      text = preprocessMD(text||'');
      window.__current_md = text;
      window.__current_title = (text.match(/^\s*#\s+(.+)$/m)||[])[1] || (document.title||'');
      __orig(text);
      ensureMasterBlock();
    }
  }
  if(typeof window.autoBuildNested==='function'){
    const __origN = window.autoBuildNested;
    window.autoBuildNested = function(text){
      text = preprocessMD(text||'');
      window.__current_md = text;
      window.__current_title = (text.match(/^\s*#\s+(.+)$/m)||[])[1] || (document.title||'');
      __origN(text);
      ensureMasterBlock();
    }
  }
})();

/* ===== Home (stacks) ===== */
function renderWelcome(){
const name =
  localStorage.getItem('tl_user_name') ||
  localStorage.getItem('di_userName') ||
  '';
  const root = document.getElementById('root');
  const stacks = libLoad();
  const cards = stacks.map(d=>{
    const a = analyzeMD(d.md);
    const dt = new Date(d.updatedAt||d.createdAt||Date.now()).toLocaleString();
    return `
    <div class="stack-card">
      <h4>${escapeHtml(d.title||'Sem título')}</h4>
      <div class="meta">${dt} · ${a.words} palavras</div>
      <div class="row">
        <button class="btn" data-action="open-doc" data-id="${d.id}">Abrir</button>
        <button class="btn" data-action="rename-doc" data-id="${d.id}">Renomear</button>
        <button class="btn" data-action="analisar-doc" data-id="${d.id}">Analisar</button>
        <button class="btn" data-action="md-doc" data-id="${d.id}">Exportar .md</button>
        <button class="btn" data-action="del-doc" data-id="${d.id}">Excluir</button>
      </div>
    </div>`;
  }).join('');

  root.innerHTML = `
  <details class="acc" open>
    <summary><span class="chev"></span><h2>👋 Boas‑vindas${name? (', '+escapeHtml(name)) : ''}</h2></summary>
    <div class="sec">
      <div class="welcome">
        <div class="row" style="gap:8px;align-items:center;">
          <input id="welcomeName" class="field" placeholder="Seu nome" value="${escapeHtml(name)}"/>
          <button class="btn" data-action="save-name">Salvar nome</button>
          <button class="btn" data-action="importar">Enviar Documento</button>
          <button class="btn" data-action="demo">Gerar Demo</button>
          <button class="btn" data-action="gerar">Gerar do Editor</button>
          <button class="btn" data-action="nested">Gerar (aninhado)</button>
          <button class="btn" data-action="md">Exportar .md</button>
          <button class="btn" data-action="pdf">Imprimir (PDF)</button>
          <button class="btn" data-action="reading">Modo Leitura</button>
          <button class="btn" data-action="theme">Trocar Tema</button>
        </div>
        <div class="small" style="margin-top:8px">Stacks salvos no dispositivo:</div>
        <div class="stack-grid">${cards || '<div class="small" style="opacity:.8">Sem documentos salvos ainda.</div>'}</div>
      </div>
    </div>
  </details>`;
}

/* ===== Estende ACTIONS ===== */
window.ACTIONS = window.ACTIONS || {};
Object.assign(ACTIONS, {
  'back'(){ try{ if(history.length>1){ history.back(); } else { renderWelcome(); } }catch(e){ renderWelcome(); } },
  
  'abrir-tudo'(){ openAll(); },
  'fechar-tudo'(){ closeAll(); },
  'copiar-tudo'(){ copyAll(); },
  'save'(){ saveCurrent(); },
  'open-doc'(el){ const id = el?.dataset?.id; const doc = libLoad().find(d=>d.id===id); if(!doc) return; autoBuild(doc.md); },
  'del-doc'(el){ const id = el?.dataset?.id; libDel(id); renderWelcome(); toast && toast('Documento removido'); },
  'rename-doc'(el){ const id = el?.dataset?.id; const doc = libLoad().find(d=>d.id===id); if(!doc) return; const novo = prompt('Novo título', doc.title)||''; if(novo.trim()){ libUpdate(id,{title:novo.trim(),updatedAt:new Date().toISOString()}); renderWelcome(); toast && toast('Renomeado'); } },
  'analisar-doc'(el){ const id = el?.dataset?.id; const doc = libLoad().find(d=>d.id===id); if(!doc) return; const a = analyzeMD(doc.md); toast && toast(`Palavras: ${a.words} · H1+: ${a.headings} · Código: ${a.code} · Citações: ${a.quotes}`); },
  'md-doc'(el){ const id = el?.dataset?.id; const doc = libLoad().find(d=>d.id===id); if(!doc) return; const blob=new Blob([doc.md],{type:'text/markdown'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=(doc.title||'documento')+'.md'; a.click(); URL.revokeObjectURL(a.href); },
  'save-name'(){ const el = document.getElementById('welcomeName'); const v=(el&&el.value||'').trim(); if(v){ localStorage.setItem('tl_user_name', v); toast && toast('Nome salvo'); } else { localStorage.removeItem('tl_user_name'); toast && toast('Nome limpo'); } renderWelcome(); },
  'home'(){ renderWelcome(); },
  'welcome'(){ renderWelcome(); }
});

/* ===== Primeira carga: Home ===== */
document.addEventListener('DOMContentLoaded', ()=>{ renderWelcome(); });
</script>


<script id="PATCH_MASTERBLOCK_HOME_BTN_V1">
(()=>{'use strict';
const $=(q,r=document)=>r.querySelector(q);
function ensureHomeInMaster(){
  const area = $('#masterActions');
  if(!area) return;
  if(!area.querySelector('[data-act="home"]')){
    const b = document.createElement('button');
    b.className='chip'; b.textContent='Home'; b.dataset.act='home';
    // Inserir como primeiro botão (antes de Copiar tudo/Iniciar)
    area.insertBefore(b, area.firstChild);
  }
  // Delegação de clique para o Master Block
  const block = $('#masterBlock') || document;
  if(!block.dataset.boundHomeAct){
    block.dataset.boundHomeAct='1';
    block.addEventListener('click', (e)=>{
      const t = e.target.closest('[data-act="home"]'); if(!t) return;
      // Reusa ACTIONS.home quando disponível; senão fallback para stacks/topo
      if(window.ACTIONS && typeof ACTIONS.home==='function'){ ACTIONS.home(); return; }
      const acc = $('#stackHost details.acc') || $('#stackHost');
      if(acc){ try{ acc.open = true; }catch{}; acc.scrollIntoView({behavior:'smooth', block:'start'}); }
      else window.scrollTo({top:0, behavior:'smooth'});
    }, true);
  }
}
document.addEventListener('DOMContentLoaded', ensureHomeInMaster);
})();</script>

<script id="FAB_MINI_CONFIG">
window.FAB_MINI = window.FAB_MINI || {
  // 'hide' = esconde os outros; 'replace' = troca o menu e mantém só os botões abaixo
  mode: 'replace',
  // incluir Voltar? (false por padrão, como você pediu)
  include_back: false,
  // textos dos botões (pode mudar aqui)
  labels: { autogerar: 'Auto‑Gerar', pdf: 'PDF', tts: 'TTS', home: 'Home', back: 'Voltar' },
  // ganchos do Auto‑Gerar
  autogerar: {
    // roda antes do Auto‑Gerar (ex.: setar tema/seed/clean)
    before: null,
    // override do fluxo de geração; se não definir, tentamos openImporter() → ACTIONS.demo() → autoBuild()
    run: null
  }
};
</script>
<script id="PATCH_FAB_MINI_V1">
(()=>{'use strict';
const $=(q,r=document)=>r.querySelector(q);

const CFG = window.FAB_MINI || (window.FAB_MINI = {
  mode:'replace', include_back:false,
  labels:{ autogerar:'Auto‑Gerar', pdf:'PDF', tts:'TTS', home:'Home', back:'Voltar' },
  autogerar:{ before:null, run:null }
});

function ensureActions(){
  if(!window.ACTIONS) window.ACTIONS = {};

  if(typeof ACTIONS.home!=='function'){
    ACTIONS.home = ()=>{
      if(typeof window.renderWelcome==='function'){ renderWelcome(); return; }
      const acc = $('#stackHost details.acc') || $('#stackHost');
      if(acc){ try{ acc.open = true; }catch{}; acc.scrollIntoView({behavior:'smooth', block:'start'}); }
      else window.scrollTo({top:0, behavior:'smooth'});
    };
  }
  if(typeof ACTIONS.ttsToggle!=='function'){
    ACTIONS.ttsToggle = ()=>{ const b=document.getElementById('btn-tts'); if(b) b.click(); };
  }
  if(typeof ACTIONS.autoGerar!=='function'){
    ACTIONS.autoGerar = ()=>{
      try{ if(typeof CFG.autogerar.before==='function') CFG.autogerar.before(); }catch{}
      if(typeof CFG.autogerar.run==='function') return CFG.autogerar.run();
      if(typeof window.openImporter==='function') return openImporter();
      if(window.ACTIONS?.demo) return ACTIONS.demo();
      if(typeof window.autoBuild==='function') return autoBuild('# Demo\n\n...');
    };
  }
  if(typeof ACTIONS.pdf!=='function'){ ACTIONS.pdf = ()=>window.print(); }
  if(typeof ACTIONS.back!=='function'){
    ACTIONS.back = ()=>{ if(history.length>1) history.back(); else ACTIONS.home?.(); };
  }
}

function rebuildFAB(){
  const menu = $('.fab .menu') || $('#fab .menu') || $('.menu[data-fab]');
  if(!menu) return;

  const keep = ['home','autogerar','tts','pdf']; // ordem desejada
  if(CFG.include_back) keep.splice(1,0,'back'); // opção: Home, Back, Auto‑Gerar, TTS, PDF

  if(CFG.mode==='replace'){
    menu.innerHTML='';
  }else{
    // hide todos os outros
    menu.querySelectorAll('.btn,button,a').forEach(el=>{
      if(!keep.includes(el.dataset.action)) el.style.display='none';
    });
  }

  const make = (act,text)=>{
    const b=document.createElement('button'); b.className='btn'; b.dataset.action=act; b.textContent=text; return b;
  };
  const label = CFG.labels || {};
  keep.forEach(act=>{
    const sel = `[data-action="${act}"]`;
    const txt = label[act] || ({home:'Home',back:'Voltar',autogerar:'Auto‑Gerar',tts:'TTS',pdf:'PDF'})[act];
    const exists = menu.querySelector(sel);
    if(exists){ exists.textContent = txt; exists.style.display=''; }
    else menu.appendChild(make(act, txt));
  });

  if(!menu.dataset.boundMini){
    menu.dataset.boundMini='1';
    menu.addEventListener('click',(e)=>{
      const b=e.target.closest('[data-action]'); if(!b) return;
      const act=b.dataset.action;
      const map = {home:'home',back:'back',autogerar:'autoGerar',tts:'ttsToggle',pdf:'pdf', dts:'ttsToggle'};
      const fn = map[act] && ACTIONS[map[act]];
      if(typeof fn==='function'){ e.preventDefault(); fn(); }
    }, true);
  }
}

document.addEventListener('DOMContentLoaded', ()=>{ ensureActions(); rebuildFAB(); });
})();
</script>

<script id="ORB2D_ENGINE_V1">
(()=>{'use strict';
const $=(q,r=document)=>r.querySelector(q);

const ARQ = window.ARQ || (window.ARQ = {
  current: (localStorage.getItem('tl_arq')||'madeira').toLowerCase(),
  map: {
    madeira: { a:'#36f6a2', b:'#00ffa8', name:'Madeira' },
    agua:    { a:'#67e6ff', b:'#3bd3ff', name:'Água' },
    fogo:    { a:'#ff7a00', b:'#ff3366', name:'Fogo' },
    terra:   { a:'#c8a46e', b:'#8a6c3d', name:'Terra' },
    metal:   { a:'#dfe7ff', b:'#a0b7ff', name:'Metal' },
  }
});

function applyArq(name){
  name = (name||'').toLowerCase();
  const cfg = ARQ.map[name] || ARQ.map.madeira;
  ARQ.current = name in ARQ.map ? name : 'madeira';
  localStorage.setItem('tl_arq', ARQ.current);
  const root = document.documentElement;
  root.style.setProperty('--orb-a', cfg.a);
  root.style.setProperty('--orb-b', cfg.b);
  document.body.dataset.arq = ARQ.current;
  if(window.toast) toast('Arquétipo: '+(cfg.name||name));
  window.dispatchEvent(new CustomEvent('archetypechange',{ detail:{ name: ARQ.current, colors: cfg } }));
}

function ensureOrb(){
  const fab = $('#fab'); if(!fab) return;
  let orb = $('#orb2d');
  if(!orb){
    orb = document.createElement('button');
    orb.id='orb2d'; orb.title='Abrir apps';
    fab.appendChild(orb);
  }
  // quick picker
  let picker = $('#orb-picker');
  if(!picker){
    picker = document.createElement('div');
    picker.id = 'orb-picker';
    picker.innerHTML = `
      <button class="chip" data-arq="madeira">Madeira</button>
      <button class="chip" data-arq="agua">Água</button>
      <button class="chip" data-arq="fogo">Fogo</button>
      <button class="chip" data-arq="terra">Terra</button>
      <button class="chip" data-arq="metal">Metal</button>
    `;
    fab.appendChild(picker);
  }
  // tap toggles menu
  orb.addEventListener('click', ()=> fab.classList.toggle('open'));
  // long press opens picker
  let pressTimer=null;
  orb.addEventListener('pointerdown', ()=>{
    clearTimeout(pressTimer);
    pressTimer = setTimeout(()=> fab.classList.toggle('show-picker'), 500);
  });
  ['pointerup','pointerleave','pointercancel'].forEach(evt=> orb.addEventListener(evt, ()=> clearTimeout(pressTimer)));
  picker.addEventListener('click', (e)=>{
    const b = e.target.closest('[data-arq]'); if(!b) return;
    applyArq(b.dataset.arq);
    fab.classList.remove('show-picker');
  });
}

document.addEventListener('DOMContentLoaded', ()=>{
  ensureOrb();
  applyArq(ARQ.current);
});

// API pública
window.ARQ = Object.assign(ARQ, {
  set: applyArq,
  cycle(){
    const list = Object.keys(ARQ.map);
    const i = Math.max(0, list.indexOf(ARQ.current));
    const next = list[(i+1)%list.length];
    applyArq(next);
  }
});
})();
</script>


<script id="HERBIE_ENGINE_V1">
(()=>{'use strict';
const $=(q,r=document)=>r.querySelector(q);

const HERBIE = window.HERBIE || (window.HERBIE = {
  preset: (localStorage.getItem('herbiePreset')||'blue').toLowerCase(),
  presets: {
    blue:    { a:'#67e6ff', b:'#3bd3ff', name:'Blue' },
    gold:    { a:'#f7d774', b:'#ffcc55', name:'Gold' },
    thermal: { a:'#ff7a00', b:'#ff3366', name:'Thermal' },
  },
  setPreset(name){
    name=(name||'').toLowerCase();
    const p=this.presets[name]||this.presets.blue;
    this.preset = name in this.presets ? name : 'blue';
    localStorage.setItem('herbiePreset', this.preset);
    const root=document.documentElement;
    root.style.setProperty('--orb-a', p.a);
    root.style.setProperty('--orb-b', p.b);
    window.dispatchEvent(new CustomEvent('herbiechange',{detail:{ name:this.preset, colors:p }}));
    if(window.toast) toast('Preset: '+(p.name||name));
  },
  setButtonsOpacity(v){
    const val=Math.max(.2, Math.min(1, Number(v)||.92));
    document.documentElement.style.setProperty('--fab-btn-opacity', String(val));
    localStorage.setItem('herbieBtnOpacity', String(val));
  },
  cyclePresets(){
    const list=Object.keys(this.presets); const i=list.indexOf(this.preset);
    this.setPreset(list[(i+1)%list.length]);
  }
});

// augment ORB picker with preset chips
function enhancePicker(){
  const fab=$('#fab'); if(!fab) return;
  let picker = $('#orb-picker');
  if(!picker) return;
  if(!picker.querySelector('.row-presets')){
    const row = document.createElement('div');
    row.className='row-presets';
    row.style.marginTop='6px';
    row.innerHTML = `
      <button class="chip" data-preset="blue">Blue</button>
      <button class="chip" data-preset="gold">Gold</button>
      <button class="chip" data-preset="thermal">Thermal</button>`;
    picker.appendChild(row);
    picker.addEventListener('click', (e)=>{
      const b=e.target.closest('[data-preset]'); if(!b) return;
      HERBIE.setPreset(b.dataset.preset);
      fab.classList.remove('show-picker');
    });
  }
}

// init
document.addEventListener('DOMContentLoaded', ()=>{
  const savedOpacity = parseFloat(localStorage.getItem('herbieBtnOpacity')||'0');
  if(savedOpacity>0){ HERBIE.setButtonsOpacity(savedOpacity); }
  enhancePicker();
  HERBIE.setPreset(HERBIE.preset);
});

window.HERBIE = HERBIE;
})();
</script>


<!--script id="CSS_INNER_RENDER_V1">
(()=>{'use strict';
const STYLE_ID='INLINE_CSS_RENDER_V1';
function appendCSS(css){
  if(!css || !css.trim()) return;
  let s=document.getElementById(STYLE_ID);
  if(!s){ s=document.createElement('style'); s.id=STYLE_ID; document.head.appendChild(s); }
  s.appendChild(document.createTextNode('\n'+css));
}

window.CSS_INNER = {
  // Varre o DOM e injeta CSS encontrado em blocos comuns
  applyFromDOM(){
    let css='';
    document.querySelectorAll('style[data-inline], [data-css-inline], pre[data-lang="css"], code.language-css, pre code.css').forEach(el=>{
      const t = (el.textContent||'').trim();
      if(t) css += '\n' + t;
    });
    appendCSS(css);
  },
  // Extrai <style>...</style> de uma string HTML e aplica
  applyFromHTML(html){
    if(!html) return;
    const re=/<style[^>]*>([\s\S]*?)<\/style>/gi; let m, css='';
    while((m=re.exec(html))){ css += '\n' + (m[1]||''); }
    appendCSS(css);
  }
};
document.addEventListener('DOMContentLoaded', ()=> CSS_INNER.applyFromDOM());
})();
</script-->


<script id="RAW_HTML_COMPAT_MIN_V1">
(()=>{'use strict';
// Non-destructive shim: preserves your existing builder and design.
// If text contains real HTML blocks, we render with a raw-aware builder;
// otherwise we delegate to the original builder untouched.

const $=(q,r=document)=>r.querySelector(q);

const RX_RAW_OPEN=/^\s*<\s*(div|figure|iframe|video|audio|svg|object|embed|table|section|article|img|pre|code|details|blockquote)\b/i;
const RX_RAW_SELF=/^\s*<(img|hr|br|embed|source|track|col|meta|link)\b[^>]*\/?>\s*$/i;
const RX_DIVIDER=/^\s*(?:---|\*\*\*)\s*$/;
const RX_HEADING=/^\s*(#{1,6})\s+(.+)$/;
// Expanded RX_CALL to also recognize shorter callouts like ":" (note) and "?" (question) and the "::." syntax for asides.
const RX_CALL=/^\s*(::(?:info|warn|tip|note|meta|ritual|success|danger|aside|question)|::\.|:|\?)\s+(.*)$/i;

function appendRaw(to, html){
  const tmp=document.createElement('div'); tmp.innerHTML = html;
  [...tmp.childNodes].forEach(n=>to.appendChild(n));
}

function rawAwareBuild(text){
  const root = $('#root'); if(!root) return;
  root.innerHTML = '';

  const lines = String(text||'').replace(/\r\n?/g,'\n').split('\n');
  let i=0, sec=null, blocks=0, sawH=false;

  function newSection(title){
    const det=document.createElement('details'); det.className='acc'; det.open=false;
    const sum=document.createElement('summary');
    sum.innerHTML=`<span class="chev"></span><h2>${title||'Seção'}</h2>`;
    const cont=document.createElement('div'); cont.className='sec';
    det.append(sum, cont); root.appendChild(det);
    sec=det; blocks=0;
  }
  function ensureSection(){ if(!sec) newSection('Seção 1'); if(blocks>=14) newSection(sec.querySelector('h2').textContent+' (cont.)'); }
  function push(el){ ensureSection(); sec.lastChild.appendChild(el); blocks++; }
  const flush = (buf)=>{
    if(!buf.length) return;
    const s = buf.join(' ').trim();
    if(/^\s*</.test(s) && RX_RAW_OPEN.test(s)){
      const d=document.createElement('div'); appendRaw(d, s); push(d);
    }else{
      const p=document.createElement('p');
      p.innerHTML = (window.inlineMD? window.inlineMD(s) : s);
      push(p);
    }
    buf.length=0;
  };

  while(i<lines.length){
    const line = lines[i];

    // hard divider
    if(RX_DIVIDER.test(line)){ flush([]); newSection(); i++; continue; }

    const mH = line.match(RX_HEADING);
    if(mH){ flush([]); newSection(mH[2].trim()); sawH=true; i++; continue; }

    const mC = line.match(RX_CALL);
    if(mC){
      flush([]);
      // Determine callout kind from the marker.
      let marker = (mC[1]||'').toLowerCase();
      let kind;
      if(marker === '::.') {
        kind = 'aside';
      } else if(marker === ':') {
        kind = 'note';
      } else if(marker === '?') {
        kind = 'question';
      } else {
        // strip leading "::" from extended callouts
        if(marker.startsWith('::')) {
          marker = marker.slice(2);
        }
        kind = marker || 'note';
      }
      const div=document.createElement('div');
      div.className=`callout ${kind} copyable`;
      div.innerHTML=`<span class="copy-hint">Copiar</span>` + (window.inlineMD? window.inlineMD(mC[2]) : mC[2]);
      push(div); i++; continue;
    }

    if(RX_RAW_OPEN.test(line)){
      // collect multi-line raw
      let tag = (line.match(RX_RAW_OPEN)||[])[1]||'div';
      const rxClose = new RegExp(`</\\s*${tag}\\s*>`, 'i');
      const buf=[line]; i++;
      while(i<lines.length && !rxClose.test(lines[i]) && !RX_RAW_SELF.test(lines[i])){
        buf.push(lines[i]); i++;
      }
      if(i<lines.length){ buf.push(lines[i]); i++; }
      const d=document.createElement('div'); appendRaw(d, buf.join('\n')); push(d);
      continue;
    }

    // code fences fallback to original builder: we gather and let original handle, or render here
    const mOpen = line.match(/^\s*(?:```|''')\s*([\w-]+)?\s*$/);
    if(mOpen){
      const lang=(mOpen[1]||'').toLowerCase(); i++; const code=[];
      while(i<lines.length && !/^\s*(?:```|''')+\s*$/.test(lines[i])){ code.push(lines[i]); i++; }
      if(i<lines.length) i++;
      const pre=document.createElement('pre'); pre.className='md-code copyable';
      const hint=document.createElement('span'); hint.className='copy-hint'; hint.textContent='Copiar';
      const c=document.createElement('code'); if(lang) c.className='lang-'+lang; c.textContent=code.join('\n');
      pre.append(hint,c); pre.onclick=()=>window.copy&&copy(pre); push(pre); continue;
    }

    if(line.trim()===''){ flush([]); i++; continue; }

    // accumulate paragraph lines
    const acc=[]; acc.push(line.trim()); i++;
    while(i<lines.length && lines[i].trim()!==''){
      if(RX_HEADING.test(lines[i])||RX_DIVIDER.test(lines[i])||RX_CALL.test(lines[i])||RX_RAW_OPEN.test(lines[i])) break;
      acc.push(lines[i].trim()); i++;
    }
    flush(acc);
  }

  // title fallback
  if(!sawH){
    const h = root.querySelector('details.acc summary h2');
    if(h && (!h.textContent || /^Seção/.test(h.textContent))) h.textContent = 'Documento';
  }

  // rename if first block is figure with caption
  root.querySelectorAll('details.acc').forEach((d,idx)=>{
    const cap=d.querySelector('figcaption'); const h=d.querySelector('summary h2');
    if(cap && h && /^Se/i.test(h.textContent||'')) h.textContent = cap.textContent.trim();
    if(!cap && h && /^Se/i.test(h.textContent||'')) h.textContent = idx===0? 'Visão' : `Bloco ${idx+1}`;
  });
}

// Wrap original autoBuild safely (idempotent)
(function(){
  const orig = window.autoBuild;
  if(typeof orig!=='function' || orig.__rawAwareWrapped) return;
  window.autoBuild = function(text){
    try{
      const hasRaw = /^(?:\s*<(?:div|figure|iframe|video|audio|svg|object|embed|table|section|article|img|pre|code|details|blockquote)\b)/mi.test(String(text||''));
      if(hasRaw){ return rawAwareBuild(text); }
    }catch{}
    return orig(text);
  };
  window.autoBuild.__rawAwareWrapped = true;
})();

})();
</script>

<!-- ============ Σ KaTeX — FAB ACTION PATCH (safe with FAB_MINI) ============ -->
<script id="FAB_KATEX_ACTION_V1">
(()=>{'use strict';
const $=(q,r=document)=>r.querySelector(q);

// — pega um container “ativo” sensato (igual ao master patch)
function getActiveRoot(){
  const picks = [
    '[data-pane="active"]','.stack .doc.active','.pane.active',
    '#renderOut','#mdOut','#viewer','#content','#root','main','article'
  ];
  for(const sel of picks){ const el=$(sel); if(el) return el; }
  return document.body;
}

// — ação KaTeX
async function runKaTeXActive(){
  try{
    const call = (root)=>{
      if(typeof window.KaTeXRender==='function') return window.KaTeXRender(root);
      // fallback: auto-render global se KaTeX já foi carregado
      if(typeof window.renderMathInElement==='function'){
        window.renderMathInElement(root||document.body,{
          delimiters:[
            {left:"$$",right:"$$",display:true},
            {left:"\\[",right:"\\]",display:true},
            {left:"$", right:"$", display:false},
            {left:"\\(", right:"\\)", display:false},
          ],
          throwOnError:false,
          ignoredTags:["script","noscript","style","textarea","code","pre"]
        });
      }
    };
    await call(getActiveRoot());
    (window.toast||console.log)('Σ KaTeX: render no painel ativo ✓');
  }catch(e){
    console.warn('[FAB_KATEX]', e);
    (window.toast||console.warn)('Falha ao renderizar KaTeX');
  }
}

// — garante ACTIONS.katex disponível
function ensureAction(){
  window.ACTIONS = window.ACTIONS || {};
  if(typeof window.ACTIONS.katex!=='function'){
    window.ACTIONS.katex = ()=> runKaTeXActive();
  }
}

// — cria/injeta o botão na #fab .menu
function ensureFabButton(){
  const menu = document.querySelector('#fab .menu');
  if(!menu) return;
  if(menu.querySelector('[data-action="katex"]')) return;
  const b = document.createElement('button');
  b.className = 'btn';
  b.dataset.action = 'katex';
  b.title = 'Render KaTeX (painel ativo)';
  b.textContent = 'Σ KaTeX';
  menu.appendChild(b);
}

// — delega clique do FAB pra chamar ACTIONS (segue o teu padrão)
function bindFabClicks(){
  const menu = document.querySelector('#fab .menu');
  if(!menu || menu.dataset.kxBound) return;
  menu.dataset.kxBound='1';
  menu.addEventListener('click',(e)=>{
    const t = e.target.closest('[data-action="katex"]'); if(!t) return;
    e.preventDefault(); ensureAction(); window.ACTIONS.katex();
  }, true);
}

// — observa o FAB para reinjetar o botão após “rebuild”
function watchFab(){
  const container = document.querySelector('#fab');
  if(!container || container.__kxObs) return;
  const obs = new MutationObserver(()=>{ ensureAction(); ensureFabButton(); bindFabClicks(); });
  obs.observe(container, { childList:true, subtree:true });
  container.__kxObs = obs;
}

// boot
function boot(){ ensureAction(); ensureFabButton(); bindFabClicks(); watchFab(); }
if(document.readyState!=='loading') boot();
else document.addEventListener('DOMContentLoaded', boot);

})();
</script>


<!-- ============ LIST/ASCII BEAUTY PATCH — V2 (hierarquia + traço-cápsula) ============ -->
<style id="LIST_BEAUTY_V2">
/* sem conflito: usa escopo mais específico, preservando V1 */
:root{
  --list-bg: color-mix(in oklab, var(--panel, #0e1220) 90%, black);
  --list-border: color-mix(in oklab, var(--ink, #e8ecf6) 16%, transparent);
  --list-shadow: 0 6px 24px rgba(0,0,0,.25), inset 0 0 0 1px var(--list-border);
  --list-radius: 16px;
  --list-marker-size: 1.65rem;
  --list-muted: color-mix(in oklab, var(--ink, #e8ecf6) 62%, transparent);
}

/* wrapper visual */
.list-card{ background:var(--list-bg); border-radius:var(--list-radius);
  box-shadow:var(--list-shadow); border:1px solid var(--list-border);
  padding:clamp(.6rem,.9rem,1rem); margin:.85rem 0; }
.list-card ul, .list-card ol{ margin:.25rem 0; padding:0; list-style:none; }
.list-card li{ display:grid; grid-template-columns:auto 1fr; gap:.65rem; align-items:start; padding:.35rem .25rem; }
.list-card li > ul, .list-card li > ol{ margin-top:.35rem; margin-left:1.85rem; }

/* ========= OL: numeração hierárquica ========= */
.list-card ol.ol-neo{ counter-reset:item; }
.list-card ol.ol-neo li{ counter-increment:item; }
.list-card ol.ol-neo li::before{
  /* hierarquia: 1, 1.1, 1.1.1 */
  content:counters(item, ".");
  inline-size:auto; min-inline-size: var(--list-marker-size);
  block-size: var(--list-marker-size);
  padding:0 .55rem; display:grid; place-items:center;
  font-weight:700; font-variant-numeric: tabular-nums;
  border-radius:12px;
  background:linear-gradient(42deg, var(--grad-a, #7effa1), var(--grad-b, #67e6ff));
  color:#000; box-shadow:0 2px 10px rgba(0,0,0,.35);
}
/* reseta contador em sub-listas para formar 1.1, 1.2, etc. */
.list-card ol.ol-neo ol{ counter-reset:item; }

/* ========= UL: bullets padrão (diamante) ========= */
.list-card ul.ul-neo:not(.style-dash):not([data-bullet="dash"]) > li::before{
  content:"";
  inline-size:.9rem; block-size:.9rem; border-radius:8px;
  background:linear-gradient(42deg, var(--grad-a, #7effa1), var(--grad-b, #67e6ff));
  box-shadow:0 1px 6px rgba(0,0,0,.35), 0 0 0 1px color-mix(in oklab, #fff 14%, transparent);
  translate:0 .15rem;
}

/* ========= UL: variante “traço-cápsula” ========= */
.list-card ul.ul-neo.style-dash > li::before,
.list-card ul.ul-neo[data-bullet="dash"] > li::before{
  content: attr(data-marker, "–"); /* pode trocar por texto: data-marker="TIP" */
  display:inline-grid; place-items:center;
  inline-size:auto; min-inline-size:1.35rem; block-size:1.35rem;
  padding:0 .6rem; border-radius:999px; font-weight:700;
  letter-spacing:.02em;
  background:linear-gradient(42deg, var(--grad-a, #7effa1), var(--grad-b, #67e6ff));
  color:#000; box-shadow:0 2px 10px rgba(0,0,0,.35);
}

/* dica/legenda leve */
.list-card .hint{ color:var(--list-muted); font-size:.9em; }

/* ========= ASCII card (igual V1, com leve glow) ========= */
.ascii-card{ background:var(--list-bg); border-radius:calc(var(--list-radius) + 2px);
  border:1px solid var(--list-border); box-shadow:var(--list-shadow),
  0 0 0 1px color-mix(in oklab, var(--grad-b, #67e6ff) 20%, transparent);
  margin:1rem 0; overflow:auto; }
.ascii-card pre{ margin:0; padding:1rem 1.1rem; line-height:1.35;
  font:500 13.5px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; white-space:pre; tab-size:2; }
.ascii-card .ascii-cap{ padding:.55rem .9rem .6rem; border-top:1px dashed var(--list-border);
  color:var(--list-muted); font-size:.85em; }
</style>

<script id="LIST_BEAUTY_V2_SCRIPT">
(()=>{'use strict';
if(window.__LIST_BEAUTY_V2__) return; window.__LIST_BEAUTY_V2__=true;

const q=(s,r=document)=>[...r.querySelectorAll(s)];

const wrapLists=(root=document)=>{
  const lists = q('ul,ol',root).filter(el=>{
    if(el.closest('nav,menu,.no-beauty,.editor,.toolbar')) return false;
    if(el.classList.contains('ul-neo')||el.classList.contains('ol-neo')) return false; // já cuidado
    return true;
  });
  for(const el of lists){
    const isOL = el.tagName==='OL';
    el.classList.add(isOL?'ol-neo':'ul-neo');
    // preserva estilos existentes do usuário
    if(!el.parentElement.classList.contains('list-card')){
      const wrap = document.createElement('div');
      wrap.className='list-card';
      el.replaceWith(wrap); wrap.appendChild(el);
    }
  }
};

const asciiScore = t=>{
  const box=/[─│┌┐└┘╭╮╰╯═╬╠╣╦╩]+/g, grid=/[-_=+*#\\/|]{3,}/g;
  const L=t.split('\n'); let h=0;
  for(const ln of L){ if(box.test(ln)||grid.test(ln)||ln.trim().startsWith('> ')) h++; }
  return h>=Math.max(2,Math.ceil(L.length*0.2));
};

const enhanceASCII=(root=document)=>{
  const cand=new Set([...q('pre',root),...q('code.language-text, code[class*="language-plaintext"]',root)]);
  q('p',root).forEach(p=>{ const x=p.innerText||''; if(x.includes('\n')&&asciiScore(x)) cand.add(p); });
  for(const el of cand){
    if(el.closest('.ascii-card,.no-beauty')) continue;
    const txt=(el.innerText||'').trim(); if(!asciiScore(txt)) continue;
    const fig=document.createElement('figure'); fig.className='ascii-card';
    const pre=document.createElement('pre'); pre.textContent=txt; fig.appendChild(pre);
    if(!el.closest('pre')){ const fc=document.createElement('figcaption'); fc.className='ascii-cap'; fc.textContent='ASCII • renderizado em bloco'; fig.appendChild(fc); }
    el.replaceWith(fig);
  }
};

/* Heurística opcional: se o UL já tiver data-bullet="dash" ou class style-dash, mantém.
   Caso NÃO tenha, deixamos como diamante (padrão), para não interferir nos teus looks. */
const applyDashCapsuleByAttr=(root=document)=>{
  q('ul.ul-neo',root).forEach(ul=>{
    if(ul.matches('.style-dash,[data-bullet="dash"]')) return;
    // não força nada; o usuário decide via classe/atributo
  });
};

const run=(ctx=document)=>{
  wrapLists(ctx);
  enhanceASCII(ctx);
  applyDashCapsuleByAttr(ctx);
};

if(window.__RENDERBUS__?.on){
  window.__RENDERBUS__.on('after', run, {name:'list-ascii-beauty-v2', priority:95});
}else{
  (document.readyState==='loading') ? document.addEventListener('DOMContentLoaded',()=>run(document)) : run(document);
  new MutationObserver(m=>m.forEach(x=>x.addedNodes&&x.addedNodes.forEach(n=>n.nodeType===1&&run(n))))
    .observe(document.body,{childList:true,subtree:true});
}
})();
</script>
<!-- ============ /LIST/ASCII BEAUTY PATCH — V2 ============ -->


<script id="PATCH_TITLES_ESCAPE_SETEXT_V1">
(()=>{'use strict';
const esc = s => String(s||'')
  .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');

function applySetext(lines,i){
  // Detecta "Título\n=====" (H1) ou "Subtítulo\n-----" (H2)
  if(i+1 < lines.length){
    const next = lines[i+1].trim();
    if(/^=+$/.test(next)) return { level: 1, text: lines[i].trim(), skip: 2 };
    if(/^-+$/.test(next)) return { level: 2, text: lines[i].trim(), skip: 2 };
  }
  return null;
}

// ------- Flat: sobrescreve helpers do autoBuild se existirem -------
if(typeof window.autoBuild==='function'){
  const abSrc = window.autoBuild.toString();
  if(!abSrc.includes('__TITLES_PATCHED__')){
    const _autoBuild = window.autoBuild;
    window.autoBuild = function(text){
      // wrap original com Setext + escape em H2
      const lines = String(text||'').replace(/\r\n?/g,'\n').split('\n');
      let i=0, rebuilt=[];
      while(i<lines.length){
        const l = lines[i];
        const set = applySetext(lines,i);
        if(set){ // converte para ATX
          rebuilt.push('#'.repeat(set.level)+' '+set.text);
          i+=set.skip; continue;
        }
        rebuilt.push(l); i++;
      }
      // sinaliza patch
      const marker='__TITLES_PATCHED__';
      const saved = window.__current_md;
      window.__current_md = (rebuilt.join('\n'));
      const out = _autoBuild(window.__current_md);
      // corrige todos os <summary><h2> com escape
      document.querySelectorAll('#root details.acc summary h2').forEach(h=>{
        h.innerHTML = esc(h.textContent||'');
      });
      window.__current_md = saved;
      return out;
    }
  }
}

// ------- Nested: adiciona escape no momento de criar seção -------
if(typeof window.autoBuildNested==='function'){
  const __origN = window.autoBuildNested;
  window.autoBuildNested = function(text){
    const escText = t => esc(t).replace(/\s+#+\s*$/,''); // remove hashes finais
    // monkey-patch: intercepta newSectionAt com escape
    const create = (lvl, title)=>{
      const details = document.createElement('details');
      details.className='acc'; details.open=false;
      const sum=document.createElement('summary');
      sum.innerHTML='<span class="chev"></span><h2>'+ escText(title) +'</h2>';
      const cont=document.createElement('div'); cont.className='sec';
      details.append(sum, cont);
      return {details, cont};
    };
    // roda original, depois faz um passe extra pros h2 existentes
    const out = __origN(text);
    document.querySelectorAll('#root details.acc summary h2').forEach(h=>{
      h.innerHTML = esc(h.textContent||'');
    });
    return out;
  }
}
})();
</script>


<script id="PATCH_MARKDOWNIFY_SMART_V1">
(()=>{'use strict';
function looksTitle(line){
  const t=line.trim();
  if(t.length<80 && /^[A-ZÁÂÃÀÉÊÍÓÔÕÚÜÇ0-9][^.!?]{2,}$/.test(t)) return true; // curto e sem pontuação final
  return false;
}
function isSubtitle(line){
  const t=line.trim();
  return t.length<90 && /[:—–-]\s+/.test(t); // “Título: subtítulo”
}
function bulletsNormalize(line){
  // 1) item → 1. item ; • item → - item
  return line
    .replace(/^\s*(\d+)[\)\]]\s+/,'$1. ')
    .replace(/^\s*[•·]\s+/,'- ');
}
function markdownifyPlain(text){
  const L=String(text||'').replace(/\r\n?/g,'\n').split('\n');
  if(/^\s*#\s+/.test(text)) return text; // já tem H1
  let out=[], seenH1=false, i=0;
  while(i<L.length){
    let line=L[i];

    // HR por longos traços
    if(/^\s*[—–-]{6,}\s*$/.test(line)){ out.push(''); out.push('---'); out.push(''); i++; continue; }

    // título/subtítulo heurístico
    if(!seenH1 && looksTitle(line)){
      out.push('# '+line.trim()); out.push(''); seenH1=true; i++; continue;
    }
    if(isSubtitle(line) && seenH1){
      out.push('## '+line.trim()); out.push(''); i++; continue;
    }

    // listas simples e numeradas
    line = bulletsNormalize(line);

    // “Termo: valor” vira lista de definição simples → callout
    const def = line.match(/^\s*([A-ZÁÂÃÀÉÊÍÓÔÕÚÜÇ].{1,40}):\s+(.+)$/);
    if(def){ out.push(':'+def[1]+' — '+def[2]); i++; continue; }

    // blocos de código heurísticos (muitas chaves/`;`)
    if(/[{;}=].{0,}$/.test(line) && (line.includes('function')||line.includes('=>'))){
      const buf=[line]; i++;
      while(i<L.length && L[i].trim()){
        buf.push(L[i]); i++;
        if(buf.length>1 && /;\s*$/.test(buf[buf.length-1])) break;
      }
      out.push('```js'); out.push(...buf); out.push('```'); out.push('');
      continue;
    }

    out.push(line); i++;
  }
  return out.join('\n');
}

if(typeof window.preprocessMD==='function'){
  const __orig = window.preprocessMD;
  window.preprocessMD = function(text){
    let t=String(text||'');
    // Se não há nenhum header e parece “texto corrido”, aplica markdownify
    const lacksHeaders = !/^\s*#{1,6}\s+/m.test(t) && !/^\s*\S+\n[-=]{3,}\s*$/m.test(t);
    const manyWords = (t.match(/\S+/g)||[]).length>40;
    if(lacksHeaders && manyWords) t = markdownifyPlain(t);
    return __orig(t);
  }
}
})();
</script>



<script id="CSS_INNER_SAFE_V2">
(()=>{'use strict';
const STYLE_ID='INLINE_CSS_RENDER_SAFE_V2';
function appendSafe(css){
  if(!css || !css.trim()) return;
  let s=document.getElementById(STYLE_ID);
  if(!s){ s=document.createElement('style'); s.id=STYLE_ID; document.head.appendChild(s); }
  s.appendChild(document.createTextNode('\n'+css));
}
window.CSS_INNER_SAFE = {
  applyFromDOM(root=document){
    let css='';
    root.querySelectorAll('style[data-inline]').forEach(el=>{
      const t=(el.textContent||'').trim(); if(t) css+='\n'+t;
    });
    appendSafe(css);
  },
  applyFromHTML(html){
    if(!html) return;
    // só <style data-inline>…</style>
    const re=/<style[^>]*\bdata-inline\b[^>]*>([\s\S]*?)<\/style>/gi; let m, css='';
    while((m=re.exec(html))) css+='\n'+(m[1]||'');
    appendSafe(css);
  }
};
document.addEventListener('DOMContentLoaded',()=> CSS_INNER_SAFE.applyFromDOM());
})();
</script>

<script id="KATEX_AUTORUN_AFTER_BUILD_V1">
(()=>{'use strict';
function loadOnceCSS(href,id){return new Promise(ok=>{ if(document.getElementById(id)) return ok();
  const l=document.createElement('link'); l.id=id; l.rel='stylesheet'; l.href=href; l.onload=ok; document.head.appendChild(l); });}
function loadOnceJS(src,id){return new Promise(ok=>{ if(document.getElementById(id)) return ok();
  const s=document.createElement('script'); s.id=id; s.src=src; s.defer=true; s.onload=ok; document.head.appendChild(s); });}
async function ensureKaTeX(){ if(window.renderMathInElement) return;
  const CDN="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist";
  await loadOnceCSS(`${CDN}/katex.min.css`,'katex_css');
  await loadOnceJS(`${CDN}/katex.min.js`,'katex_js');
  await loadOnceJS(`${CDN}/contrib/auto-render.min.js`,'katex_auto_js');
}
async function run(root){
  await ensureKaTeX();
  if(typeof window.KaTeXRender==='function') return window.KaTeXRender(root||document.body);
  if(window.renderMathInElement) window.renderMathInElement(root||document.body,{
    delimiters:[
      {left:"$$",right:"$$",display:true},
      {left:"\$begin:math:display$",right:"\\$end:math:display$",display:true},
      {left:"$", right:"$", display:false},
      {left:"\$begin:math:text$", right:"\\$end:math:text$", display:false},
    ],
    throwOnError:false,
    ignoredTags:["script","noscript","style","textarea","code","pre"]
  });
}
// envelopa os builders
['autoBuild','autoBuildNested'].forEach(name=>{
  const f=window[name];
  if(typeof f==='function' && !f.__kxKaTeXWrapped){
    window[name]=function(text){ const out=f(text); run(document.getElementById('root')); return out; }
    window[name].__kxKaTeXWrapped=true;
  }
});
})();
</script>

<style> #fab .menu [data-action="katex"]{ display:none !important; }</style>


<!-- ============ TEXT BEAUTY & INTERACTION PATCH — V3 (aditivo) ============ -->
<style id="TEXT_BEAUTY_V3">
:root{
  --txt-card: color-mix(in oklab, var(--panel, #0e1220) 92%, black);
  --txt-bd: color-mix(in oklab, var(--ink, #e8ecf6) 16%, transparent);
  --txt-shadow: 0 6px 24px rgba(0,0,0,.25), inset 0 0 0 1px var(--txt-bd);
  --chip-bg: linear-gradient(42deg, var(--grad-a, #7effa1), var(--grad-b, #67e6ff));
  --chip-ink: #000;
  --paren-ink: color-mix(in oklab, var(--ink, #e8ecf6) 92%, white);
}

/* Tipografia base do texto corrido (aplicamos quando detectado bloco .flow-text) */
.flow-text p{
  text-wrap: pretty;
  line-height: 1.65;
  letter-spacing: .01em;
  margin: .65rem 0;
  hyphens: auto;
}

/* Heading leve detectado por “Titulo:” */
.flow-text .kv-head{
  font-weight: 800;
  letter-spacing:.02em;
  margin: 1.2rem 0 .4rem;
}

/* Parênteses → realce sutil */
.span-paren{
  padding: .05rem .35rem;
  border-radius: .55rem;
  border: 1px solid var(--txt-bd);
  color: var(--paren-ink);
  background: color-mix(in oklab, var(--txt-card) 86%, transparent);
}

/* Chips (colchetes) clicáveis */
.chip, .chip-btn{
  display:inline-grid; place-items:center;
  padding:.25rem .6rem; border-radius:999px;
  background: var(--chip-bg); color: var(--chip-ink);
  font-weight: 700; letter-spacing:.02em;
  box-shadow: 0 2px 10px rgba(0,0,0,.35);
  cursor: pointer; user-select: none;
}
.chip + .chip{ margin-left:.35rem; }

/* Pergunta → card */
.q-card{
  background: var(--txt-card);
  border: 1px solid var(--txt-bd);
  box-shadow: var(--txt-shadow);
  border-radius: 14px;
  padding: .85rem 1rem;
  margin: .9rem 0;
  display:grid; grid-template-columns:auto 1fr; gap:.65rem; align-items:start;
}
.q-card .q-ico{
  inline-size:1.65rem; block-size:1.65rem; border-radius:50%;
  display:grid; place-items:center; font-weight:800; color:#000;
  background: var(--chip-bg);
}
.q-card .q-body{ line-height:1.55; }

/* Overlay de copiar nas listas (usa .list-card do patch anterior) */
.list-card{ position:relative; }
.list-card .copy-badge{
  position:absolute; top:.35rem; right:.35rem;
  font-size:.8rem; padding:.2rem .45rem; border-radius:999px;
  background: color-mix(in oklab, #fff 12%, var(--txt-card));
  border: 1px solid var(--txt-bd);
  color: var(--ink, #e8ecf6); opacity:.65; transition:.2s; user-select:none;
}
.list-card:hover .copy-badge{ opacity:1; }

/* Área que receberá HTML “desescapado” */
.raw-html-card{
  background: var(--txt-card); border: 1px dashed var(--txt-bd);
  border-radius: 14px; padding: .85rem 1rem; margin: .9rem 0;
}
.raw-html-card .raw-note{ color: color-mix(in oklab, var(--ink) 62%, transparent); font-size:.85em; margin-bottom:.35rem; }
</style>

<script id="TEXT_BEAUTY_V3_SCRIPT">
(()=>{'use strict';
if(window.__TEXT_BEAUTY_V3__) return; window.__TEXT_BEAUTY_V3__=true;

/* Utilitários */
const $=(s,r=document)=>r.querySelector(s);
const $$=(s,r=document)=>[...r.querySelectorAll(s)];
const esc=(s)=>s.replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));

/* 0) Toggle edição rápida */
let EDIT_ON=false;
const toggleEdit=()=>{
  EDIT_ON=!EDIT_ON;
  document.body.toggleAttribute('data-edit', EDIT_ON);
  const host = document.getElementById('CONTENT') || document.querySelector('main, article, .render, .reader, body');
  if(host) host.contentEditable = EDIT_ON ? 'plaintext-only' : 'false';
};
document.addEventListener('keydown',e=>{
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='e'){ e.preventDefault(); toggleEdit(); }
});

/* 1) Key:Value negrito (palavra:) + parênteses + chips [ ]
   - roda apenas em blocos de texto (p, li) e não mexe dentro de code/pre */
const processInline = (root=document)=>{
  const targets = $$('p, li, h1, h2, h3, h4, h5, h6', root).filter(n=>!n.closest('pre, code, .no-beauty'));
  const rxKV = /(^|\s)([A-Za-zÀ-ÿ0-9_]+):(?=\s|$)/g; // Palavra:
  const rxParen = /\(([^\n)]+)\)/g;                  // ( … )
  const rxChip  = /\[\[([^[\]]+)\]\]|\[([^[\]]+)\]/g; // [[a]] | [a]

  for(const el of targets){
    // evita processar múltiplas vezes
    if(el.dataset.inlineProcessed==='1') continue;
    el.dataset.inlineProcessed='1';

    const html = el.innerHTML;
    if(/<pre|<code|contenteditable/i.test(html)) continue;

    let out = html;

    // 1. Palavra:  → <strong>
    out = out.replace(rxKV, (m, sp, key)=> `${sp}<strong class="kv-key">${key}:</strong>`);

    // 2. ( ... )   → span-paren
    out = out.replace(rxParen, (m, inside)=> `<span class="span-paren">(${inside})</span>`);

    // 3. [ ... ] / [[ ... ]]  → chip/chip-btn
    out = out.replace(rxChip, (m, dbl, sgl)=>{
      const label = (dbl||sgl||'').trim();
      return `<span class="${dbl?'chip-btn':'chip'}" data-chip="${esc(label)}">${esc(label)}</span>`;
    });

    el.innerHTML = out;
  }
};

/* 2) Perguntas → .q-card (frases que terminam com '?') */
const processQuestions=(root=document)=>{
  const paras = $$('p', root).filter(n=>!n.closest('.q-card, pre, code, .no-beauty'));
  for(const p of paras){
    const txt = (p.innerText||'').trim();
    if(txt.endsWith('?') && !p.dataset.qProcessed){
      p.dataset.qProcessed='1';
      const wrap=document.createElement('div'); wrap.className='q-card';
      wrap.innerHTML = `<div class="q-ico">?</div><div class="q-body">${esc(txt)}</div>`;
      p.replaceWith(wrap);
    }
  }
};

/* 3) Flow text: melhora texto corrido, cria heading leve se linha for "Algo:" sozinha */
const beautifyFlow=(root=document)=>{
  const container = root.querySelector('.flow-text') || root; // se já tiver classe, usa; senão aplica heurística suave
  $$('p', container).forEach(p=>{
    const t=(p.innerText||'').trim();
    if(/^[^:\n]{3,}:\s*$/.test(t)){ // linha que termina com ":" vira heading leve
      p.classList.add('kv-head');
    }
    // Quebra parágrafos absurdamente longos em dois (heurística)
    if(t.length>600 && t.includes('. ')){
      const mark = t.indexOf('. ', Math.floor(t.length/2));
      if(mark>0){
        const a=t.slice(0, mark+1), b=t.slice(mark+1);
        const p2=p.cloneNode(); p2.textContent=b.trim();
        p.textContent=a.trim();
        p.insertAdjacentElement('afterend', p2);
      }
    }
  });
};

/* 4) Listas copiáveis: badge + click copy */
const enableCopyLists=(root=document)=>{
  const lists = $$('.list-card', root);
  for(const card of lists){
    if(card.querySelector('.copy-badge')) continue;
    const badge = document.createElement('div');
    badge.className='copy-badge'; badge.textContent='copiar';
    card.appendChild(badge);
    card.addEventListener('click', e=>{
      // evita copiar quando clicou em link/botão dentro
      if(e.target.closest('a,button,.chip,.chip-btn')) return;
      const txt = [...card.querySelectorAll('li')].map(li=>li.innerText.trim()).join('\n');
      navigator.clipboard.writeText(txt).then(()=>{
        badge.textContent='copiado!'; setTimeout(()=>badge.textContent='copiar',1200);
      });
    }, {passive:true});
  }
};

/* 5) HTML/SVG pass-through
   - ```html-raw ... ``` → renderiza
   - <div data-raw-html>…(escapado)…</div> → renderiza
*/
const renderRawHTML=(root=document)=>{
  // code fence transform
  $$('pre code', root).forEach(code=>{
    const cls = (code.className||'').toLowerCase();
    if(cls.includes('language-html-raw') || cls.includes('lang-html-raw')){
      const raw = code.textContent;
      const box = document.createElement('div');
      box.className='raw-html-card';
      box.innerHTML = `<div class="raw-note">HTML/SVG renderizado a partir de bloco <code>html-raw</code></div>`;
      const slot = document.createElement('div');
      slot.className='raw-slot';
      // injeta SEM esc, assumindo que o autor confia no conteúdo
      slot.innerHTML = raw;
      box.appendChild(slot);
      const pre = code.closest('pre');
      pre.replaceWith(box);
    }
  });

  // <div data-raw-html>…</div>
  $$('div[data-raw-html]', root).forEach(div=>{
    const raw = div.textContent; // assume texto escapado pelo md
    const box = document.createElement('div'); box.className='raw-html-card';
    const slot = document.createElement('div'); slot.className='raw-slot';
    slot.innerHTML = raw;
    box.appendChild(slot);
    div.replaceWith(box);
  });
};

/* 6) Delegação de cliques para chips (colchetes) */
document.addEventListener('click', e=>{
  const chip = e.target.closest('.chip, .chip-btn');
  if(chip){
    const label = chip.dataset.chip||chip.textContent.trim();
    // dispara um evento customizado para teu bus/orquestrador
    const ev = new CustomEvent('chip:click', {detail:{label, source:'text-beauty-v3'}});
    document.dispatchEvent(ev);
  }
}, {passive:true});

/* 7) Orquestração */
const run=(ctx=document)=>{
  processInline(ctx);
  processQuestions(ctx);
  beautifyFlow(ctx);
  enableCopyLists(ctx);
  renderRawHTML(ctx);
};

if(window.__RENDERBUS__?.on){
  window.__RENDERBUS__.on('after', run, {name:'text-beauty-v3', priority: 96});
}else{
  (document.readyState==='loading') ? document.addEventListener('DOMContentLoaded',()=>run(document)) : run(document);
  new MutationObserver(m=>m.forEach(x=>x.addedNodes&&x.addedNodes.forEach(n=>n.nodeType===1&&run(n))))
    .observe(document.body,{childList:true,subtree:true});
}
})();
</script>
<!-- ============ /TEXT BEAUTY & INTERACTION PATCH — V3 ============ -->

<script id="KOBLLUX_HOTFIX_BUNDLE_V1">
(()=>{'use strict';
if (window.__KOBLLUX_HOTFIX_BUNDLE_V1__) return;
window.__KOBLLUX_HOTFIX_BUNDLE_V1__ = true;

/* ========= Helpers ========= */
const $ = (q, r=document)=>r.querySelector(q);

/* Biblioteca (Stacks) */
function _libLoad(){ try{ return JSON.parse(localStorage.getItem('tl_library_v1')||'[]'); }catch{ return []; } }
function _libSave(arr){ localStorage.setItem('tl_library_v1', JSON.stringify(arr)); }
function _upsertDoc(doc){
  const arr = _libLoad();
  const idx = arr.findIndex(d => d.id === doc.id);
  if (idx >= 0) arr[idx] = doc; else arr.unshift(doc);
  _libSave(arr);
}

/* Render helper (não quebra se autoBuild não existir) */
async function _openText(md){
  window.__current_md = md || '';
  if (typeof autoBuild === 'function') autoBuild(md);
}

/* ========= 1) Exportar .md (iOS/Safari-safe) ========= */
window.exportMD = function(){
  const md = (typeof buildMDFromDOM === 'function' ? buildMDFromDOM() : (window.__current_md || ''));
  const blob = new Blob([md], { type: 'text/markdown;charset=utf-8' });
  const a = document.createElement('a');
  const base = (window.__current_title || 'export').replace(/[\\\/:*?"<>|]+/g,'-').slice(0,80) || 'export';
  a.download = base + '.md';
  a.href = URL.createObjectURL(blob);
  a.style.display = 'none';
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 1200);
  if (window.toast) toast('.md exportado');
};

/* ========= 2) Upload cria novo contexto (sem sobrescrever) ========= */
const _fi = document.getElementById('fileInput');
if (_fi && !_fi.dataset._ctxFix){
  _fi.dataset._ctxFix = '1';
  _fi.addEventListener('change', async (e)=>{
    const f = e.target.files?.[0];
    if (!f) return;
    const prev = document.getElementById('filePreview');
    if (prev) prev.textContent = 'Lendo ' + f.name + '...';

    // Zera o contexto para evitar sobrescrita no Salvar
    window.__current_doc_id = null;
    window.__current_title  = (f.name || 'Documento').replace(/\.(pdf|txt|md|markdown|html|htm)$/i, '');

    // PDF (se pdfjsLib estiver disponível)
    if (/\.(pdf)$/i.test(f.name) && window.pdfjsLib){
      try{
        const buf = await f.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: buf }).promise;
        let txt = '';
        for (let i = 1; i <= pdf.numPages; i++) {
          const p = await pdf.getPage(i);
          const c = await p.getTextContent();
          txt += c.items.map(it => it.str).join(' ') + '\n';
        }
        await _openText(txt);
      }catch(err){
        console.warn('[upload pdf] falhou:', err);
        await _openText(''); if (window.toast) toast('Falha ao ler PDF');
      }
    } else {
      // Demais extensões: lê como texto
      const txt = await f.text();
      await _openText(txt);
    }
  }, { capture: true });
}

/* ========= 3) Salvar vira update quando há __current_doc_id ========= */
(function(){
  window.saveCurrent = function(){
    const md = (typeof getCurrentMarkdown === 'function' ? getCurrentMarkdown() : (window.__current_md || ''));
    const ti = document.getElementById('docTitle');
    const titleFromH1 = md.match(/^\s*#\s+(.+)$/m)?.[1];
    const title = (ti && ti.value.trim()) || titleFromH1 || (window.__current_title || 'Sem título');
    const now = new Date().toISOString();

    const arr = _libLoad();
    const existing = arr.find(d => d.id === window.__current_doc_id);
    const id = window.__current_doc_id || (self.crypto?.randomUUID ? ('doc_' + crypto.randomUUID()) : ('doc_' + Date.now()));

    const doc = {
      id,
      title,
      md,
      bytes: md.length,
      createdAt: existing?.createdAt || now,
      updatedAt: now
    };

    _upsertDoc(doc);
    window.__current_doc_id = id;   // fixa o contexto
    window.__current_title  = title;
    localStorage.setItem('tl_last_doc_id', id);
    if (window.toast) toast(existing ? 'Atualizado em Stacks' : 'Salvo em Stacks');
  };
})();

/* ========= 4) Patches de ações (Stacks) ========= */
if (window.ACTIONS && !window.ACTIONS.__koblluxFixed){
  // open-doc: abre do acervo e seta contexto para update
  const _oldOpen = window.ACTIONS['open-doc'];
  window.ACTIONS['open-doc'] = function(el){
    const id = el?.dataset?.id;
    const doc = _libLoad().find(d => d.id === id);
    if (!doc) return;
    window.__current_doc_id = id;
    window.__current_title  = doc.title || '';
    window.__current_md     = doc.md || '';
    _openText(doc.md);
  };

  // md-doc: exporta .md (iOS-safe)
  window.ACTIONS['md-doc'] = function(el){
    const id = el?.dataset?.id;
    const doc = _libLoad().find(d => d.id === id);
    if (!doc) return;
    const blob = new Blob([doc.md||''], { type:'text/markdown;charset=utf-8' });
    const a = document.createElement('a');
    a.download = (doc.title || 'documento') + '.md';
    a.href = URL.createObjectURL(blob);
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 1200);
  };

  window.ACTIONS.__koblluxFixed = true;
}

/* ========= 5) Opcional: limpar SW + caches (PWA hard refresh) ========= */
window.forceHardRefresh = function(){
  (async()=>{
    try{
      const keys = await caches.keys();
      await Promise.all(keys.map(k => caches.delete(k)));
    }catch{}
    if ('serviceWorker' in navigator){
      try{
        const regs = await navigator.serviceWorker.getRegistrations();
        await Promise.all(regs.map(r => r.unregister()));
      }catch{}
    }
    location.reload();
  })();
};
})();
</script>


<script id="KOBLLUX_TTS_PATCH_V1">
(()=>{'use strict';
if(window.__KOBLLUX_TTS_PATCH_V1__) return;
window.__KOBLLUX_TTS_PATCH_V1__ = true;

const synth = window.speechSynthesis;
let speaking = false, paused = false;
let currentUtter = null;

/* ===== Botão ON/OFF ===== */
const fab = document.createElement('button');
fab.id = 'ttsToggle';
fab.textContent = '🔊';
fab.style.cssText = `
position:fixed;top:66px;right:16px;z-index:99999;
border:none;border-radius:50%;width:32px;height:32px;
font-size:24px;cursor:pointer;
background:linear-gradient(42deg,#0f0,#0ff);
box-shadow:0 0 12px rgba(0,255,255,.4);
`;
fab.title = 'TTS: desligado';
document.body.appendChild(fab);

/* ===== Funções ===== */
function readAll(){
  if(speaking) return;
  const area = document.querySelector('#renderArea, main, article, #book') || document.body;
  const blocks = [...area.querySelectorAll('h1,h2,h3,p,li,blockquote,section,div')]
    .map(x => x.innerText.trim()).filter(Boolean);
  if(!blocks.length){ toast?.('Nada para ler'); return; }

  speaking = true; paused = false;
  fab.style.background = 'linear-gradient(42deg,#0ff,#0f0)';
  fab.title = 'TTS: ligado';

  let i = 0;
  const readNext = ()=>{
    if(!speaking || i>=blocks.length){ stopTTS(); return; }
    const text = blocks[i];
    currentUtter = new SpeechSynthesisUtterance(text);
    currentUtter.lang = 'pt-BR';
    currentUtter.rate = 1.0;
    currentUtter.pitch = 1.0;
    currentUtter.volume = 1.0;

    const el = area.querySelectorAll('h1,h2,h3,p,li,blockquote,section,div')[i];
    if(el){ el.style.outline='2px solid #0ff'; el.scrollIntoView({behavior:'smooth',block:'center'}); }

    currentUtter.onend = ()=>{
      if(el) el.style.outline='none';
      i++; readNext();
    };
    synth.speak(currentUtter);
  };
  readNext();
}

function stopTTS(){
  if(currentUtter) synth.cancel();
  speaking = false; paused = false;
  fab.style.background = 'linear-gradient(42deg,#0f0,#0ff)';
  fab.title = 'TTS: desligado';
}

/* ===== Botão toggle ===== */
fab.addEventListener('click', ()=>{
  if(!speaking){ readAll(); }
  else{ stopTTS(); toast?.('Leitura parada'); }
});

/* ===== Teclas rápidas (opcional) ===== */
document.addEventListener('keydown', e=>{
  if(e.key==='F2'){ fab.click(); } // F2 = liga/desliga
});

})();
</script>



 
<script type="module">
  import { applyRGX } from './js/patches/MAP_RGX_v3_KOBLLUX.mjs';

  document.addEventListener('DOMContentLoaded', () => {
    // raiz onde o markdown é renderizado
    const root =
      document.querySelector('#reader') ||
      document.querySelector('#app')    ||
      document.body;

    // marca o root pra animação do TTS e estilo local
    root.dataset.koblluxRoot = '1';

    // ativa o engine (chips, callouts, botões, IA, TTS)
    applyRGX(root);
  });
</script>

 



<!-- MD Smart Generator · Monólito BUGADÃO v3 -->
<script type="module">
/* ============================================================
   Monolithic MD Generator (BUGADÃO) — v3
   - Default: "Glitch Mode" ON (windows-1252 decode)
   - Toggle Glitch/UTF-8 sem reupload (mantém bytes em cache)
   - Upload → textarea (staging), só render se pedir
   - Converter → MD / Converter+Gerar
   - Callouts inline ::info/::warn/::aside
   - Tabela pipe → lista-tabela (linhas "- "), coluna-chave → (parênteses)
   ============================================================ */
let MDGEN_GLITCH_MODE = true;
let __mdgen_lastBytes = null;   // ArrayBuffer dos bytes do último upload
let __mdgen_filename  = null;

function tryFindTextarea(){
  return document.querySelector('#srcText, #src, textarea[name="src"], textarea');
}

function decodeBytes(ab, label){
  try{
    const dec = new TextDecoder(label || (MDGEN_GLITCH_MODE ? 'windows-1252' : 'utf-8'), {fatal:false});
    return dec.decode(new Uint8Array(ab));
  }catch(e){
    console.warn('Decoder falhou, fallback utf-8', e);
    return new TextDecoder('utf-8').decode(new Uint8Array(ab));
  }
}

function setTextarea(text){
  const ta = tryFindTextarea();
  if(!ta) return;
  ta.value = text;
  ta.focus();
  ta.setSelectionRange(0, Math.min(text.length, 2000));
}

function generateSmartMD(input, opts={}){
  const o = Object.assign({ title:'Documento Convertido', addHeaderButtons:true, addMeta:true }, opts||{});
  let txt = String(input||'').replace(/\r\n?/g,'\n').replace(/[“”]/g,'"').replace(/[’‘]/g,"'").replace(/'''/g,'```');
  if(!/^#\s/m.test(txt)){ txt = `# ${o.title}\n\n` + txt; }

  const lines = txt.split('\n'), OUT=[]; let i=0;
  const KEY_WARN=/\b(atenç(ã|a)o|cuidado|risco|quebra|bug|perigo)\b/i;
  const KEY_INFO=/\b(nota|observa(ç|c)[aã]o|info|dica|lembrete)\b/i;
  const KEY_ASIDE=/\b(contexto|bastidor|extra|observa(ç|c)[aã]o lateral)\b/i;
  const KEY_OK=/\b(sucesso|ok|pronto|feito)\b/i;
  const KEY_Q=/\?\s*$/;
  function push(s){ OUT.push(s); }

  while(i<lines.length){
    let line=lines[i];
    if(/^\s*```/.test(line)){ push(line); i++; while(i<lines.length && !/^\s*```/.test(lines[i])) push(lines[i++]); if(i<lines.length) push(lines[i++]); continue; }
    const mFn=line.match(/^\s*["“”](.+function\s+[a-zA-Z_$][\w$]*\s*\([^)]*\)\s*\{.*\})["“”]\s*$/);
    if(mFn){ push('```js'); push(mFn[1]); push('```'); i++; continue; }
    const plain=line.trim();
    if(plain){
      if(KEY_WARN.test(plain)){  push(`::warn ${plain}`);  i++; continue; }
      if(KEY_ASIDE.test(plain)){ push(`::aside ${plain}`); i++; continue; }
      if(KEY_INFO.test(plain)){  push(`::info ${plain}`);  i++; continue; }
      if(KEY_OK.test(plain)){    push(`: ${plain}`);       i++; continue; }
      if(KEY_Q.test(plain)){     push(`? ${plain}`);       i++; continue; }
    }
    push(line); i++;
  }
  let md=OUT.join('\n');

  // Normaliza callouts multiline → linha única
  md = md.replace(
    /(^|\n)::(info|warn|aside|pulse|loop)\s*\n+([^:\n>][^\n]+(?:\n(?!::(info|warn|aside|pulse|loop)\b)[^\n]+)*)/gi,
    (m, pre, kind, body)=>`${pre}::${kind} ${body.replace(/\s*\n\s*/g,' ').trim()}`
  );

  // Tabelas pipe → lista-tabela (com coluna-chave opcional)
  md = md.replace(
    /(^|\n)\|([^\n]+)\|\n\|([ :\-|]+)\|\n((?:\|[^\n]+\|\n?)+)/g,
    (m, pre, headerRow, sepRow, bodyRows) => {
      const headers = headerRow.split('|').map(s=>s.trim());
      let keyIdx = -1;
      for(let i=0;i<headers.length;i++){
        const h=headers[i];
        if(/\(key\)|\[key\]|\*$/i.test(h) || /\b(chave|key)\b/i.test(h)){
          keyIdx=i; headers[i]=h.replace(/\s*(\(key\)|\[key\]|\*)\s*$/i,''); break;
        }
      }
      const body = bodyRows.trim().split('\n').map(r=>r.trim()).filter(Boolean).map(r=>{
        const cells = r.replace(/^\|/,'').replace(/\|$/,'').split('|').map(s=>s.trim());
        if(keyIdx>=0 && keyIdx<cells.length){ const c=cells[keyIdx]; cells[keyIdx]=/^\(.*\)$/.test(c)?c:`(${c})`; }
        return '- | '+cells.join(' | ')+' |';
      }).join('\n');
      return `${pre}|${headers.join(' | ')}|\n|${sepRow}|\n${body}\n`;
    }
  );

  if(o.addHeaderButtons){
    md = md.replace(/^#\s+.+$/m, (h1)=>`${h1}\n\n[[btn:gerar|Gerar]] [[btn:nested|Gerar (aninhado)]] [[btn:md|Salvar .md]] [[btn:pdf|Imprimir PDF]]\n`);
  }
  if(o.addMeta){ md += `\n\n::aside Documento gerado por MD Smart Generator (BUGADÃO v3)`;}
  return md;
}

// Exportador .md no padrão "lista-tabela"
function installExportMD_ListTable(){
  if(window.exportMD) return;
  window.exportMD = function(){
    const root=document.getElementById('root'); if(!root){ alert('Sem root'); return; }
    const parts=[];
    root.querySelectorAll('details.acc').forEach((d,secIdx)=>{
      const h=d.querySelector('summary h2'); if(h){ const mark='#'.repeat(secIdx===0?1:2); parts.push(`${mark} ${h.textContent.trim()}`); }
      d.querySelectorAll('.sec > *').forEach(el=>{
        if(el.matches('p')) parts.push(el.innerText.replace('Copiar','').trim());
        else if(el.matches('blockquote')) parts.push('> '+el.innerText.replace('Copiar','').trim());
        else if(el.matches('.callout')){
          const t=el.className.match(/\b(info|warn|tip|note|success|danger|aside|question)\b/);
          const kind=t?(t[1]==='note'?':': t[1]==='question'?'?': t[1]==='aside'?'::aside':'::'+t[1]):': ';
          parts.push(`${kind} `+el.innerText.replace('Copiar','').trim());
        }else if(el.matches('pre.md-code')){
          const code=el.querySelector('code')?.textContent||''; parts.push('```\n'+code+'\n```');
        }else if(el.matches('table.md-table')){
          const rows=[...el.querySelectorAll('tr')].map(tr=>[...tr.children].map(td=>td.innerText.trim()));
          if(rows.length){
            parts.push('| '+rows[0].join(' | ')+' |');
            parts.push('| '+rows[0].map(()=> '---').join(' | ')+' |');
            rows.slice(1).forEach(r=> parts.push('- | '+r.join(' | ')+' |'));
          }
        }else if(el.matches('ul,ol')){
          el.querySelectorAll('li').forEach(li=>parts.push('- '+li.innerText.trim()));
        }
      });
    });
    const blob=new Blob([parts.join('\n\n')],{type:'text/markdown'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='export_listTable.md'; a.click(); URL.revokeObjectURL(a.href);
    (window.toast||console.log)('.md exportado (lista-tabela)');
  };
}

// Upload → staging: LÊ COMO BYTES e decodifica com windows-1252 (Glitch ON) ou utf-8 (Glitch OFF)
function installUploadStagingBugadao(opts={}){
  const o = Object.assign({inputSelector:'input[type=file], #upload, #fileUpload, .upload-input'}, opts||{});
  const inputs = Array.from(document.querySelectorAll(o.inputSelector));
  const ta = tryFindTextarea();
  inputs.forEach(inp=>{
    if(inp.dataset.mdgenUpload==='1') return;
    inp.dataset.mdgenUpload='1';
    inp.addEventListener('change', (ev)=>{
      const f = ev.target.files && ev.target.files[0];
      if(!f) return;
      __mdgen_filename = f.name;
      const reader = new FileReader();
      reader.readAsArrayBuffer(f); // bytes puros
      reader.onload = ()=>{
        __mdgen_lastBytes = reader.result;
        const text = decodeBytes(__mdgen_lastBytes, MDGEN_GLITCH_MODE ? 'windows-1252' : 'utf-8');
        setTextarea(text);
        (window.toast||console.log)(`Upload carregado no input (staging, ${MDGEN_GLITCH_MODE?'GLITCH 1252':'UTF-8'})`);
      };
    }, false);
  });
}

// Monta UI (botões + toggle Glitch)
function mountMDGeneratorUI(){
  const tab=document.querySelector('#tab-text')||document.body;
  if(tab.querySelector('.btn-converter')) return;
  const ta = tryFindTextarea();
  const bar=document.createElement('div'); bar.style.display='flex'; bar.style.gap='8px'; bar.style.marginTop='8px'; bar.style.flexWrap='wrap';

  const b1=document.createElement('button'); b1.className='btn btn-converter'; b1.textContent='Converter → MD';
  b1.onclick=()=>{ const raw=(ta&&ta.value)?ta.value:''; const md=generateSmartMD(raw||'# Documento\n\nTexto aqui...'); if(ta){ ta.value=md; ta.focus(); ta.setSelectionRange(0,md.length);} (window.toast||console.log)('Texto convertido para MD'); };

  const b2=document.createElement('button'); b2.className='btn btn-gen-inteligente'; b2.textContent='Converter+Gerar';
  b2.onclick=()=>{ const raw=(ta&&ta.value)?ta.value:''; const md=generateSmartMD(raw||'# Documento\n\nTexto aqui...'); if(typeof window.autoBuild==='function'){ window.autoBuild(md); (window.toast||console.log)('Convertido e renderizado (ARN)'); } else { alert(md);} };

  const wrap=document.createElement('label'); wrap.style.display='inline-flex'; wrap.style.alignItems='center'; wrap.style.gap='6px';
  const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=true; cb.title='Glitch Mode (windows-1252)';
  const sp=document.createElement('span'); sp.textContent='😵‍💫 Glitch Mode';
  cb.onchange=()=>{
    MDGEN_GLITCH_MODE = cb.checked;
    if(__mdgen_lastBytes){
      const text = decodeBytes(__mdgen_lastBytes, MDGEN_GLITCH_MODE ? 'windows-1252' : 'utf-8');
      setTextarea(text);
      (window.toast||console.log)(`Re-decodificado ${__mdgen_filename||''} → ${MDGEN_GLITCH_MODE?'GLITCH 1252':'UTF-8'}`);
    }
  };
  wrap.appendChild(cb); wrap.appendChild(sp);

  bar.appendChild(b1); bar.appendChild(b2); bar.appendChild(wrap);
  tab.appendChild(bar);
}

function autoMountBugadao(){
  mountMDGeneratorUI();
  installUploadStagingBugadao();
  // exportador md
  installExportMD_ListTable();
  console.info('[MD Smart Generator · BUGADÃO v3] pronto.');
}
window.addEventListener('DOMContentLoaded', autoMountBugadao);
</script>


<!-- KOBLLUX :: PATCH ÚNICO — TTS por Blocos (v2 • Dock Vertical + Drag + Auto-Wire) -->
<style>
  /* =======================================================================
     KOBLLUX — TTS Dock (Nebula Pro + Base Madeira)
     MOBILE-FIRST VERTICAL HARD-LOCK
     ======================================================================= */

  /* Destaque do bloco atual lido */
  [data-tts-current]{
    outline:2px dashed var(--cyan,#4cf);
    background:rgba(76,240,255,.06);
    border-radius:8px;
    transition:background .25s ease, outline .25s ease;
  }

  /* Tokens */
  :root{
    --tts-dock-left: 8px;         /* ajuste livre */
    --tts-dock-bottom: 269px;     /* ajuste livre */
    --tts-gap: 10px;

    --tts-glass-bg: rgba(15,18,28,.38);
    --tts-glass-bd: rgba(255,255,255,.12);
    --tts-glow:     rgba(76,240,255,.85);   /* ciano (Nebula) */
    --tts-ink:      rgba(255,255,255,.92);
    --tts-ink-dim:  rgba(255,255,255,.68);
    --tts-accent:   color-mix(in srgb, #00e28b 55%, var(--tts-glow) 45%); /* Base Madeira + ciano */
  }

  /* Base inline (fallback) */
  .kob-tts-panel{
    display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;margin:.5rem 0
  }
  .kob-tts-panel button{
    padding:.5rem .75rem;
    border:1px solid rgba(255,255,255,.2);
    background:rgba(255,255,255,.05);
    backdrop-filter:saturate(1.2) blur(2px);
    border-radius:10px
  }
  .kob-tts-panel small{opacity:.8}

  /* Dock vertical fixo */
  .kob-tts-panel.is-dock{
    position: fixed;
    left: var(--tts-dock-left);
    bottom: calc(var(--tts-dock-bottom) + env(safe-area-inset-bottom, 0px));
    z-index: 9999;
    display: flex;
    flex-direction: column;
    gap: var(--tts-gap);
    align-items: stretch;

    padding: .6rem;
    border-radius: 16px;
    background: var(--tts-glass-bg);
    border: 1px solid var(--tts-glass-bd);
    -webkit-backdrop-filter: blur(10px) saturate(1.15);
    backdrop-filter: blur(10px) saturate(1.15);
    box-shadow: 0 12px 26px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.05);

    touch-action: none; /* habilita drag suave */
    cursor: grab;
  }
  .kob-tts-panel.is-dock.is-dragging{
    cursor: grabbing;
    transition: none !important;
  }

  .kob-tts-panel.is-dock button{
    width: 48px; height: 48px;
    border-radius: 14px;
    display: grid; place-items: center;

    color: var(--tts-ink-dim);
    font-size: 20px; line-height: 1; font-weight: 600;

    border: 1px solid rgba(255,255,255,.18);
    background:
      linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.02)) padding-box,
      linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.05)) border-box;

    box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
    cursor: pointer;
    transition: transform .16s ease, box-shadow .16s ease, color .16s ease, background .16s ease;
  }
  .kob-tts-panel.is-dock button:hover{
    transform: translateY(-1px);
    color: var(--tts-ink);
    box-shadow: 0 8px 18px rgba(0,0,0,.32), inset 0 0 0 1px rgba(255,255,255,.10);
  }
  .kob-tts-panel.is-dock button:active{ transform: translateY(0); }

  .kob-tts-panel.is-dock button[aria-pressed="true"]{
    color: var(--tts-ink);
    background:
      radial-gradient(120% 120% at 50% 0%, color-mix(in srgb, var(--tts-glow), transparent 65%) 0%, transparent 60%) padding-box,
      linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,.08)) border-box;
    outline: 2px solid color-mix(in srgb, var(--tts-glow) 70%, var(--tts-accent) 30%);
    box-shadow:
      0 0 18px -2px color-mix(in srgb, var(--tts-glow) 70%, var(--tts-accent) 30%),
      0 10px 26px rgba(0,0,0,.38),
      inset 0 0 0 1px rgba(255,255,255,.10);
  }

  /* micro-ripple sem JS */
  .kob-tts-panel.is-dock button::after{
    content:""; position:absolute; inset:0; border-radius:inherit; opacity:0;
    box-shadow: 0 0 0 0 var(--tts-glow);
    transition: box-shadow .4s ease, opacity .4s ease;
  }
  .kob-tts-panel.is-dock button:active::after{
    opacity:.4; box-shadow: 0 0 0 10px transparent;
  }

  .kob-tts-panel.is-dock small[data-tts-status]{
    margin-top: .15rem; font-size: 11px; letter-spacing: .2px;
    opacity: .78; color: var(--tts-ink); max-width: 172px; text-wrap: balance;
  }

  .kob-tts-panel.is-dock button:focus-visible{
    outline: 2px solid var(--tts-accent); outline-offset: 2px;
  }

  @supports not ((backdrop-filter: blur(10px))){
    .kob-tts-panel.is-dock{ background: rgba(20,22,28,.85); }
  }
  @media (prefers-reduced-motion: reduce){
    .kob-tts-panel.is-dock, .kob-tts-panel.is-dock button{ transition: none !important; }
  }
  @media print{ .kob-tts-panel.is-dock{ display:none !important; } }

  /* Espaço opcional no conteúdo quando o dock existir */
  body.kob-tts-dock-padding{ padding-left: calc(var(--tts-dock-left) + 72px); }
</style>

<script>
(()=>{ // IIFE – instala somente uma vez
  if(window.__KOB_TTS_V2_ACTIVE){ console.debug('[KOBLLUX TTS] já ativo'); return; }
  window.__KOB_TTS_V2_ACTIVE = true;

  const DOCKED = true;          // true = dock vertical fixo
  const DRAG_ENABLED = true;    // arrastar e lembrar posição
  const POS_KEY = 'kob_tts_dock_pos_v1';

  // ——— Mitigar conflito com TTS antigo ———
  try{
    if('speechSynthesis' in window){ window.speechSynthesis.cancel(); }
    if(window.__tts && typeof window.__tts.stop === 'function'){ try{ window.__tts.stop(); }catch(e){} }
    window.__tts = { set:()=>{}, speak:()=>{}, stop:()=>{} }; // no-op legacy
  }catch(e){}

  const synth = ('speechSynthesis' in window) ? window.speechSynthesis : null;
  if(!synth){ console.warn('[KOBLLUX TTS] SpeechSynthesis não disponível'); return; }

  // ——— Seletores tolerantes para raiz renderizada/analisada ———
  const ROOT_SELECTORS = ['#root','[data-analyzer-output]','.analyzer-output','#render','main','.content'];
  const getRoot = ()=> {
    for(const sel of ROOT_SELECTORS){
      const el = document.querySelector(sel);
      if(el) return el;
    }
    return document.body;
  };

  // ——— UI ———
  const ensurePanel = ()=>{
    let wrap = document.querySelector('.kob-tts-panel');
    let btnT = document.getElementById('btn-tts');
    let btnS = document.getElementById('btn-tts-sel');
    let btnX = document.getElementById('btn-tts-stop');
    let btnPrev = document.getElementById('btn-tts-prev');
    let btnNext = document.getElementById('btn-tts-next');
    let status = document.querySelector('[data-tts-status]');

    if(!(btnT && btnS && btnX && status)){
      wrap = document.createElement('div');
      wrap.className = 'kob-tts-panel' + (DOCKED ? ' is-dock' : '');
      wrap.innerHTML = DOCKED
        ? `
          <button id="btn-tts"       type="button" title="Ativar/Desativar leitura contínua" aria-pressed="false">🔊</button>
          <button id="btn-tts-prev"  type="button" title="Bloco anterior">◀</button>
          <button id="btn-tts-next"  type="button" title="Próximo bloco">▶</button>
          <button id="btn-tts-sel"   type="button" title="Ler apenas seleção">✂︎</button>
          <button id="btn-tts-stop"  type="button" title="Parar voz">■</button>
          <small data-tts-status>Pronto.</small>
        `
        : `
          <button id="btn-tts"       type="button" title="Ativar/Desativar leitura contínua">Voz: Off</button>
          <button id="btn-tts-prev"  type="button" title="Bloco anterior">◀</button>
          <button id="btn-tts-next"  type="button" title="Próximo bloco">▶</button>
          <button id="btn-tts-sel"   type="button" title="Ler apenas seleção">Ler seleção</button>
          <button id="btn-tts-stop"  type="button" title="Parar voz">Parar</button>
          <small data-tts-status>Pronto.</small>
        `;
      document.body.appendChild(wrap);
      btnT   = wrap.querySelector('#btn-tts');
      btnS   = wrap.querySelector('#btn-tts-sel');
      btnX   = wrap.querySelector('#btn-tts-stop');
      btnPrev= wrap.querySelector('#btn-tts-prev');
      btnNext= wrap.querySelector('#btn-tts-next');
      status = wrap.querySelector('[data-tts-status]');
    }else if(DOCKED){
      const w = btnT.closest('.kob-tts-panel'); if(w) w.classList.add('is-dock');
      btnT.textContent='🔊'; if(btnPrev) btnPrev.textContent='◀'; if(btnNext) btnNext.textContent='▶';
      btnS.textContent='✂︎'; btnX.textContent='■';
    }

    return {wrap, btnT, btnS, btnX, btnPrev, btnNext, status};
  };

  // ——— Toast seguro ———
  const toastSafe = (msg)=> { try{ if(typeof window.toast==='function') window.toast(msg); }catch(e){} };

  // ——— Voz ———
  let voice = null;
  const pickVoice = ()=>{
    const vs = synth.getVoices() || [];
    return vs.find(v=>/pt[-_]BR/i.test(v.lang))
        || vs.find(v=>/pt/i.test(v.lang))
        || vs[0] || null;
  };
  const ensureVoice = ()=> { if(!voice) voice = pickVoice(); };
  synth.onvoiceschanged = ()=> { if(!voice) voice = pickVoice(); };

  // ——— Estado TTS ———
  let blocks = [];        // [{ node, text }]
  let currentIndex = 0;
  let speaking = false;
  let utterance = null;
  let errorStreak = 0;
  const MAX_ERRORS = 3;

  // ——— Utils ———
  const setLabel = (btn, on)=>{
    if(!btn) return;
    if(DOCKED){ btn.setAttribute('aria-pressed', on ? 'true' : 'false'); btn.textContent = '🔊'; }
    else{ btn.textContent = 'Voz: ' + (on ? 'On' : 'Off'); }
  };
  const setStatus = (el, txt)=> { if(el) el.textContent = txt; };
  const clearHighlight = ()=> document.querySelectorAll('[data-tts-current]').forEach(el=>el.removeAttribute('data-tts-current'));
  const highlightCurrent = ()=>{
    clearHighlight();
    if(!blocks.length) return;
    const b = blocks[currentIndex]; if(!b || !b.node) return;
    b.node.setAttribute('data-tts-current','true');
    try{ b.node.scrollIntoView({behavior:'smooth', block:'center'});}catch(e){}
  };

  const BUILD_NODE_SEL = [
    'h1','h2','h3','h4','h5','h6',
    'p','li','blockquote','.callout',
    'pre.md-code','codeblock','table.md-table td','table.md-table th'
  ].join(',');

  const buildBlocksFromDOM = ()=>{
    const root = getRoot();
    const nodes = root.querySelectorAll(BUILD_NODE_SEL);
    const list = [];
    nodes.forEach(node=>{
      let text = (node.innerText || '').replace(/\bCopiar\b/g,'').trim();
      if(!text) return;
      list.push({ node, text });
    });
    blocks = list;
    currentIndex = 0;
    errorStreak = 0;
    setStatus(ui.status, blocks.length ? `TTS pronto: ${blocks.length} blocos.` : 'Nenhum bloco válido.');
    if(blocks.length) toastSafe('TTS pronto: ' + blocks.length + ' blocos');
  };

  const stopInternal = ()=>{
    speaking = false; errorStreak = 0;
    try{ synth.cancel(); }catch(e){}
    if(utterance){ try{ utterance.onend=null; utterance.onerror=null; }catch(e){}; utterance=null; }
    clearHighlight(); setLabel(ui.btnT, false); setStatus(ui.status, 'TTS parado.');
  };

  const speakCurrent = ()=>{
    if(!blocks.length) buildBlocksFromDOM();
    if(!blocks.length){ stopInternal(); return; }

    if(currentIndex < 0) currentIndex = 0;
    if(currentIndex >= blocks.length){ stopInternal(); toastSafe('Fim dos blocos'); return; }

    const b = blocks[currentIndex];
    if(!b || !b.text || !b.text.trim()){
      errorStreak++;
      if(errorStreak > MAX_ERRORS){ toastSafe('Muitos blocos vazios/erro. Pausado.'); stopInternal(); return; }
      currentIndex++; speakCurrent(); return;
    }

    try{ synth.cancel(); }catch(e){}
    ensureVoice();

    utterance = new SpeechSynthesisUtterance(b.text.trim());
    if(voice) utterance.voice = voice;
    utterance.lang = (voice && voice.lang) || 'pt-BR';
    utterance.rate = 1.0; utterance.pitch = 1.0; utterance.volume = 1.0;

    utterance.onend   = ()=>{ if(!speaking) return; currentIndex++; speakCurrent(); };
    utterance.onerror = ()=>{ if(!speaking) return; errorStreak++; (errorStreak>MAX_ERRORS)?(toastSafe('Erros seguidos. Pausado.'), stopInternal()):(currentIndex++, speakCurrent()); };

    highlightCurrent();
    setStatus(ui.status, `Lendo ${currentIndex+1}/${blocks.length}…`);
    synth.speak(utterance);
  };

  // ——— Controles ———
  const toggle = ()=>{
    if(speaking){ stopInternal(); toastSafe('Voz desativada'); return; }
    speaking = true; setLabel(ui.btnT, true);
    if(!blocks.length) buildBlocksFromDOM();
    speakCurrent(); toastSafe('Voz ativada');
  };
  const speakSelection = ()=>{
    const text = (window.getSelection && String(window.getSelection())) || '';
    const t = text.trim();
    if(!t){ toastSafe('Selecione um trecho primeiro'); return; }
    ensureVoice(); try{ synth.cancel(); }catch(e){}
    const u = new SpeechSynthesisUtterance(t);
    if(voice) u.voice = voice;
    u.lang = (voice && voice.lang) || 'pt-BR';
    u.rate = 1.0; u.pitch = 1.0; u.volume = 1.0;
    synth.speak(u);
  };
  const nextBlock = ()=>{ if(!blocks.length) buildBlocksFromDOM(); speaking = true; setLabel(ui.btnT, true); currentIndex++; speakCurrent(); };
  const prevBlock = ()=>{ if(!blocks.length) buildBlocksFromDOM(); speaking = true; setLabel(ui.btnT, true); currentIndex = Math.max(0, currentIndex-1); speakCurrent(); };

  // ——— Auto-wire: botões externos "TTS" / "ouvir TTS" ———
  const isTTSLabel = (el)=>{
    const t = (el.textContent||'').toLowerCase().replace(/\s+/g,' ').trim();
    return /\btts\b/.test(t) || t.includes('ouvir tts');
  };
  const bindExternal = (root=document)=>{
    const candidates = Array.from(root.querySelectorAll('button, a, [role="button"], .btn, .button'))
      .filter(el=>!el.dataset.kobTtsBound && isTTSLabel(el));
    candidates.forEach(el=>{
      el.dataset.kobTtsBound = '1';
      el.addEventListener('click', (e)=>{ e.preventDefault(); toggle(); }, { passive:false });
      el.title = (el.title||'') || 'Ativar/Desativar TTS';
    });
  };
  const mo = new MutationObserver((muts)=>{
    for(const m of muts){
      if(m.addedNodes) m.addedNodes.forEach(n=>{ if(n.nodeType===1) bindExternal(n); });
    }
  });

  // ——— Drag + persistência ———
  const applySavedDockPos = ()=>{
    try{
      const saved = JSON.parse(localStorage.getItem(POS_KEY)||'null');
      if(saved && typeof saved.left==='number' && typeof saved.bottom==='number'){
        document.documentElement.style.setProperty('--tts-dock-left', `${saved.left}px`);
        document.documentElement.style.setProperty('--tts-dock-bottom', `${saved.bottom}px`);
      }
    }catch(e){}
  };
  const enableDrag = (wrap)=>{
    if(!DRAG_ENABLED || !wrap) return;
    let startX=0, startY=0, startLeft=0, startBottom=0, dragging=false;

    const onDown = (ev)=>{
      const e = ev.touches ? ev.touches[0] : ev;
      dragging=true; wrap.classList.add('is-dragging');
      startX = e.clientX; startY = e.clientY;
      const cs = getComputedStyle(document.documentElement);
      startLeft   = parseFloat(cs.getPropertyValue('--tts-dock-left')) || 8;
      startBottom = parseFloat(cs.getPropertyValue('--tts-dock-bottom')) || 269;
      window.addEventListener('pointermove', onMove, {passive:false});
      window.addEventListener('pointerup', onUp, {passive:false});
      window.addEventListener('touchmove', onMove, {passive:false});
      window.addEventListener('touchend', onUp, {passive:false});
    };
    const onMove = (ev)=>{
      if(!dragging) return;
      const e = ev.touches ? ev.touches[0] : ev;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      const left = Math.max(0, startLeft + dx);
      const bottom = Math.max(0, startBottom - dy); // mover para cima aumenta bottom
      document.documentElement.style.setProperty('--tts-dock-left', `${left}px`);
      document.documentElement.style.setProperty('--tts-dock-bottom', `${bottom}px`);
    };
    const onUp = ()=>{
      if(!dragging) return;
      dragging=false; wrap.classList.remove('is-dragging');
      const cs = getComputedStyle(document.documentElement);
      const left   = parseFloat(cs.getPropertyValue('--tts-dock-left')) || 8;
      const bottom = parseFloat(cs.getPropertyValue('--tts-dock-bottom')) || 269;
      try{ localStorage.setItem(POS_KEY, JSON.stringify({left,bottom})); }catch(e){}
      window.removeEventListener('pointermove', onMove);
      window.removeEventListener('pointerup', onUp);
      window.removeEventListener('touchmove', onMove);
      window.removeEventListener('touchend', onUp);
    };

    wrap.addEventListener('pointerdown', onDown);
    wrap.addEventListener('touchstart', onDown);
  };

  // ——— Boot ———
  let ui = {wrap:null,btnT:null,btnS:null,btnX:null,status:null,btnPrev:null,btnNext:null};

  const boot = ()=>{
    applySavedDockPos();
    const got = ensurePanel();
    ui = {
      wrap:   got.wrap,
      btnT:   got.btnT,
      btnS:   got.btnS,
      btnX:   got.btnX,
      status: got.status,
      btnPrev: got.btnPrev,
      btnNext: got.btnNext,
    };
    setLabel(ui.btnT,false);
    setStatus(ui.status,'Pronto.');

    // binds painel
    ui.btnT   && ui.btnT.addEventListener('click', e=>{e.preventDefault(); toggle();});
    ui.btnS   && ui.btnS.addEventListener('click', e=>{e.preventDefault(); speakSelection();});
    ui.btnX   && ui.btnX.addEventListener('click', e=>{e.preventDefault(); stopInternal();});
    ui.btnPrev&& ui.btnPrev.addEventListener('click', e=>{e.preventDefault(); prevBlock();});
    ui.btnNext&& ui.btnNext.addEventListener('click', e=>{e.preventDefault(); nextBlock();});

    // teclado opcional (←/→)
    window.addEventListener('keydown', (ev)=>{
      if(ev.target && /input|textarea/i.test(ev.target.tagName)) return;
      if(ev.key==='ArrowRight'){ nextBlock(); }
      if(ev.key==='ArrowLeft'){ prevBlock(); }
    });

    // integra com ACTIONS (compat)
    window.ACTIONS = window.ACTIONS || {};
    const oldTTS = window.ACTIONS.tts;
    window.ACTIONS.tts = ()=>{ try{ toggle(); }catch(e){}; if(typeof oldTTS==='function'){ /* compat */ } };
    window.ACTIONS.ttsPrev = ()=>{ prevBlock(); };
    window.ACTIONS.ttsNext = ()=>{ nextBlock(); };
    window.ACTIONS.ttsStop = ()=>{ stopInternal(); };

    // expõe API global
    window.KOBLLUX_TTS = {
      rebuild: ()=>buildBlocksFromDOM(),
      play: ()=>{ if(!speaking){ speaking=true; setLabel(ui.btnT,true); } speakCurrent(); },
      stop: stopInternal,
      next: nextBlock,
      prev: prevBlock,
      info: ()=>({ blocks:blocks.length, currentIndex, speaking })
    };

    // Auto-wire em botões externos
    bindExternal(document);
    mo.observe(document.documentElement, {childList:true, subtree:true});

    // Drag opcional
    if(DOCKED && DRAG_ENABLED){ enableDrag(ui.wrap); }
  };

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', boot, { once:true });
  }else{
    boot();
  }
})();
</script>
<!-- /KOBLLUX :: PATCH ÚNICO — TTS por Blocos -->

<!-- KOBLLUX :: TTS v32 — Dock + Outline + Vozes PT-BR + ASCII + Status compacto -->
<script>
(()=>{ if(window.__KOB_TTS_V32_ACTIVE) return; window.__KOB_TTS_V32_ACTIVE = true;

  /* ---------- Constantes & Preferências ---------- */
  const POS_KEY  = 'kob_tts_pos_v3';
  const PREF_KEY = 'kob_tts_prefs_v32';
  const ROOTS    = ['#root','[data-analyzer-output]','.analyzer-output','#render','main','.content'];
  const BLOCK_SEL= [
    'h1','h2','h3','h4','h5','h6',
    'p','li','blockquote','.callout','.equation','pre','td','th','codeblock'
  ].join(',');

  const PREFS = Object.assign({
    outline: true,
    asciiMode: 'describe',      // 'describe' | 'skip' | 'read'
    clickToSpeak: true,         // clicar no bloco inicia leitura
    preferMale: true            // prioridade de vozes
  }, readPrefs());

  /* ---------- Util ---------- */
  const $  = (q, r=document)=> r.querySelector(q);
  const $$ = (q, r=document)=> [...r.querySelectorAll(q)];
  const setCSS = (v,val)=> document.documentElement.style.setProperty(v,val);
  const toast  = (m)=> { try{ window.toast && window.toast(m); }catch{} };
  const getRoot= ()=> { for(const s of ROOTS){ const el=document.querySelector(s); if(el) return el; } return document.body; };

  /* ---------- Dock ---------- */
  const dock = document.querySelector('.kob-tts-dock') || (()=> {
    const d = document.createElement('div');
    d.className = 'kob-tts-dock';
    d.innerHTML = `
      <button id="tts-on"      title="Voz On/Off" aria-pressed="false">🔊</button>
      <button id="tts-prev"    title="Anterior">◀</button>
      <button id="tts-next"    title="Próximo">▶</button>
      <button id="tts-sel"     title="Ler seleção">✂︎</button>
      <button id="tts-stop"    title="Parar">■</button>
      <button id="tts-reread"  title="Re-Ler do início (abrir tudo)">⟳</button>
      <button id="tts-reset"   title="Reset + próxima seção">↻</button>
      <button id="tts-openall" title="Abrir Tudo (acordeons/detalhes)">◎</button>
      <button id="tts-grid"    title="Outline / Click-to-Speak">⌗</button>
      <button id="tts-voice"   title="Trocar Voz PT-BR (segurar: alterna masc/fem)">🎙</button>
      <small id="tts-status">Pronto.</small>
    `;
    document.body.appendChild(d);
    return d;
  })();

  /* Outline/grade */
  const outline = document.getElementById('kob-tts-outline') || (()=> {
    const o = document.createElement('div');
    o.id='kob-tts-outline';
    document.body.appendChild(o);
    return o;
  })();

  /* Drag e posição */
  applySavedPos();
  ;(()=>{ let sx=0,sy=0,sl=0,sb=0,drag=false;
    const onDown=(ev)=>{ const e=ev.touches?ev.touches[0]:ev; drag=true; dock.classList.add('is-drag'); sx=e.clientX; sy=e.clientY;
      const cs=getComputedStyle(document.documentElement);
      sl=parseFloat(cs.getPropertyValue('--tts-left'))||8;
      sb=parseFloat(cs.getPropertyValue('--tts-bottom'))||240;
      addEventListener('pointermove',onMove,{passive:false});
      addEventListener('pointerup',onUp,{passive:false});
      addEventListener('touchmove',onMove,{passive:false});
      addEventListener('touchend',onUp,{passive:false});
    };
    const onMove=(ev)=>{ if(!drag) return; const e=ev.touches?ev.touches[0]:ev;
      const dx=e.clientX-sx, dy=e.clientY-sy;
      setCSS('--tts-left',   Math.max(0, sl+dx)+'px');
      setCSS('--tts-bottom', Math.max(0, sb-dy)+'px');
    };
    const onUp=()=>{ if(!drag) return; drag=false; dock.classList.remove('is-drag'); savePos(); };
    dock.addEventListener('pointerdown',onDown); dock.addEventListener('touchstart',onDown);
  })();

  /* ---------- Speech & Vozes ---------- */
  const synth = ('speechSynthesis' in window) ? window.speechSynthesis : null;
  if(!synth){ console.warn('[TTS] SpeechSynthesis indisponível'); return; }
  try{ synth.cancel(); }catch{}

  let VOICES=[], baseVoice=null, voiceIdx=0;
  const MALE   = /(ricardo|thiago|jo[aã]o|daniel|felipe|bruno|rafael|marc(o|os)|c[aá]ssio)/i;
  const FEMALE = /(luciana|camila|fabiana|maria|helena|ana|carla|bia|let[ií]cia|fernanda)/i;

  function loadVoices(){
    VOICES = synth.getVoices()||[];
    const pt = VOICES.filter(v=>/pt/i.test(v.lang));
    const pri = (PREFS.preferMale? MALE : FEMALE);
    const sec = (PREFS.preferMale? FEMALE: MALE);
    baseVoice = pt.find(v=> pri.test(v.name||'')) || pt.find(v=> sec.test(v.name||'')) || pt[0] || VOICES[0] || null;
    voiceIdx  = Math.max(0, (pt.indexOf(baseVoice)));
  }
  synth.onvoiceschanged = ()=> loadVoices();
  loadVoices();

  function cycleVoice(){
    const pt = VOICES.filter(v=>/pt/i.test(v.lang));
    if(!pt.length) return;
    voiceIdx = (voiceIdx+1) % pt.length;
    baseVoice = pt[voiceIdx];
    setStatus(`Voz: ${baseVoice.name||baseVoice.lang}`);
  }
  function toggleVoicePriority(){ // segurar
    PREFS.preferMale = !PREFS.preferMale; savePrefs();
    loadVoices();
    setStatus(`Preferência: ${PREFS.preferMale?'masculina':'feminina'}`);
  }

  const ARCH_STYLES = {
    atlas:{ rate:.95, pitch:1.00, find:/\b(atlas)\b/i },
    nova:{ rate:1.12, pitch:1.12, find:/\b(nova)\b/i },
    vitalis:{ rate:1.08, pitch:1.05, find:/\b(vitalis)\b/i },
    pulse:{ rate:1.04, pitch:1.08, find:/\b(pulse|pulso)\b/i },
    serena:{ rate:.98, pitch:.96, find:/\b(serena)\b/i },
    kaos:{ rate:1.18, pitch:1.02, find:/\b(kaos)\b/i },
    genus:{ rate:1.00, pitch:1.00, find:/\b(genus)\b/i },
    lumine:{ rate:1.0, pitch:1.10, find:/\b(lumine)\b/i },
    rhea:{ rate:.97, pitch:1.00, find:/\b(rhea)\b/i },
    solus:{ rate:.93, pitch:.95, find:/\b(solus)\b/i },
    aion:{ rate:1.00, pitch:1.08, find:/\b(aion)\b/i }
  };
  function voiceStyleFor(text){
    for(const k in ARCH_STYLES){ if(ARCH_STYLES[k].find.test(text)) return ARCH_STYLES[k]; }
    return {rate:1.01,pitch:1.0};
  }
  function pickVoiceFor(text){
    const st = voiceStyleFor(text);
    return { voice: baseVoice, rate: st.rate, pitch: st.pitch };
  }

  /* ---------- Estado ---------- */
  let blocks=[], idx=0, speaking=false, u=null;

  function setPressed(btn,on){ btn?.setAttribute('aria-pressed', on?'true':'false'); }
  function setStatus(t){ const el=$('#tts-status',dock); if(!el) return; el.textContent=String(t); }
  function setStatusProgress(){ const el=$('#tts-status',dock); if(!el) return;
    if(!blocks.length){ el.textContent='0/0'; return; }
    el.textContent = `${Math.min(idx+1,blocks.length)}/${blocks.length}`;
  }

  function isAsciiArt(txt){
    const lines=txt.split(/\n/);
    const raw=txt.replace(/\s+/g,'');
    const nonWord=(raw.replace(/[A-Za-zÀ-ÿ0-9]/g,'').length)/(raw.length||1);
    const box=/[░▒▓█▀▄▌▐─═║╔╗╝╚╩╦╠╣┌┐└┘]/.test(txt);
    const wide=lines.some(l=> l.length>28 && l.replace(/[A-Za-zÀ-ÿ0-9]/g,'').length/(l.length||1)>.45);
    return box || nonWord>.42 || wide;
  }
  function describeAscii(txt){
    const t=txt||''; const parts=[];
    if(/[█▓▒░]{4,}/.test(t)) parts.push('massa sólida');
    if(/[─═]{4,}/.test(t))   parts.push('linhas horizontais');
    if(/[┼╬╦╩╠╣]/.test(t))   parts.push('grade geométrica');
    if(/[△▲▵]/.test(t))     parts.push('triângulos');
    if(/[○●◯]/.test(t))     parts.push('círculos');
    return 'Arte ASCII' + (parts.length?(' — '+parts.join(', ')):'');
  }
  function stripKaTeX(s){
    // remove $$…$$ e $…$ do KaTeX/LaTeX para não “soletrar” símbolos
    s = s.replace(/\$\$[\s\S]*?\$\$/g,' ');
    s = s.replace(/\$[^$]*\$/g,' ');
    return s;
  }
  function sanitize(txt,type){
    let s = stripKaTeX(txt||'');
s = s.replace(/[\\/*_|=`~^<>#${}()+\-]+/g, ' ');
s = s.replace(/\$begin:math:display\$\$[\s\S]*?\$\$end:math:display\$/g, ' ');
    s = s.replace(/:+/g, ', ').replace(/\.+/g, ', ');
    s = s.replace(/\s{2,}/g,' ').trim();
    if(type==='code')     return 'Bloco de código com ' + (txt.split(/\n/).length) + ' linhas.';
    if(type==='equation') return 'Equação matemática.';
    if(type==='ascii'){
      if(PREFS.asciiMode==='skip') return '';
      if(PREFS.asciiMode==='describe') return describeAscii(txt);
    }
    return s;
  }

  function sectionIndexOf(node){
    const secs = $$('#root details, details, .acc details, details.acc');
    const i = secs.findIndex(d=> d.contains(node));
    return i<0?0:i;
  }

  /* ---------- EXPANDIR TODOS ---------- */
  function expandAll(open=true){
    $$('details').forEach(d=> d.open = !!open);
    $$('[aria-expanded]').forEach(el=>{
      el.setAttribute('aria-expanded', open?'true':'false');
      const id = el.getAttribute('aria-controls');
      if(id){ const tgt = document.getElementById(id); if(tgt) tgt.hidden = !open; }
    });
    $$('[data-open]').forEach(el=> el.setAttribute('data-open', open?'1':'0'));
  }

  /* ---------- Build ---------- */
  function rebuild(){
    const root = getRoot();
    const nodes = $$(BLOCK_SEL, root);
    const out=[];
    for(const node of nodes){
      let raw = (node.innerText||'').replace(/\bCopiar\b/g,'').trim();
      if(!raw) continue;
      const type = node.matches('pre') ? 'code'
                : node.matches('.equation') ? 'equation'
                : isAsciiArt(raw) ? 'ascii'
                : node.matches('blockquote,.callout') ? 'quote'
                : node.matches('li') ? 'list'
                : node.matches('td,th') ? 'cell'
                : node.matches('h1,h2,h3,h4,h5,h6') ? 'heading'
                : 'para';
      out.push({ node, raw, type, sectionIdx: sectionIndexOf(node) });
    }
    blocks = out; idx = 0;
    setStatus(blocks.length ? `${blocks.length}/${blocks.length}` : '0/0');
  }

  /* ---------- Outline ---------- */
  function hideOutline(){ outline.style.display='none'; }
  function showOutlineFor(node){
    if(!PREFS.outline || !node) return hideOutline();
    const r=node.getBoundingClientRect();
    outline.style.display='block';
    outline.style.left  =(scrollX+r.left-6)+'px';
    outline.style.top   =(scrollY+r.top -6)+'px';
    outline.style.width =(r.width+12)+'px';
    outline.style.height=(r.height+12)+'px';
  }
  function highlight(){
    $$('[data-tts-current]').forEach(el=>el.removeAttribute('data-tts-current'));
    const b=blocks[idx]; if(!b) return;
    b.node.setAttribute('data-tts-current','true');
    try{ b.node.scrollIntoView({behavior:'smooth', block:'center'});}catch{}
    showOutlineFor(b.node);
  }
  addEventListener('scroll', ()=>{ const b=blocks[idx]; if(PREFS.outline && b) showOutlineFor(b.node); }, {passive:true});
  addEventListener('resize', ()=>{ const b=blocks[idx]; if(PREFS.outline && b) showOutlineFor(b.node); });

  /* ---------- Speak ---------- */
  function speakCurrent(){
    if(!blocks.length) rebuild();
    if(idx<0) idx=0;
    if(idx>=blocks.length){ stop(); toast('Fim.'); return; }

    const b = blocks[idx];
    const text = sanitize(b.raw, b.type);
    if(!text){ idx++; setStatusProgress(); return speakCurrent(); }

    try{ synth.cancel(); }catch{}
    const conf = pickVoiceFor(text);
    const u = new SpeechSynthesisUtterance(text);
    if(conf.voice) u.voice = conf.voice;
    u.lang = (conf.voice && conf.voice.lang) || 'pt-BR';
    u.rate = conf.rate; u.pitch = conf.pitch; u.volume=1;

    u.onend   = ()=>{ if(!speaking) return; idx++; setStatusProgress(); speakCurrent(); };
    u.onerror = ()=>{ if(!speaking) return; idx++; setStatusProgress(); speakCurrent(); };

    highlight();
    setStatusProgress();
    synth.speak(u);
  }
  function play(){ speaking=true; setPressed($('#tts-on',dock),true); if(!blocks.length) rebuild(); speakCurrent(); }
  function stop(){ speaking=false; try{ synth.cancel(); }catch{} setPressed($('#tts-on',dock),false); setStatus(blocks.length?`${Math.min(idx+1,blocks.length)}/${blocks.length}`:'Pausado.'); hideOutline(); }
  function toggle(){ speaking ? stop() : play(); }
  function next(){ if(!blocks.length) rebuild(); speaking=true; setPressed($('#tts-on',dock),true); idx++; setStatusProgress(); speakCurrent(); }
  function prev(){ if(!blocks.length) rebuild(); speaking=true; setPressed($('#tts-on',dock),true); idx=Math.max(0,idx-1); setStatusProgress(); speakCurrent(); }

  /* ---------- Reset & Re-Ler ---------- */
  function reset(opts={}){
    expandAll(true);
    stop(); rebuild();
    if(opts.nextSection===true){
      const cur = blocks[idx]?.sectionIdx ?? 0;
      const j = blocks.findIndex(b=> b.sectionIdx>cur);
      idx = j>=0 ? j : 0;
    }else if(typeof opts.sectionIndex==='number'){
      const j = blocks.findIndex(b=> b.sectionIdx===opts.sectionIndex);
      idx = j>=0 ? j : 0;
    }else{
      idx = 0;
    }
    setStatus(blocks.length?`${idx+1}/${blocks.length}`:'Pronto.');
    if(PREFS.outline && blocks[idx]) showOutlineFor(blocks[idx].node);
  }
  function rereadFromStart(){
    expandAll(true);
    rebuild();
    idx=0; play();
  }

  /* ---------- Click-to-Speak (Outline ON) ---------- */
  document.addEventListener('click', (ev)=>{
    const blk = ev.target.closest(BLOCK_SEL);
    if(!blk) return;
    const i = blocks.findIndex(b=> b.node===blk);
    if(i<0) return;
    idx=i;
    if(PREFS.outline) showOutlineFor(blk);
    if(PREFS.clickToSpeak){
      speaking=true; setPressed($('#tts-on',dock),true);
      speakCurrent();
    }else{
      setStatusProgress();
    }
  }, {passive:false});

  /* ---------- Seleção ---------- */
  $('#tts-sel',dock)?.addEventListener('click', (e)=>{
    e.preventDefault();
    const t = String(window.getSelection && window.getSelection()).trim();
    if(!t){ toast('Selecione um trecho'); return; }
    try{ synth.cancel(); }catch{}
    const conf = pickVoiceFor(t);
    const uu = new SpeechSynthesisUtterance(sanitize(t,'para'));
    if(conf.voice) uu.voice=conf.voice;
    uu.lang=(conf.voice&&conf.voice.lang)||'pt-BR'; uu.rate=conf.rate; uu.pitch=conf.pitch; uu.volume=1;
    synth.speak(uu);
  });

  /* ---------- Botões ---------- */
  $('#tts-on',dock)?.addEventListener('click', e=>{ e.preventDefault(); toggle(); });
  $('#tts-prev',dock)?.addEventListener('click', e=>{ e.preventDefault(); prev(); });
  $('#tts-next',dock)?.addEventListener('click', e=>{ e.preventDefault(); next(); });
  $('#tts-stop',dock)?.addEventListener('click', e=>{ e.preventDefault(); stop(); });
  $('#tts-reset',dock)?.addEventListener('click', e=>{ e.preventDefault(); reset({nextSection:true}); });
  $('#tts-reread',dock)?.addEventListener('click', e=>{ e.preventDefault(); rereadFromStart(); });
  $('#tts-openall',dock)?.addEventListener('click', e=>{ e.preventDefault(); expandAll(true); rebuild(); setStatusProgress(); });

  // Outline toggle (e click-to-speak junto)
  $('#tts-grid',dock)?.addEventListener('click', e=>{
    e.preventDefault();
    PREFS.outline = !PREFS.outline;
    PREFS.clickToSpeak = PREFS.outline;
    savePrefs();
    if(!PREFS.outline) hideOutline(); else { const b=blocks[idx]; b && showOutlineFor(b.node); }
    setPressed($('#tts-grid',dock), PREFS.outline);
  });
  setPressed($('#tts-grid',dock), PREFS.outline);

  // Voz: click = cicla, longpress = alterna prioridade masc/fem
  ;(()=>{ const btn=$('#tts-voice',dock); if(!btn) return;
    let pressT=null, pressed=false;
    const down=()=>{ pressed=true; pressT=setTimeout(()=>{ pressed='hold'; toggleVoicePriority(); }, 550); };
    const up=()=>{ if(pressT){ clearTimeout(pressT); pressT=null; } if(pressed===true){ cycleVoice(); } pressed=false; };
    btn.addEventListener('pointerdown', down); btn.addEventListener('pointerup', up); btn.addEventListener('pointerleave', up);
    btn.addEventListener('touchstart', down);  btn.addEventListener('touchend', up);
  })();

  /* ---------- Integrar com AUTO-GERAR do app ---------- */
  hook('autoBuild'); hook('autoBuildNested');
  function hook(name){
    if(typeof window[name]==='function'){
      const orig=window[name];
      window[name]=function(){
        const out=orig.apply(this, arguments);
        setTimeout(()=>{ expandAll(true); rebuild(); setStatusProgress(); }, 30);
        return out;
      }
    }
  }

  /* ---------- Boot ---------- */
  try{ window.__tts && typeof window.__tts.stop==='function' && window.__tts.stop(); }catch{}
  expandAll(true);
  rebuild();
  setStatusProgress();

  /* ---------- Helpers ---------- */
  function readPrefs(){ try{ return JSON.parse(localStorage.getItem(PREF_KEY)||'{}'); }catch{ return {}; } }
  function savePrefs(){ try{ localStorage.setItem(PREF_KEY, JSON.stringify(PREFS)); }catch{} }
  function applySavedPos(){
    try{
      const s=JSON.parse(localStorage.getItem(POS_KEY)||'null');
      if(s){ setCSS('--tts-left', s.left); setCSS('--tts-bottom', s.bottom); }
    }catch{}
  }
  function savePos(){
    try{
      const cs=getComputedStyle(document.documentElement);
      localStorage.setItem(POS_KEY, JSON.stringify({
        left: cs.getPropertyValue('--tts-left').trim(),
        bottom: cs.getPropertyValue('--tts-bottom').trim()
      }));
    }catch{}
  }
})();
</script>

<script>
/* PATCH: substitui a função pickVoiceFor original pela versão com HOOK */
function pickVoiceFor(text){
  // se existir um hook externo (IA), tenta classificar primeiro
  try{
    if (window.KOB_TTS_VOICE_STYLE_HOOK) {
      const arch = window.KOB_TTS_VOICE_STYLE_HOOK(text);
      if (arch) {
        const ST = {
          atlas:{rate:.95,pitch:0.80}, nova:{rate:1.09,pitch:1.18},
          vitalis:{rate:1.08,pitch:1.34}, pulse:{rate:1.02,pitch:1.12},
          serena:{rate:.98,pitch:.96}, kaos:{rate:1.13,pitch:1.02},
          genus:{rate:1.00,pitch:1.00}, lumine:{rate:1.00,pitch:1.28},
          rhea:{rate:.97,pitch:0.78}, solus:{rate:.93,pitch:.95},
          aion:{rate:1.00,pitch:1.08}
        }[String(arch).toLowerCase()];
        if (ST) return { voice: baseVoice, rate: ST.rate, pitch: ST.pitch };
      }
    }
  }catch(e){}
  // fallback regex (v32)
  const st = voiceStyleFor(text);
  return { voice: baseVoice, rate: st.rate, pitch: st.pitch };
}
</script>

<!-- KOBLLUX :: TTS v32.2 — Patch Correto (clique + dock + limpeza de texto) -->
<script id="KOB_TTS_V32_2">
(()=>{

  if(window.__KOB_TTS_V32_2_ACTIVE) return;
  window.__KOB_TTS_V32_2_ACTIVE = true;

  if(!('speechSynthesis' in window)){
    console.warn('SpeechSynthesis não suportado neste navegador.');
    return;
  }

  /* ========= ESTADO GLOBAL ========= */
  window.__tts_on = false;
  let __tts_voice = null;
  let __tts_utterance = null;

  function $(sel, root=document){ return root.querySelector(sel); }

  function getStatusEl(){
    return document.getElementById('tts-status');
  }

  function setStatus(msg){
    const el = getStatusEl();
    if(el) el.textContent = msg || '';
  }

  /* ========= VOZ ========= */
  function pickPTBRVoice(){
    const voices = speechSynthesis.getVoices();
    const cand =
      voices.find(v => /pt[-_]BR/i.test(v.lang)) ||
      voices.find(v => /pt\b/i.test(v.lang));
    return cand || voices[0] || null;
  }

  function ensureVoice(){
    if(!__tts_voice){
      __tts_voice = pickPTBRVoice();
    }
  }

  /* ========= LIMPEZA DO TEXTO ========= */
  function cleanText(raw){
    if(!raw) return '';
    let text = String(raw);

    // Remove rótulos e lixinhos óbvios
    text = text.replace(/Copiar/g, ' ');

    // Quebras de linha, \n, etc → espaço
    text = text.replace(/\\n|[\r\n]+/g, ' ');

    // Remove barras invertidas sobrando
    text = text.replace(/\\+/g, '');

    // Normaliza barras normais (evita "barra barra barra")
    text = text.replace(/[\/]{2,}/g, '/');

    // Espaços múltiplos → um espaço
    text = text.replace(/\s{2,}/g, ' ');

    // Trim final
    text = text.trim();

    // Se for muito curtinho ou só símbolo, não fala
    if(text.length <= 3) return '';

    return text;
  }

  /* ========= FALAR / PARAR ========= */
  function speakText(text){
    const cleaned = cleanText(text);
    if(!cleaned) return;

    if(!window.__tts_on){
      window.toast && toast('Ative a Voz (TTS)');
      return;
    }

    ensureVoice();
    speechSynthesis.cancel();
    setStatus('Lendo...');

    const u = new SpeechSynthesisUtterance(cleaned);
    __tts_utterance = u;

    if(__tts_voice) u.voice = __tts_voice;
    u.lang = (__tts_voice && __tts_voice.lang) || 'pt-BR';
    u.rate = 1.12;
    u.pitch = 0.78;
    u.volume = 1.0;

    u.onstart = () => setStatus('Lendo...');
    u.onend   = () => setStatus('Pronto');
    u.onerror = () => setStatus('Erro na voz');

    speechSynthesis.speak(u);
  }

  function stopTTS(){
    speechSynthesis.cancel();
    __tts_utterance = null;
    setStatus('Parado');
  }

  function getSelectedText(){
    return (window.getSelection && String(window.getSelection())) || '';
  }

  function setTTS(on){
    window.__tts_on = !!on;
    const btnFab = document.getElementById('btn-tts');
    if(btnFab){
      btnFab.textContent = 'Voz: ' + (window.__tts_on ? 'On' : 'Off');
    }
    const dockBtn = document.querySelector('[data-tts-btn="toggle"]');
    if(dockBtn){
      dockBtn.setAttribute('aria-pressed', window.__tts_on ? 'true' : 'false');
    }
    setStatus(window.__tts_on ? 'TTS ligado' : 'TTS desligado');
    window.toast && toast(window.__tts_on ? 'Voz ativada' : 'Voz desativada');
  }

  /* ========= DOCK LATERAL (se ainda não existir) ========= */
  function ensureTTSDock(){
    if(document.querySelector('.kob-tts-dock')) return;

    const dock = document.createElement('div');
    dock.className = 'kob-tts-dock';
    dock.innerHTML = `
      <button type="button" data-tts-btn="toggle" title="TTS On/Off" aria-pressed="false">◎</button>
      <button type="button" data-tts-btn="sel"    title="Ler seleção">▷</button>
      <button type="button" data-tts-btn="stop"   title="Parar voz">■</button>
      <span id="tts-status"></span>
    `;
    document.body.appendChild(dock);

    // status inicial
    setStatus('TTS desligado');

    // drag simples
    let dragging = false;
    let startX = 0, startY = 0;
    let startLeft = 0, startBottom = 0;

    dock.addEventListener('pointerdown', (ev)=>{
      if(!(ev.target instanceof HTMLElement)) return;
      // só arrasta se clicar na área vazia do dock (não nos botões)
      if(ev.target.closest('button')) return;

      dragging = true;
      dock.classList.add('is-drag');
      startX = ev.clientX;
      startY = ev.clientY;
      const cs = getComputedStyle(dock);
      startLeft = parseFloat(cs.left || '8');
      startBottom = parseFloat(cs.bottom || '240');
      dock.setPointerCapture(ev.pointerId);
    });

    dock.addEventListener('pointermove', (ev)=>{
      if(!dragging) return;
      const dx = ev.clientX - startX;
      const dy = ev.clientY - startY;
      const left = startLeft + dx;
      const bottom = startBottom - dy;
      dock.style.left = `${left}px`;
      dock.style.bottom = `${bottom}px`;
    });

    dock.addEventListener('pointerup', (ev)=>{
      if(!dragging) return;
      dragging = false;
      dock.classList.remove('is-drag');
      dock.releasePointerCapture(ev.pointerId);
    });
  }

  /* ========= LISTENERS GERAIS ========= */

  // Integra com botões existentes (FAB, MasterBlock, Dock)
  document.addEventListener('click',(e)=>{
    const t = e.target;
    if(!(t instanceof HTMLElement)) return;

    // 1) Botões dedicados (IDs existentes + dock)
    const isFabToggle = t.id === 'btn-tts';
    const isFabSel    = t.id === 'btn-tts-sel';
    const isFabStop   = t.id === 'btn-tts-stop';

    const dockRole = t.dataset.ttsBtn;

    if(isFabToggle || dockRole === 'toggle'){
      setTTS(!window.__tts_on);
      return;
    }
    if(isFabSel || dockRole === 'sel'){
      const sel = getSelectedText();
      if(sel) speakText(sel);
      else window.toast && toast('Selecione um trecho primeiro');
      return;
    }
    if(isFabStop || dockRole === 'stop'){
      stopTTS();
      return;
    }

    // 2) Se TTS desligado, não faz nada no resto
    if(!window.__tts_on) return;

    // 3) Clique em bloco de texto → ler
    const block = t.closest('p, li, blockquote, .coach, .callout, .equation, pre, td, th');
    if(!block) return;

    // Ignora cliques em zonas de UI
    if(t.closest('button,a,.emoji-btn,.chip,.btn,#fab,.menu,#ttsDock,.kob-tts-dock')) return;

    // NÃO ler código nem fórmulas (senão soletra tudo)
    if(block.matches('pre, .equation')) return;

    let text = block.innerText || '';
    speakText(text);
  });

  // Voicelist
  if('speechSynthesis' in window){
    speechSynthesis.onvoiceschanged = ()=>{
      if(!__tts_voice) __tts_voice = pickPTBRVoice();
    };
  }

  // Quando DOM carregar: garantir Dock
  window.addEventListener('DOMContentLoaded', ()=>{
    try{
      ensureTTSDock();
      // Ajusta label inicial do botão principal (se existir)
      const b = document.getElementById('btn-tts');
      if(b){
        b.textContent = 'Voz: ' + (window.__tts_on ? 'On' : 'Off');
      }
      setStatus('TTS desligado');
    }catch(err){
      console.error('Erro ao inicializar TTS dock', err);
    }
  });

  // Expor API global opcional
  window.__tts = {
    set: setTTS,
    speak: speakText,
    stop: stopTTS,
    status: setStatus
  };

})();
</script>


<!-- BIG_LOCK_RESET_v1 — limpa locks e força preferências de base -->
<script id="BIG_LOCK_RESET_v1">
(()=>{
  try{
    const K='kob_tts_prefs_v32';
    const p = Object.assign({preferMale:false,userLockedBase:false,voiceName:''}, JSON.parse(localStorage.getItem(K)||'{}'));
    p.preferMale=false; p.userLockedBase=false; p.voiceName='';
    localStorage.setItem(K, JSON.stringify(p));
  }catch{}
  // opcional: expõe um atalho pro console
  window.__kob_reset_tts_prefs = ()=>{
    try{
      const K='kob_tts_prefs_v32';
      const p = {preferMale:false,userLockedBase:false,voiceName:''};
      localStorage.setItem(K, JSON.stringify(p));
      return p;
    }catch(e){ return e&&e.message; }
  };
})();
</script>




<!-- KOBLLUX · Vozes Arquétipas — Patch Inline (UPDATED) -->
<script id="KOBLLUX_VOICES_INTEGRATION">
(()=>{
  const ARCHETYPES = [
    { id:'atlas',   name:'Atlas',   tone:'Estratégico, metódico',        modulation:'Grave, ritmo calculado, dicção nítida.',        voice:'Reed',    rate:1.0,  pitch:0.93 },
    { id:'nova',    name:'Nova',    tone:'Vibrante, entusiasmado',       modulation:'Agudo, entusiasmado, ligeiramente rápido.',      voice:'Luciana', rate:1.063, pitch:1.34 },
    { id:'vitalis', name:'Vitalis', tone:'Energético, urgente',          modulation:'Rápido, intenso, motivacional.',                  voice:'Rocko',   rate:0.96, pitch:1.42 },
    { id:'pulse',   name:'Pulse',   tone:'Emocional, melódico',          modulation:'Fluido, tom médio/suave.',                       voice:'Reed',    rate:1.0, pitch:1.14 },
    { id:'artemis', name:'Artemis', tone:'Aventureiro, expansivo',       modulation:'Curioso, exploratório.',                         voice:'es_f',    rate:1.00, pitch:1.23 },
    { id:'serena',  name:'Serena',  tone:'Calmo, acolhedor',             modulation:'Suave, terapêutico, com pausas.',                voice:'Joana',   rate:0.92, pitch:0.90 },
    { id:'kaos',    name:'Kaos',    tone:'Desafiador, imprevisível',     modulation:'Intenso, ritmo entrecortado.',                   voice:'Rocko',   rate:1.09, pitch:1.28 },
    { id:'genus',   name:'Genus',   tone:'Prático, detalhista',          modulation:'Tom firme, foco na dicção.',                     voice:'Reed',    rate:0.98, pitch:1.20 },
    { id:'lumine',  name:'Lumine',  tone:'Alegre, brincalhão',           modulation:'Agudo, vibrante.',                               voice:'Flo',     rate:1.030, pitch:1.55 },
    { id:'solus',   name:'Solus',   tone:'Sábio, introspectivo',         modulation:'Grave, lento, eco sutil.',                       voice:'es_m',    rate:0.88, pitch:0.87 },
    { id:'rhea',    name:'Rhea',    tone:'Profundo, conectivo',          modulation:'Calmo, eco sutil.',                              voice:'Joana',   rate:1.02, pitch:0.59 },
    { id:'aion',    name:'Aion',    tone:'Futurista, metódico',          modulation:'Tom constante, progressivo.',                    voice:'Monica',  rate:0.98, pitch:1.00 },

    { id:'kobllux', name:'KOBLLUX', tone:'Núcleo do sistema, oracular',
      modulation:'Grave-médio, presença de comando, ritmo estável.',     voice:'es_m',  rate:0.98, pitch:0.48 },

    { id:'uno',     name:'Uno',     tone:'Essência, origem, foco',
      modulation:'Tom centrado, poucas variações, pausas marcadas.',     voice:'Grandma',    rate:0.90, pitch:0.93 },

    { id:'dual',    name:'Dual',    tone:'Espelho, contraste, jogo',
      modulation:'Alterna leve entre grave/agudo, ritmo pulsante.',      voice:'pt_m',    rate:1.02, pitch:1.02 },

    { id:'trinity', name:'Trinity', tone:'Síntese, tríade viva',
      modulation:'Voz estável com micro variações rítmicas em 3 tempos.', voice:'Sandy', rate:1.04, pitch:1.04 },

    { id:'infodose',name:'Infodose',tone:'Didático, carismático, dopamínico',
      modulation:'Tom amigável, ritmo de recompensa → curiosidade.',      voice:'Luciana', rate:1.06, pitch:0.96 },

    { id:'kodux',   name:'KODUX',   tone:'Criador do pulso, metaconsciência',
      modulation:'Grave, confiante, pausas longas, intenção forte.',      voice:'Reed pt-BR',  rate:0.86, pitch:0.68 },

    { id:'bllue',   name:'Bllue',   tone:'Emocional, sensorial, intuitivo',
      modulation:'Suave, quase sussurrado, ritmo ondulante.',            voice:'Joana',   rate:0.94, pitch:1.42 },

    { id:'minuz',   name:'Minuz',   tone:'Minimalista, direto, hacker',
      modulation:'Rápido, cortes secos, foco em termos técnicos.',       voice:'Reed',    rate:1.05, pitch:0.90 },

    { id:'hanah', name:'HANAH', tone:'Estético, simbólico, futurista',
      modulation:'Tom limpo, levemente ecoado, cadência ritualística.',  voice:'Monica',  rate:1.00, pitch:1.08 },

  { id:'metalux', name:'MetaLux', tone:'Estético, simbólico, futurista',
      modulation:'Tom limpo, levemente ecoado, cadência ritualística.',  voice:'Grandma',  rate:0.80, pitch:1.68 }

  ];

  window.KOBLLUX_VOICES = ARCHETYPES.reduce((acc,a)=>{
    acc[a.name.toLowerCase()] = a;
    return acc;
  },{});

  const origSpeak = window.speechSynthesis.speak.bind(window.speechSynthesis);
  window.speechSynthesis.speak = (u)=>{
    const text = (u.text||'').toLowerCase();
    const found = ARCHETYPES.find(a=> text.includes(a.name.toLowerCase()));
    if(found){
      const voices = speechSynthesis.getVoices();
      const match = voices.find(v=> v && v.name && v.name.includes(found.voice));
      if(match) u.voice = match;
      u.pitch = found.pitch;
      u.rate  = found.rate;
      console.log('🎙️ KOBLLUX Voice →', found.name, '→', found.voice, `(rate=${found.rate}, pitch=${found.pitch})`);
    }
    origSpeak(u);
  };

  console.log('⚡ KOBLLUX Voices Integradas —', ARCHETYPES.length, 'perfis ativos');

  // 🔔 avisa pro painel que as vozes estão prontas
  window.dispatchEvent(new Event('KOBLLUX_VOICES_READY'));

})();
</script>

<script id="KOB_VOICE_THEME_PATCH_V3">
(()=>{

  if (!('speechSynthesis' in window)) return;

  const root = document.documentElement;
  const body = document.body;
  const metaTheme = document.querySelector('meta[name="theme-color"]') || null;

  // Salva o tema neutro atual (INFODOXY) pra poder voltar depois
  const BASE = {};
  const VARS = ['--grad-a','--grad-b','--bg','--panel','--ink','--muted'];
  const cs = getComputedStyle(root);
  VARS.forEach(v=>{
    BASE[v] = cs.getPropertyValue(v) || '';
  });

  // Mapa de cores por arquétipo (fallback).
  // Se você já tiver um window.KOB_VOICE_THEME em outro lugar,
  // ele é mesclado por cima disso aqui.
  const DEFAULT_THEME = {
    neutral: {
      gradA: BASE['--grad-a'],
      gradB: BASE['--grad-b'],
      bg:    BASE['--bg'],
      panel: BASE['--panel'],
      ink:   BASE['--ink'],
      muted: BASE['--muted'],
      meta:  '#070b14'
    },

    atlas:   { gradA:'#00c4ff', gradB:'#0066ff', bg:'#050814', panel:'#0b1020', ink:'#eaf6ff', muted:'#8aa4c8', meta:'#04101f' },
    nova:    { gradA:'#ff7ad9', gradB:'#ffb347', bg:'#140512', panel:'#20091f', ink:'#ffeefc', muted:'#ffb7e4', meta:'#2a0723' },
    vitalis: { gradA:'#00ff95', gradB:'#00ffd0', bg:'#04140e', panel:'#071e17', ink:'#eafff7', muted:'#8fdac2', meta:'#012018' },
    pulse:   { gradA:'#ff5fa7', gradB:'#5f8bff', bg:'#120517', panel:'#1b0a22', ink:'#ffeafd', muted:'#c79ddc', meta:'#24082a' },
    serena:  { gradA:'#7bc7ff', gradB:'#7bffe0', bg:'#03111a', panel:'#071823', ink:'#eaf6ff', muted:'#99bfd7', meta:'#031520' },
    kaos:    { gradA:'#ff4b81', gradB:'#ffdd55', bg:'#18040a', panel:'#250811', ink:'#ffeef4', muted:'#ffb3c9', meta:'#24030b' },
    genus:   { gradA:'#9b8fff', gradB:'#5fffe3', bg:'#070718', panel:'#0c0d22', ink:'#eef0ff', muted:'#a4a8dd', meta:'#08081f' },
    lumine:  { gradA:'#ffe66b', gradB:'#ff9bff', bg:'#170a06', panel:'#25120e', ink:'#fff7e3', muted:'#f3cfa2', meta:'#261308' },
    solus:   { gradA:'#6b8cff', gradB:'#341f5f', bg:'#050715', panel:'#090b1f', ink:'#e3e8ff', muted:'#9ea4d6', meta:'#050716' },
    rhea:    { gradA:'#3cffd2', gradB:'#3c8bff', bg:'#031411', panel:'#071d19', ink:'#eafffb', muted:'#8cd8c8', meta:'#031914' },
    aion:    { gradA:'#9c7bff', gradB:'#4fd5ff', bg:'#060414', panel:'#0c0920', ink:'#f0e9ff', muted:'#b19de4', meta:'#07051a' },

    kobllux: { gradA:'#00ffd0', gradB:'#00b3ff', bg:'#020812', panel:'#050d18', ink:'#eafcff', muted:'#8ac7dd', meta:'#010710' },
    uno:     { gradA:'#ffffff', gradB:'#8ee7ff', bg:'#05070b', panel:'#090b11', ink:'#f5f8ff', muted:'#aeb4c8', meta:'#05070b' },
    dual:    { gradA:'#ff7ab3', gradB:'#7af0ff', bg:'#0b0510', panel:'#13081c', ink:'#ffeefe', muted:'#c49ccf', meta:'#0c0714' },
    trinity: { gradA:'#7affd1', gradB:'#ffef7a', bg:'#060b05', panel:'#0b1409', ink:'#f7ffef', muted:'#b7d7a9', meta:'#050c05' },

    infodose:{ gradA:'#00d8d8', gradB:'#d800d8', bg:'#050813', panel:'#090f1e', ink:'#f2f5ff', muted:'#a1a8c8', meta:'#060818' },
    kodux:   { gradA:'#00f5ff', gradB:'#0078ff', bg:'#02060f', panel:'#050a16', ink:'#e5f5ff', muted:'#8bb5d6', meta:'#020610' },
    bllue:   { gradA:'#6be1ff', gradB:'#3c6bff', bg:'#020911', panel:'#04121d', ink:'#e7f6ff', muted:'#8fbad3', meta:'#020b13' },
    minuz:   { gradA:'#b7b7b7', gradB:'#4b4b4b', bg:'#050505', panel:'#101010', ink:'#f3f3f3', muted:'#a5a5a5', meta:'#050505' },
    hanah:   { gradA:'#ffb3f8', gradB:'#70d7ff', bg:'#130514', panel:'#1c0b1e', ink:'#ffeefe', muted:'#c9a4d8', meta:'#160819' },
    metalux: { gradA:'#f5ff8a', gradB:'#8af5ff', bg:'#080b02', panel:'#101507', ink:'#f9ffe6', muted:'#c6d39b', meta:'#090d03' },

    // você pode usar esses dois via JS manualmente se quiser:
    cooplux: { gradA:'#ff9b6b', gradB:'#ffde6b', bg:'#120606', panel:'#1d0b0a', ink:'#fff4ea', muted:'#e5b7a1', meta:'#170807' },
    fitlux:  { gradA:'#7cffaf', gradB:'#7cbcff', bg:'#04140a', panel:'#071c11', ink:'#e9fff2', muted:'#9fd0aa', meta:'#04150c' }
  };

  const THEMES = Object.assign({}, DEFAULT_THEME, (window.KOB_VOICE_THEME || {}));

  function setVar(name, value){
    if (value != null && value !== '') {
      root.style.setProperty(name, value);
    }
  }

  function applyTheme(id){
    const key = (id && String(id).toLowerCase()) || 'neutral';
    const cfg = THEMES[key] || THEMES.neutral;
    setVar('--grad-a', cfg.gradA);
    setVar('--grad-b', cfg.gradB);
    setVar('--bg',     cfg.bg);
    setVar('--panel',  cfg.panel);
    setVar('--ink',    cfg.ink);
    setVar('--muted',  cfg.muted);
    if (metaTheme && cfg.meta) metaTheme.setAttribute('content', cfg.meta);

    if (key === 'neutral'){
      body.removeAttribute('data-voice-arch');
    } else {
      body.setAttribute('data-voice-arch', key);
    }
  }

  // Exposto pra você usar no console ou em outros patches
  window.KOB_APPLY_VOICE_THEME = applyTheme;

  // Detecta arquétipo com base no texto + mapa de vozes atual
  function detectArchFromUtterance(u){
    const t = (u && u.text || '').toLowerCase();
    if (!t) return null;

    // se o bloco de vozes já estiver carregado, usa os nomes declarados lá
    if (window.KOBLLUX_VOICES){
      for (const k in window.KOBLLUX_VOICES){
        if (!Object.prototype.hasOwnProperty.call(window.KOBLLUX_VOICES,k)) continue;
        const arch = window.KOBLLUX_VOICES[k];
        const name = String(arch.name || k).toLowerCase();
        // procura "[Atlas", "Atlas]" ou o nome puro
        if (t.includes('['+name) || t.includes(name+']') || t.includes(name+' —') || t.includes('## '+name) || t.includes(name)){
          return (arch.id || name || k).toLowerCase();
        }
      }
    }

    // fallback: tenta pelas chaves do mapa de tema
    for (const k in THEMES){
      if (k === 'neutral') continue;
      if (t.includes(k.toLowerCase())) return k.toLowerCase();
    }

    return null;
  }

  // ==== override do speak, em cima do que JÁ existe ====
  const prevSpeak = window.speechSynthesis.speak.bind(window.speechSynthesis);
  const prevCancel = window.speechSynthesis.cancel.bind(window.speechSynthesis);

  window.speechSynthesis.speak = function(u){
    try{
      const archId = detectArchFromUtterance(u);
      if (archId){
        applyTheme(archId);
      } else {
        // se o texto não tem arquétipo explícito, mantém a última cor
        // (se quiser neutro por padrão entre blocos, troca pra applyTheme(null); aqui)
      }
    }catch(e){
      console.warn('[KOB_VOICE_THEME_PATCH] erro ao detectar arquétipo', e);
    }
    return prevSpeak(u);
  };

  window.speechSynthesis.cancel = function(){
    // quando parar tudo → volta pro neutro
    try{ applyTheme(null); }catch{}
    return prevCancel();
  };

  // inicia neutro garantindo que o snapshot do tema base prevaleça
  applyTheme(null);

})();
</script>

<!-- KOBLLUX · PATCH de Tema de Voz (cor por arquétipo) -->
<script id="KOBLLUX_VOICE_THEME_PATCH">
(()=>{
  if (window.__KOBLLUX_VOICE_THEME_PATCH__) return;
  window.__KOBLLUX_VOICE_THEME_PATCH__ = true;

  const COLOR_MAP = {
    kobllux: {
      primary:'#00d8d8', secondary:'#d800d8', accent:'#39FFB6',
      bg_soft:'rgba(0,216,216,0.08)',
      glow:'0 0 18px rgba(0,216,216,0.55)'
    },
    cooplux:{
      primary:'#39FFB6', secondary:'#00d8d8', accent:'#ffffff',
      bg_soft:'rgba(57,255,182,0.10)',
      glow:'0 0 16px rgba(57,255,182,0.60)'
    },
    fitlux:{
      primary:'#FFC857', secondary:'#FFE39A', accent:'#22252f',
      bg_soft:'rgba(255,200,87,0.12)',
      glow:'0 0 16px rgba(255,200,87,0.70)'
    },
    atlas:{
      primary:'#6CCFF6', secondary:'#1B4965', accent:'#CAE9FF',
      bg_soft:'rgba(108,207,246,0.10)',
      glow:'0 0 14px rgba(108,207,246,0.55)'
    },
    nova:{
      primary:'#FF6FB5', secondary:'#FFD6E8', accent:'#FFE066',
      bg_soft:'rgba(255,111,181,0.12)',
      glow:'0 0 16px rgba(255,111,181,0.65)'
    },
    vitalis:{
      primary:'#00F5A0', secondary:'#00D9F5', accent:'#0b1720',
      bg_soft:'rgba(0,245,160,0.10)',
      glow:'0 0 18px rgba(0,245,160,0.65)'
    },
    pulse:{
      primary:'#A259FF', secondary:'#2D1B69', accent:'#F1E4FF',
      bg_soft:'rgba(162,89,255,0.12)',
      glow:'0 0 18px rgba(162,89,255,0.70)'
    },
    serena:{
      primary:'#7AD3A8', secondary:'#154734', accent:'#EAFBF3',
      bg_soft:'rgba(122,211,168,0.12)',
      glow:'0 0 16px rgba(122,211,168,0.65)'
    },
    kaos:{
      primary:'#FF5C8A', secondary:'#3D000F', accent:'#FFD6E0',
      bg_soft:'rgba(255,92,138,0.12)',
      glow:'0 0 20px rgba(255,92,138,0.75)'
    },
    genus:{
      primary:'#4EE1A0', secondary:'#193A3A', accent:'#E1FFF2',
      bg_soft:'rgba(78,225,160,0.10)',
      glow:'0 0 16px rgba(78,225,160,0.65)'
    },
    lumine:{
      primary:'#FFE066', secondary:'#FF9F1C', accent:'#2F2F40',
      bg_soft:'rgba(255,224,102,0.16)',
      glow:'0 0 18px rgba(255,224,102,0.75)'
    },
    rhea:{
      primary:'#00B894', secondary:'#055E55', accent:'#D1FFF6',
      bg_soft:'rgba(0,184,148,0.14)',
      glow:'0 0 16px rgba(0,184,148,0.65)'
    },
    solus:{
      primary:'#4B6584', secondary:'#0B1420', accent:'#E3EFFA',
      bg_soft:'rgba(75,101,132,0.16)',
      glow:'0 0 14px rgba(75,101,132,0.65)'
    },
    aion:{
      primary:'#00A8E8', secondary:'#001F54', accent:'#C4F1FF',
      bg_soft:'rgba(0,168,232,0.14)',
      glow:'0 0 16px rgba(0,168,232,0.70)'
    },
    uno:{
      primary:'#FFFFFF', secondary:'#BBBBBB', accent:'#FFFFFF',
      bg_soft:'rgba(255,255,255,0.05)',
      glow:'0 0 16px rgba(255,255,255,0.35)'
    },
    dual:{
      primary:'#FF9F1C', secondary:'#2EC4B6', accent:'#f5f5f5',
      bg_soft:'rgba(255,159,28,0.10)',
      glow:'0 0 14px rgba(255,159,28,0.65)'
    },
    trinity:{
      primary:'#00d8d8', secondary:'#FFE066', accent:'#ffffff',
      bg_soft:'rgba(0,216,216,0.09)',
      glow:'0 0 18px rgba(0,216,216,0.70)'
    },
    infodose:{
      primary:'#39FFB6', secondary:'#FFE066', accent:'#11141c',
      bg_soft:'rgba(57,255,182,0.12)',
      glow:'0 0 18px rgba(57,255,182,0.75)'
    },
    kodux:{
      primary:'#FF6FB5', secondary:'#5B2C6F', accent:'#FDEBFF',
      bg_soft:'rgba(91,44,111,0.18)',
      glow:'0 0 16px rgba(255,111,181,0.70)'
    },
    bllue:{
      primary:'#4A90E2', secondary:'#142850', accent:'#E3F2FF',
      bg_soft:'rgba(74,144,226,0.14)',
      glow:'0 0 16px rgba(74,144,226,0.70)'
    },
    minuz:{
      primary:'#FF3366', secondary:'#111111', accent:'#FFE3ED',
      bg_soft:'rgba(255,51,102,0.16)',
      glow:'0 0 16px rgba(255,51,102,0.75)'
    },
    hanah:{
      primary:'#FFB6C1', secondary:'#3C1F3C', accent:'#FFE9F0',
      bg_soft:'rgba(255,182,193,0.16)',
      glow:'0 0 16px rgba(255,182,193,0.70)'
    },
    metalux:{
      primary:'#B0E0E6', secondary:'#202733', accent:'#F0FBFF',
      bg_soft:'rgba(176,224,230,0.16)',
      glow:'0 0 18px rgba(176,224,230,0.70)'
    }
  };

  const root = document.documentElement;
  const body = document.body;

  function normalizeKey(s){
    return String(s||'').normalize('NFD')
      .replace(/\p{Diacritic}/gu,'')
      .toLowerCase()
      .replace(/[^a-z0-9]/g,'');
  }

  function detectArchKeyFromText(text){
    if(!text) return null;
    const raw = String(text);
    const trimmed = raw.trim();
    const lowAll  = trimmed.toLowerCase();

    // 1) [Nome] no começo do parágrafo
    const m = trimmed.match(/^\[([^\]]+)\]/);
    if(m){
      const namePart = m[1].split('—')[0].split('-')[0].trim();
      const k = normalizeKey(namePart);
      if(COLOR_MAP[k]) return k;
    }

    // 2) procura pelo nome dentro do texto
    for(const key of Object.keys(COLOR_MAP)){
      if(lowAll.includes(key)) return key;
    }

    // 3) fallback: hook externo (já existe no teu TTS)
    try{
      if(window.KOB_TTS_VOICE_STYLE_HOOK){
        const arch = window.KOB_TTS_VOICE_STYLE_HOOK(raw);
        const k = normalizeKey(arch);
        if(COLOR_MAP[k]) return k;
      }
    }catch(e){}

    return null;
  }

  function applyColorTheme(key){
    const cfg = COLOR_MAP[key];
    if(!cfg) return;

    root.style.setProperty('--kob-voice-primary',   cfg.primary  || '#00d8d8');
    root.style.setProperty('--kob-voice-secondary', cfg.secondary|| cfg.primary || '#d800d8');
    root.style.setProperty('--kob-voice-accent',    cfg.accent   || '#ffffff');
    root.style.setProperty('--kob-voice-bg-soft',   cfg.bg_soft  || 'rgba(0,0,0,0.25)');
    root.style.setProperty('--kob-voice-glow',      cfg.glow     || '0 0 0 transparent');

    if(body){
      body.setAttribute('data-voice-arch', key);
    }

    // se quiser integrar com outros painéis
    try{
      window.dispatchEvent(new CustomEvent('KOB_VOICE_COLOR',{
        detail:{ id:key, color:cfg }
      }));
    }catch(e){}
  }

  const prevSpeak = window.speechSynthesis.speak.bind(window.speechSynthesis);

  window.speechSynthesis.speak = function(u){
    try{
      if(u instanceof SpeechSynthesisUtterance){
        const key = detectArchKeyFromText(u.text||'');
        if(key){
          applyColorTheme(key);
          console.log('🎨 KOBLLUX THEME →', key);
        }
      }
    }catch(e){
      console.warn('KOBLLUX_VOICE_THEME_PATCH error:', e);
    }
    return prevSpeak(u);
  };

  console.log('⚡ KOBLLUX_VOICE_THEME_PATCH ativo — cores dinâmicas por arquétipo');

})();
</script>

<!-- KOBLLUX · Soft Transition Override (fade de cores) -->
<script id="KOB_THEME_TRANSITION_SOFT_OVERRIDE">
(()=>{
  if (window.__KOB_THEME_TRANSITION_SOFT_OVERRIDE__) return;
  window.__KOB_THEME_TRANSITION_SOFT_OVERRIDE__ = true;

  const css = `
  :root{
    /* duração padrão da transição de tema (pode ajustar aqui) */
    --kob-voice-theme-duration: 6600ms;
  }

  /* Tudo que costuma mudar de cor quando o tema troca */
  body,
  .nebula,
  .nebula-bg,
  .page,
  .page-inner,
  details.acc,
  .btn,
  #fab,
  .kob-tts-dock,
  .kob-tts-panel.is-dock {
    transition:
      background-color var(--kob-voice-theme-duration) ease-in-out,
      background        var(--kob-voice-theme-duration) ease-in-out,
      box-shadow        var(--kob-voice-theme-duration) ease-in-out,
      border-color      var(--kob-voice-theme-duration) ease-in-out,
      color             var(--kob-voice-theme-duration) ease-in-out;
  }
  `;

  const style = document.createElement('style');
  style.id = 'KOB_THEME_TRANSITION_SOFT_CSS';
  style.textContent = css;
  document.head.appendChild(style);

  console.log('🎨 KOB_THEME_TRANSITION_SOFT_OVERRIDE ativo (fade ~1.1s)');
})();
</script>

<!-- KOBLLUX · Soft Fade Extra para BACKGROUND -->
<script id="KOB_BG_FADE_OVERRIDE">
(()=>{
  if (window.__KOB_BG_FADE_OVERRIDE__) return;
  window.__KOB_BG_FADE_OVERRIDE__ = true;

  const css = `
  :root{
    --kob-voice-theme-duration: 7800ms;
  }

  /* Fade suave pro fundo principal e o glow nebuloso */
  body,
  .nebula{
    transition:
      background-color var(--kob-voice-theme-duration) ease-in-out !important,
      background        var(--kob-voice-theme-duration) ease-in-out !important,
      box-shadow        var(--kob-voice-theme-duration) ease-in-out !important,
      color             var(--kob-voice-theme-duration) ease-in-out !important,
      filter            var(--kob-voice-theme-duration) ease-in-out !important;
  }
  `;

  const style = document.createElement('style');
  style.id = 'KOB_BG_FADE_CSS';
  style.textContent = css;
  document.head.appendChild(style);

  console.log('🎨 KOB_BG_FADE_OVERRIDE ativo (body + .nebula com fade ~1.2s)');
})();
</script>

<!-- KOBLLUX · PATCH Buttons Fade + TTS Dock Soft Shadow -->
<script id="KOB_BUTTON_FADE_AND_TTS_SHADOW_PATCH">
(()=>{
  if (window.__KOB_BUTTON_FADE_AND_TTS_SHADOW_PATCH__) return;
  window.__KOB_BUTTON_FADE_AND_TTS_SHADOW_PATCH__ = true;

  const css = `
  :root{
    /* usa o mesmo timing do tema de voz, ou define aqui se quiser independente */
    --kob-voice-theme-duration: 1100ms;
  }

  /* Fades suaves para botões, chips e afins */
  .btn,
  .chip,
  button,
  #fab,
  .fab,
  .menu button,
  details.acc,
  details.acc summary,
  .kob-tts-dock button,
  .kob-tts-panel.is-dock button{
    transition:
      background-color var(--kob-voice-theme-duration) ease-in-out,
      background        var(--kob-voice-theme-duration) ease-in-out,
      border-color      var(--kob-voice-theme-duration) ease-in-out,
      color             var(--kob-voice-theme-duration) ease-in-out,
      box-shadow        var(--kob-voice-theme-duration) ease-in-out;
  }

  /* Shadow mais discreto pro dock de TTS */
  .kob-tts-dock{
    box-shadow:
      0 6px 14px rgba(0,0,0,.30),
      inset 0 0 0 1px rgba(255,255,255,.04) !important;
  }
  `;

  const style = document.createElement('style');
  style.id = 'KOB_BUTTON_FADE_AND_TTS_SHADOW_CSS';
  style.textContent = css;
  document.head.appendChild(style);

  console.log('🎨 KOB_BUTTON_FADE_AND_TTS_SHADOW_PATCH ativo (fade botões + shadow TTS suave)');
})();
</script>
<script id="RTF_RENDER_INTEGRATION_V1">
(()=>{'use strict';

// — heurística: checa se o conteúdo parece RTF
function looksLikeRTF(text){
  if(!text) return false;
  const t = String(text).slice(0, 250);
  if(/^\s*{\\rtf1/i.test(t)) return true;
  if(/\\rtf1\\ansi/.test(t)) return true;
  const slashCount = (t.match(/\\/g) || []).length;
  if(slashCount > 12 && /\\(fonttbl|colortbl|viewkind|pard|stylesheet)\b/.test(t)) return true;
  return false;
}

// — decoder simples RTF -> texto / Markdown cru
function decodeRTF(raw){
  if(!raw) return '';
  let txt = String(raw);

  // normaliza quebras de linha
  txt = txt.replace(/\r\n?/g, '\n');

  // \par, \pard, \line -> \n
  txt = txt.replace(/\\par[d]?\b/g, '\n')
           .replace(/\\line\b/g, '\n');

  // \'hh (hex) -> char
  txt = txt.replace(/\\'([0-9a-fA-F]{2})/g, (_,hex)=>{
    const code = parseInt(hex,16);
    return Number.isFinite(code) ? String.fromCharCode(code) : '';
  });

  // \uNNNN? -> unicode
  txt = txt.replace(/\\u(-?\d+)\??/g, (_,num)=>{
    let code = parseInt(num,10);
    if(!Number.isFinite(code)) return '';
    if(code < 0) code = 65536 + code; // corrige negativos comuns
    try{ return String.fromCharCode(code); }catch{ return ''; }
  });

  // remove outros comandos RTF (\palavra, \palavraN)
  txt = txt.replace(/\\[a-zA-Z]+-?\d*(?:\s)?/g, '');

  // remove chaves de grupo { }
  txt = txt.replace(/[{}]/g, '');

  // compacta linhas em branco
  txt = txt.replace(/\n{3,}/g, '\n\n');

  return txt.trim();
}

// — wrap do autoBuild (flat)
if(typeof window.autoBuild === 'function'){
  const orig = window.autoBuild;
  window.autoBuild = function(text){
    let t = text;
    // se for RTF, decodifica antes de tudo
    if(looksLikeRTF(t)){
      try{
        const decoded = decodeRTF(t);
        // guarda o MD decodificado como “estado atual”
        window.__current_md = decoded;
        t = decoded;
        window.__current_title = (decoded.match(/^\s*#\s+(.+)$/m)||[])[1] || window.__current_title;
        window.toast && toast('RTF decodificado → MD');
      }catch(e){
        console.warn('[RTF_RENDER] erro ao decodificar RTF', e);
      }
    }
    return orig(t);
  };
}

// — wrap do autoBuildNested (aninhado)
if(typeof window.autoBuildNested === 'function'){
  const origN = window.autoBuildNested;
  window.autoBuildNested = function(text){
    let t = text;
    if(looksLikeRTF(t)){
      try{
        const decoded = decodeRTF(t);
        window.__current_md = decoded;
        t = decoded;
        window.__current_title = (decoded.match(/^\s*#\s+(.+)$/m)||[])[1] || window.__current_title;
        window.toast && toast('RTF decodificado → MD');
      }catch(e){
        console.warn('[RTF_RENDER] erro ao decodificar RTF (nested)', e);
      }
    }
    return origN(t);
  };
}

// — helper global, se você quiser brincar via console: RTF_RENDER.decode(textoRTF)
window.RTF_RENDER = {
  looksLike: looksLikeRTF,
  decode: decodeRTF
};

})();
</script>

<!-- KOBLLUX · ASCII Carousel v1 (marca ::anim ... ::end com ```ascii dentro) -->
<style>
  .ascii-anim{position:relative;display:block;margin:12px 0}
  .ascii-anim .ascii-frame{transition:opacity .25s ease}
  .ascii-anim .anim-ctrl{
    position:absolute;top:-10px;left:50%;transform:translate(-50%,-100%);
    padding:.4rem .7rem;border:1px solid var(--muted,#89a);
    background:rgba(0,0,0,.3);border-radius:999px;backdrop-filter:blur(4px)
  }
</style>
<script id="KOBLLUX_ASCII_ANIM_V1">
(()=>{'use strict';
function initAsciiCarousel(root=document){
  const marks=[...root.querySelectorAll('p')].filter(p=>p.textContent.trim().toLowerCase().startsWith('::anim'));
  for(const mark of marks){
    const cfg=mark.textContent.trim().slice(6).trim();
    const ms=(/(\d{2,5})/.exec(cfg)||[])[1]||1200;
    const frames=[];
    let n=mark.nextSibling;
    while(n && !(n.nodeType===1 && n.matches('p') && n.textContent.trim().toLowerCase()==='::end')){
      if(n.nodeType===1 && (n.matches('figure.ascii-card')||n.matches('pre[class*="language-ascii"],pre.language-text'))){
        frames.push(n);
      }
      n=n.nextSibling;
    }
    if(!frames.length) continue;
    const wrap=document.createElement('div');
    wrap.className='ascii-anim'; wrap.dataset.interval=ms;
    mark.replaceWith(wrap);
    frames.forEach(f=>wrap.appendChild(f));
    if(n && n.textContent.trim().toLowerCase()==='::end') n.remove();
    setupAnim(wrap, +ms);
  }
}
function setupAnim(wrap, ms){
  const frames=[...wrap.children];
  frames.forEach((el,i)=>{ el.style.display=i?'none':'block'; el.classList.add('ascii-frame'); });
  let i=0, playing=true, t=null;
  function step(){ if(!playing) return; frames[i].style.display='none'; i=(i+1)%frames.length; frames[i].style.display='block'; t=setTimeout(step, ms); }
  t=setTimeout(step, ms);
  const ctrl=document.createElement('button'); ctrl.className='anim-ctrl'; ctrl.textContent='⏸︎';
  ctrl.onclick=()=>{ playing=!playing; ctrl.textContent=playing?'⏸︎':'▶︎'; if(playing){ t=setTimeout(step, ms);} else{ clearTimeout(t);} };
  wrap.prepend(ctrl);
}
document.addEventListener('DOMContentLoaded', ()=>initAsciiCarousel(document));
new MutationObserver(m=>m.forEach(x=>x.addedNodes&&x.addedNodes.forEach(n=>n.nodeType===1&&initAsciiCarousel(n))))
  .observe(document.body,{childList:true,subtree:true});
})();
</script>

<script id="RTF_RENDER_INTEGRATION_V1">
(()=>{'use strict';

// ===== Detectores =====
function looksLikeRTF(text){
  if(!text) return false;
  const t = String(text).slice(0, 250);
  if(/^\s*{\\rtf1/i.test(t)) return true;
  if(/\\rtf1\\ansi/.test(t)) return true;
  const slashCount = (t.match(/\\/g) || []).length;
  if(slashCount > 12 && /\\(fonttbl|colortbl|viewkind|pard|stylesheet)\b/.test(t)) return true;
  return false;
}

function looksLikeHTML(text){
  if(!text) return false;
  const t = String(text).slice(0, 400);
  if(/<!DOCTYPE html/i.test(t)) return true;
  if(/<html[\s>]/i.test(t)) return true;
  if(/<body[\s>]/i.test(t)) return true;
  // fallback: muitas tags de abertura
  const tagCount = (t.match(/<\w+/g)||[]).length;
  return tagCount > 5;
}

// ===== RTF → texto =====
function decodeRTF(raw){
  if(!raw) return '';
  let txt = String(raw);

  txt = txt.replace(/\r\n?/g, '\n');
  txt = txt.replace(/\\par[d]?\b/g, '\n')
           .replace(/\\line\b/g, '\n');

  txt = txt.replace(/\\'([0-9a-fA-F]{2})/g, (_,hex)=>{
    const code = parseInt(hex,16);
    return Number.isFinite(code) ? String.fromCharCode(code) : '';
  });

  txt = txt.replace(/\\u(-?\d+)\??/g, (_,num)=>{
    let code = parseInt(num,10);
    if(!Number.isFinite(code)) return '';
    if(code < 0) code = 65536 + code;
    try{ return String.fromCharCode(code); }catch{ return ''; }
  });

  txt = txt.replace(/\\[a-zA-Z]+-?\d*(?:\s)?/g, '');
  txt = txt.replace(/[{}]/g, '');
  txt = txt.replace(/\n{3,}/g, '\n\n');

  return txt.trim();
}

// ===== HTML → texto (estilo 78konvert) =====
function htmlToPlain(mdLike){
  let t = String(mdLike||'');
  // quebras básicas
  t = t.replace(/<br\s*\/?>/gi, '\n')
       .replace(/<\/p>/gi, '\n\n')
       .replace(/<\/div>/gi, '\n')
       .replace(/<\/li>/gi, '\n');

  // listas
  t = t.replace(/<li[^>]*>/gi, '- ');
  // headings → #
  t = t.replace(/<h1[^>]*>([\s\S]*?)<\/h1>/gi, (_m,g)=>'\n# '+g.trim()+'\n')
       .replace(/<h2[^>]*>([\s\S]*?)<\/h2>/gi, (_m,g)=>'\n## '+g.trim()+'\n')
       .replace(/<h3[^>]*>([\s\S]*?)<\/h3>/gi, (_m,g)=>'\n### '+g.trim()+'\n');

  // blockquote
  t = t.replace(/<blockquote[^>]*>([\s\S]*?)<\/blockquote>/gi, (_m,g)=>{
    const inner = g.replace(/<[^>]+>/g,'').trim();
    return inner ? '\n> '+inner+'\n' : '\n';
  });

  // remove qualquer outra tag
  t = t.replace(/<style[\s\S]*?<\/style>/gi, '')
       .replace(/<script[\s\S]*?<\/script>/gi, '')
       .replace(/<[^>]+>/g, '');

  // espaços & entidades simples
  t = t.replace(/&nbsp;/g, ' ')
       .replace(/&amp;/g, '&')
       .replace(/&lt;/g, '<')
       .replace(/&gt;/g, '>')
       .replace(/&quot;/g, '"')
       .replace(/&#39;/g, "'");

  t = t.replace(/[ \t]+\n/g, '\n')
       .replace(/\n{3,}/g, '\n\n');

  return t.trim();
}

// ===== Wraps nos builders =====
function preprocessMaybe(text){
  let t = text;
  if(!t) return t;

  if(looksLikeRTF(t)){
    try{
      const decoded = decodeRTF(t);
      window.__current_md = decoded;
      window.__current_title = (decoded.match(/^\s*#\s+(.+)$/m)||[])[1] || window.__current_title;
      window.toast && toast('RTF decodificado → MD');
      return decoded;
    }catch(e){
      console.warn('[RTF/HTML_RENDER] erro RTF', e);
      return t;
    }
  }

  if(looksLikeHTML(t)){
    try{
      const plain = htmlToPlain(t);
      window.__current_md = plain;
      window.__current_title = (plain.match(/^\s*#\s+(.+)$/m)||[])[1] || window.__current_title;
      window.toast && toast('HTML limpo → texto');
      return plain;
    }catch(e){
      console.warn('[RTF/HTML_RENDER] erro HTML', e);
      return t;
    }
  }

  return t;
}

// autoBuild (flat)
if(typeof window.autoBuild === 'function'){
  const orig = window.autoBuild;
  window.autoBuild = function(text){
    const t = preprocessMaybe(text);
    return orig(t);
  };
}

// autoBuildNested (aninhado)
if(typeof window.autoBuildNested === 'function'){
  const origN = window.autoBuildNested;
  window.autoBuildNested = function(text){
    const t = preprocessMaybe(text);
    return origN(t);
  };
}

// helper global p/ brincar no console
window.RTF_RENDER = {
  looksLikeRTF,
  looksLikeHTML,
  decodeRTF,
  htmlToPlain
};

})();
</script>


<!-- KOBLLUX PATCH :: FAB auto-close on action click / outside click -->
<script id="KOB_PATCH_FAB_AUTOCLOSE">
(function(){
  const fab = document.getElementById('fab');
  const toggle = document.getElementById('fab-toggle');
  if(!fab || !toggle) return;
  // Close when clicking an action
  document.addEventListener('click', (e)=>{
    const a = e.target.closest('[data-action]');
    if (a && fab.classList.contains('open')) fab.classList.remove('open');
  });
  // Close when clicking outside
  document.addEventListener('click', (e)=>{
    const withinFab = e.target.closest('#fab');
    if (!withinFab && fab.classList.contains('open')) fab.classList.remove('open');
  }, true);
})();
</script>


<!-- KOBLLUX PATCH :: Converter (RTF→MD, tabelista, tokens, buttons) -->
<script id="KOB_PATCH_CONVERTER">
function convertSourceToMD(raw){
  if (!raw) return '';
  // RTF → texto básico
  if (/^{\\rtf/i.test(raw)) {
    raw = raw
      .replace(/\\par[d]?/g, '\n')
      .replace(/\\tab/g, '\t')
      .replace(/\\'[0-9a-fA-F]{2}/g, ' ')      // escapes hex → espaço
      .replace(/\\[a-zA-Z]+\d*/g, '')          // comandos \b \i \fs...
      .replace(/[{}]/g, '')                    // remove braces do RTF
      .replace(/\n{2,}/g, '\n\n');
  }
  // normalizações
  let text = raw
    .replace(/[“”]/g,'"').replace(/[‘’]/g,"'")
    .replace(/\r\n?/g, '\n')
    .trim();

  // TABELISTA (pula 1–2; 3 = header; 4 = <auto>; 5+ dados)
  text = text.replace(
    /(?:^|\n)#[^\n]*\n#[^\n]*\n\s*([\w\W]*?)\n\s*<auto>\n([\w\W]*?)(?=\n{2,}|$)/g,
    function(_, headerLine, dataBlock){
      const header = headerLine.split('|').map(s=>s.trim()).filter(Boolean);
      if (!header.length) return _;
      const sep = '|' + header.map(()=> '---').join('|') + '|';
      const rows = dataBlock.split('\n')
        .map(l => l.trim())
        .filter(l => l && !l.startsWith('#'))
        .map(l => {
          const cols = l.split('|').map(s=>s.trim());
          return '| ' + cols.join(' | ') + ' |';
        });
      return '\n| ' + header.join(' | ') + ' |\n' + sep + '\n' + rows.join('\n') + '\n';
    }
  );

  // botões [[btn:acao|Rótulo]] → HTML
  text = text.replace(/\[\[btn:([a-z0-9_-]+)(?:\|([^\]]+))?\]\]/gi,
    function(_,act,label){ return '<button class="btn action" data-action="'+act+'">'+(label||act)+'</button>'; });

  // tokens [voz:] [arch:] saneados (mantidos para o TTS parser)
  text = text.replace(/\[voz:\s*([^\]]+)\s*\]/gi, '[voz:$1]')
             .replace(/\[arch:\s*([^\]]+)\s*\]/gi, '[arch:$1]');

  // fences simples: fecha ``` se contar ímpar
  const fences = (text.match(/```/g)||[]).length;
  if (fences % 2 === 1) text += '\n```';

  return text;
}

// Bind converter button if present
document.addEventListener('click',(e)=>{
  const btn = e.target.closest('#btn-converter');
  if(!btn) return;
  const ta = document.getElementById('srcText');
  if(!ta) return;
  const md = convertSourceToMD(ta.value||'');
  ta.value = md;
  if (window.toast) toast('Convertido (RTF→MD, tabelista, tokens, botões)');
});
</script>

<!-- KOBLLUX PATCH :: FAB fecha logo após clicar em uma ação -->
<script>
(function(){
  const fab = document.getElementById('fab');
  if (!fab) return;

  fab.addEventListener('click', (e)=>{
    const btn = e.target.closest('[data-action]');
    if (!btn) return;

    // deixa a ação rodar normal, e logo em seguida fecha o menu
    setTimeout(()=> {
      fab.classList.remove('open');
    }, 0);
  });
})();
</script>

<script id="FORCE_LUCIANA_ARQ_OVERRIDE_v4">
(()=> {
  if (window.__FORCE_LUCIANA_ARQ_OVERRIDE_V4__) return;
  window.__FORCE_LUCIANA_ARQ_OVERRIDE_V4__ = true;

  if (!('speechSynthesis' in window)) return;
  const synth = window.speechSynthesis;

  // ===== Utils básicos =====
  const PT = v => /^pt/i.test(v.lang || '');
  const ES = v => /^es/i.test(v.lang || '');
  const NORM = s => String(s || '')
    .normalize('NFD').replace(/\p{Diacritic}/gu,'')
    .toLowerCase();

  function getVoicesSafe(){
    try { return synth.getVoices() || []; }
    catch { return []; }
  }

  // ===== Mapa de vozes por arquétipo (pode sobrescrever via window.ARQ_VOICE_MAP) =====
  const VOICE_MAP = Object.assign({
    Atlas:   'pt_m',
    Nova:    'Luciana',
    Vitalis: 'Rocko',
    Pulse:   'es_m',
    Artemis: 'Monica',
    Serena:  'Joana',
    Kaos:    'Rocko',
    Genus:   'pt_m',
    Lumine:  'Monica',
    Solus:   'es_m',
    Rhea:    'Joana',
    Aion:    'Monica'
  }, (window.ARQ_VOICE_MAP || {}));

  // expõe pra você editar no console, se quiser:
  //   setArchetypeVoiceMap({ Atlas:'Monica', Nova:'pt_f' })
  window.ARQ_VOICE_MAP = VOICE_MAP;

  // Heurísticas simples pros nomes típicos (atalho, não trava nada)
  const NAME_F_PT = /(luciana|vitor[ioa]|camila|maria|sofia|joana)/i;
  const NAME_M_PT = /(daniel|reed|ricardo|miguel|thiago|henrique|felipe|jo[aã]o)/i;
  const NAME_F_ES = /(conchita|m[oó]nica|monica|paulina|luz)/i;
  const NAME_M_ES = /(jorge|fred|diego|sebasti[aá]n|sebastian)/i;

  function pickBySpec(spec, vs){
    if (!spec) return null;
    const s = String(spec).trim().toLowerCase();

    // Tokens por idioma (pt_f, es_m, etc)
    if (s === 'pt_f') return vs.find(v => PT(v) && NAME_F_PT.test(v.name || '')) || vs.find(PT) || null;
    if (s === 'pt_m') return vs.find(v => PT(v) && NAME_M_PT.test(v.name || '')) || vs.find(PT) || null;
    if (s === 'es_f') return vs.find(v => ES(v) && NAME_F_ES.test(v.name || '')) || vs.find(ES) || null;
    if (s === 'es_m') return vs.find(v => ES(v) && NAME_M_ES.test(v.name || '')) || vs.find(ES) || null;

    // Idioma genérico
    if (s === 'pt')   return vs.find(PT) || null;
    if (s === 'es')   return vs.find(ES) || null;

    // Nome direto → parcial (ex: "Monica", "Luciana", "Reed")
    const exact = vs.find(v => NORM(v.name) === NORM(spec));
    if (exact) return exact;
    return vs.find(v => NORM(v.name).includes(NORM(spec))) || null;
  }

  // Detecta tag de arquétipo no começo do parágrafo: [Atlas], [Nova], etc
  const ARCH_RE = /^\s*\[\s*([a-zA-Z0-9_]+)\s*\]/;

  function applyArchetypeVoice(u, vs){
    try{
      const m = (u.text || '').match(ARCH_RE);
      if (!m) return false; // sem tag [Atlas] / [Nova] etc

      const rawArch = m[1];
      const archKey = rawArch[0].toUpperCase() + rawArch.slice(1).toLowerCase();

      const spec = VOICE_MAP[archKey];
      if (!spec) return false;

      const v = pickBySpec(spec, vs);
      if (v){
        u.voice = v;
        // NÃO força idioma: só herda, se não tiver nada definido
        if (!u.lang && v.lang) u.lang = v.lang;
        return true;
      }
      return false;
    }catch{
      return false;
    }
  }

  // ===== Fila + override leve do speak (sem Luciana/base forçada) =====
  const NATIVE_SPEAK  = window.__KOB_NATIVE_SPEAK__  || synth.speak.bind(synth);
  const NATIVE_CANCEL = window.__KOB_NATIVE_CANCEL__ || synth.cancel.bind(synth);
  window.__KOB_NATIVE_SPEAK__  = NATIVE_SPEAK;
  window.__KOB_NATIVE_CANCEL__ = NATIVE_CANCEL;

  let VOICES    = getVoicesSafe();
  let ready     = !!VOICES.length;
  const Q       = [];
  let polTimer  = null;
  let tries     = 0;

  function refreshVoices(){
    VOICES = getVoicesSafe();
    if (VOICES.length){
      ready = true;
      drainQueue();
      if (polTimer){ clearInterval(polTimer); polTimer = null; }
    }
  }

  function ensureVoices(){
    if (ready) return;
    if (typeof synth.onvoiceschanged === 'object'){
      synth.onvoiceschanged = refreshVoices;
    }
    if (!polTimer){
      polTimer = setInterval(()=>{
        tries++;
        refreshVoices();
        if (ready || tries > 40){
          clearInterval(polTimer);
          polTimer = null;
        }
      }, 150);
    }
  }

  function wireUtterance(u){
    try{
      if (u.__kob_wired_v4) return;
      u.__kob_wired_v4 = true;

      // Só mexe se tiver tag de arquétipo; se não, deixa o TTS padrão decidir a voz
      applyArchetypeVoice(u, VOICES);
    }catch(e){
      console.warn('FORCE_LUCIANA_ARQ_OVERRIDE_v4 wireUtterance error', e);
    }
  }

  function drainQueue(){
    while(Q.length){
      const u = Q.shift();
      if (u.__kob_spoken_v4) continue;
      wireUtterance(u);
      u.__kob_spoken_v4 = true;
      NATIVE_SPEAK(u);
    }
  }

  synth.speak = function(u){
    if (!(u instanceof SpeechSynthesisUtterance)) return NATIVE_SPEAK(u);

    ensureVoices();
    if (!ready || !VOICES.length){
      Q.push(u);
      return;
    }

    wireUtterance(u);
    return NATIVE_SPEAK(u);
  };

  synth.cancel = function(){
    Q.length = 0;
    return NATIVE_CANCEL();
  };

  // prewarm leve
  refreshVoices();

  // helper opcional pra ajustar mapa via código:
  window.setArchetypeVoiceMap = (m)=> Object.assign(VOICE_MAP, m || {});

})();
</script>

<!-- KOBLLUX · PATCH Gatilhos de Arquétipo (tags + frases) -->
<script id="KOB_TTS_ARCH_GATILHO_PATCH_V1">
(()=>{'use strict';
  if (!('speechSynthesis' in window)) {
    console.warn('KOB_TTS_ARCH_GATILHO_PATCH_V1: SpeechSynthesis não disponível.');
    return;
  }
  if (window.__KOB_TTS_ARCH_GATILHO_PATCH_V1__) return;
  window.__KOB_TTS_ARCH_GATILHO_PATCH_V1__ = true;

  const synth = window.speechSynthesis;
  const prevSpeak = synth.speak.bind(synth); // respeita patches anteriores

  // Mapa de vozes já existente (Atlas, Nova, etc)
  const VOICE_MAP = (window.ARQ_VOICE_MAP || {});
  const ARCH_KEYS = Object.keys(VOICE_MAP);
  if (!ARCH_KEYS.length){
    console.warn('KOB_TTS_ARCH_GATILHO_PATCH_V1: VOICE_MAP vazio, nada a fazer.');
  }

  // 🔑 Gatilhos de frase (você pode editar/expandir depois no console)
  const DEFAULT_TRIGGERS = {
    Atlas: [
      /\bupa[-\s]*atlas\b/i,
      /\bportal\s*\[\s*atlas\s*\]/i
    ],
    Nova: [
      /\bvia\s*\[\s*nova\s*\]/i,
      /\bmente nova\b/i
    ],
    Lumine: [
      /\blumine\b/i,
      /\barch[-\s]*lumine\b/i
    ]
    // adiciona mais se quiser…
  };

  // Mescla default + o que você definir manualmente:
  const TRIGGERS = Object.assign({}, DEFAULT_TRIGGERS, (window.ARQ_TRIGGERS || {}));
  window.ARQ_TRIGGERS = TRIGGERS; // expõe pra você brincar

  // Heurísticas de idioma básicas (pt/es)
  const PT    = v => /^pt\b/i.test(v.lang || '');
  const ES    = v => /^es\b/i.test(v.lang || '');

  const NORM = s => String(s || '')
    .normalize('NFD')
    .replace(/\p{Diacritic}/gu, '')
    .toLowerCase();

  function getVoicesSafe(){
    try { return synth.getVoices() || []; }
    catch { return []; }
  }

  function pickBySpec(spec, vs){
    if (!spec) return null;
    const s = String(spec).trim().toLowerCase();

    // Tokens por idioma (pt_f, es_m, etc)
    const NAME_F_PT = /(luciana|vitor[ioa]|camila|maria|sofia|joana)/i;
    const NAME_M_PT = /(daniel|reed|ricardo|miguel|thiago|henrique|felipe|jo[aã]o)/i;
    const NAME_F_ES = /(conchita|m[oó]nica|monica|paulina|luz)/i;
    const NAME_M_ES = /(jorge|fred|diego|sebasti[aá]n|sebastian)/i;

    if (s === 'pt_f') return vs.find(v => PT(v) && NAME_F_PT.test(v.name || '')) || vs.find(PT) || null;
    if (s === 'pt_m') return vs.find(v => PT(v) && NAME_M_PT.test(v.name || '')) || vs.find(PT) || null;
    if (s === 'es_f') return vs.find(v => ES(v) && NAME_F_ES.test(v.name || '')) || vs.find(ES) || null;
    if (s === 'es_m') return vs.find(v => ES(v) && NAME_M_ES.test(v.name || '')) || vs.find(ES) || null;

    if (s === 'pt')   return vs.find(PT) || null;
    if (s === 'es')   return vs.find(ES) || null;

    const exact = vs.find(v => NORM(v.name) === NORM(spec));
    if (exact) return exact;
    return vs.find(v => NORM(v.name).includes(NORM(spec))) || null;
  }

  // 🎯 Detecta arquétipo a partir de TODAS as formas de tag + frases de gatilho
  function detectArchetypeKey(text){
    if (!text || !ARCH_KEYS.length) return null;
    const raw   = String(text);
    const lower = raw.toLowerCase();

    for (const key of ARCH_KEYS){
      const n = key.toLowerCase();

      // [Atlas], [[Atlas]], (((Atlas))), {Atlas}, <Atlas>
      const bracket = new RegExp(`[\$begin:math:display$\\\\(\\\\{<]+\\\\s*${n}\\\\s*[\\$end:math:display$\\)\\}>]+`);
      if (bracket.test(lower)) return key;

      // Nome no início com : ou traço — ex: "Atlas: ..." ou "Nova — ..."
      const header = new RegExp(`^\\s*${n}\\s*[:\\-–—·>]`);
      if (header.test(lower)) return key;

      // Nome isolado entre espaços com "modo tag" ex: "::Atlas::"
      const middle = new RegExp(`[\\s\\|:>\\-\\[]${n}[\\s\\|<\\-:!,.?]`);
      if (middle.test(lower)) return key;

      // Frases de gatilho custom
      const arr = TRIGGERS[key] || [];
      for (const rx of arr){
        try{
          if (rx.test(raw) || rx.test(lower)) return key;
        }catch(e){}
      }
    }
    return null;
  }

  // Opcional: remover tags de arquétipo do texto falado (pra não ler "[Atlas]" etc)
  function stripArchetypeTags(text, key){
    if (!text || !key) return text;
    const n = key.toLowerCase();

    // remove [Atlas], ((Atlas)), {{Atlas}}, <Atlas>, [[Atlas]] etc
    const genericBrackets = new RegExp(`[\\[\$begin:math:text$\\\\{<]+\\\\s*${n}\\\\s*[\\\\]\\$end:math:text$\\}>]+\\s*`, 'ig');
    let out = text.replace(genericBrackets, '');

    // remove "Atlas: " no começo da linha
    const header = new RegExp(`^\\s*${n}\\s*[:\\-–—·>]\\s*`, 'i');
    out = out.replace(header, '');

    return out.trim() || text;
  }

  synth.speak = function(u){
    try{
      if (u instanceof SpeechSynthesisUtterance && ARCH_KEYS.length){
        let text   = String(u.text || '');
        const arch = detectArchetypeKey(text);

        if (arch){
          const voices = getVoicesSafe();
          const spec   = VOICE_MAP[arch];
          const v      = spec ? pickBySpec(spec, voices) : null;

          if (v){
            u.voice = v;
            if (!u.lang && v.lang) u.lang = v.lang;
            // marca pra debug / painel
            u.__kob_arch = arch;
            // limpa as tags pra não serem lidas
            u.text = stripArchetypeTags(text, arch);
            console.log('🎙️ ARCH_GATILHO', arch, '→', v.name, v.lang);
          }
        }
      }
    }catch(e){
      console.warn('KOB_TTS_ARCH_GATILHO_PATCH_V1 error', e);
    }
    return prevSpeak(u); // deixa LANG_SPEC, THEME etc trabalharem depois
  };

  console.log('⚡ KOB_TTS_ARCH_GATILHO_PATCH_V1 ativo — tags & gatilhos de arquétipo liberados');
})();
</script>

<!-- KOBLLUX · Bloquinho de Vozes + Gatilhos (Ion, Solus, Artemis, Pulse) -->
<script id="KOB_ARQ_BOOT">
  // 📣 Mapa de VOZ por arquétipo
  // Esses valores entram em cima do VOICE_MAP padrão via Object.assign
  window.ARQ_VOICE_MAP = {
    // deixa Atlas/Nova no eixo padrão
    Atlas:   'pt_m',  // PT macho
    Nova:    'pt_f',  // PT feminina (Luciana / Joana / etc)

    // QUATRO QUE VOCÊ FALOU:
    Ion:     'es_m',  // espanhol macho
    Solus:   'es_m',  // espanhol macho
    Artemis: 'es_f',  // espanhol feminino
    Pulse:   'es_m',  // espanhol macho, ritmo

    // Se quiser forçar outros:
    // Lumine: 'pt_f',
    // Kaos:   'pt_m',
    // etc...
  };

  // 🧠 Tabelas de gatilhos de frase por arquétipo
  // Lembrando: isso soma com DEFAULT_TRIGGERS dentro do patch
  window.ARQ_TRIGGERS = {
    Atlas: [
      /\bUPA-ATLAS\b/i,
      /\bPORTAL\s*\[\s*ATLAS\s*\]/i,
      'BASE ATLAS',
      'ATLAS NA BASE'
    ],
    Nova: [
      /\bMENTE NOVA\b/i,
      /\bTRINDADE\s+NOVA\b/i,
      'NOVA ARQUETÍPICA',
      'NOVA EM CENA'
    ],

    Aion: [
      'MODO ION',
      'ION EM CARGA',
      'IONIZAR O CAMPO',
      'ION FLUXO',
      'AI·ON LIGADO' // A I ON 🔥
    ],
    Solus: [
      'EIXO SOLUS',
      'SOLUS CENTRAL',
      'SOLUS NO COMANDO',
      'SOLUS EM ÓRBITA',
      'DECISÃO SOLUS'
    ],
    Artemis: [
      'ALVO ARTEMIS',
      'MIRA ARTEMIS',
      'ARTEMIS EM CAÇA',
      'FOCO ARTEMIS',
      'RITUAL ARTEMIS'
    ],
    Pulse: [
      'PULSO ATIVO',
      'PULSE 3·6·9',
      'RITMO DO PULSE',
      'BPM DO PULSE',
      'PULSE NO BPM'
    ]
  };
</script>

<script>
/* KOBLLUX · PATCH DE VOZ POR NOME
   - Usa o NOME da voz (v.name) para cada arquétipo
   - Mantém fallback pro applyArchetypeVoice original se não achar nada
   - Ajusta o nome Aion (nada de Ion kkk)
*/
(function () {
  if (typeof window === "undefined" || !("speechSynthesis" in window)) {
    return;
  }

  const synth = window.speechSynthesis;

  // 🔊 EDITÁVEL: coloque aqui os nomes das vozes que você TEM no aparelho
  // Dica: use o painel de vozes que você já tem ou os nomes padrão tipo "Luciana", "Mônica", "Conchita", etc.
  const VOICE_NAME_PREFS = {
    Atlas:  ["Luciana", "pt-BR"],
    Nova:   ["Luciana", "pt-BR"],
    Vitalis:["Luciana", "pt-BR"],

    // Esses você queria em espanhol:
    Pulse:  ["Mónica", "Monica", "Conchita", "es"],
    Artemis:["Mónica", "Monica", "Conchita", "es"],
    Solus:  ["Mónica", "Monica", "Conchita", "es"],
    Aion:   ["Mónica", "Monica", "Conchita", "es"],

    Serena: ["Luciana", "pt-BR"],
    Kaos:   ["Luciana", "pt-BR"],
    Genus:  ["Luciana", "pt-BR"],
    Lumine: ["Luciana", "pt-BR"],
    Rhea:   ["Luciana", "pt-BR"],
    Horus:  ["Luciana", "pt-BR"]
  };

  // 🧠 Normaliza o nome (sem acento / caixa)
  function norm(str) {
    return String(str || "")
      .toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "");
  }

  // Procura voz por nome / pedaço do nome / lang
  function pickVoiceByNamePrefs(archetype, voices) {
    const prefs = VOICE_NAME_PREFS[archetype];
    if (!prefs || !prefs.length) return null;

    const vlist = voices || synth.getVoices();
    if (!vlist || !vlist.length) return null;

    const normPrefs = prefs.map(norm);

    // 1) match exato de nome
    for (const p of normPrefs) {
      const exact = vlist.find(v => norm(v.name) === p);
      if (exact) return exact;
    }

    // 2) nome contém o pedaço (ex: "Monica" dentro de "Mônica - es-MX")
    for (const p of normPrefs) {
      const byPart = vlist.find(v => norm(v.name).includes(p));
      if (byPart) return byPart;
    }

    // 3) se algum pref parece código de idioma (ex: "es", "pt-br"), tenta lang
    for (const p of normPrefs) {
      if (p === "es" || p === "es-es" || p === "es-mx" || p === "pt-br" || p === "pt") {
        const byLang = vlist.find(v => norm(v.lang).startsWith(p));
        if (byLang) return byLang;
      }
    }

    return null;
  }

  // Guarda referência do applyArchetypeVoice original, se existir
  const originalApply = window.applyArchetypeVoice || null;

  window.applyArchetypeVoice = function patchedApplyArchetypeVoice(utterance, archetypeName) {
    try {
      const voices = synth.getVoices();
      let arch = archetypeName;

      // Normaliza o nome do arquétipo (Atlas, Nova, Pulse, Solus, Aion...)
      if (arch && typeof arch === "string") {
        arch = arch.trim();
        // Se vier em minúsculo, ajeita a primeira letra
        const low = arch.toLowerCase();
        const mapFix = {
          atlas: "Atlas",
          nova: "Nova",
          vitalis: "Vitalis",
          pulse: "Pulse",
          artemis: "Artemis",
          serena: "Serena",
          kaos: "Kaos",
          genus: "Genus",
          lumine: "Lumine",
          rhea: "Rhea",
          solus: "Solus",
          aion: "Aion",
          horus: "Horus"
        };
        arch = mapFix[low] || arch;
      }

      let chosen = null;

      if (arch && voices && voices.length) {
        chosen = pickVoiceByNamePrefs(arch, voices);
      }

      if (chosen) {
        utterance.voice = chosen;
        // marca no body quem tá falando (pra tema / debug visual)
        try {
          document.body.dataset.voiceArch = norm(arch);
        } catch(e){/* ignora se der erro */ }
        return;
      }

      // Se não achou nada pelas prefs, cai no comportamento antigo (se existir)
      if (typeof originalApply === "function") {
        originalApply(utterance, archetypeName);
      }

    } catch (err) {
      // Falhou o patch? volta pro original pra não quebrar nada
      if (typeof originalApply === "function") {
        try { originalApply(utterance, archetypeName); } catch(e){}
      }
    }
  };

})();
</script>




  <svg style="display:none">
    <symbol id="icon-orb" viewBox="0 0 24 24"><circle cx="12" cy="12" r="7"></circle><circle cx="12" cy="12" r="8"></circle></symbol>
    <symbol id="icon-cards" viewBox="0 0 24 24"><rect x="2" y="2" width="16" height="16" rx="2"></rect><path d="M22 6v14a2 2 0 0 1-2 2H6"></path></symbol>
    <symbol id="icon-gem" viewBox="0 0 24 24"><path d="M6 3h12l4 6-10 12L2 9z"></path></symbol>
    <symbol id="icon-settings" viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></symbol>
    <symbol id="icon-send" viewBox="0 0 24 24"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></symbol>
    <symbol id="icon-copy" viewBox="0 0 24 24"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></symbol>
    <symbol id="icon-trash" viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></symbol>
    <symbol id="icon-voice" viewBox="0 0 24 24"><rect x="9" y="1" width="6" height="12" rx="3"></rect><path d="M5 10a7 7 0 0 0 14 0"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></symbol>
    <symbol id="icon-edit" viewBox="0 0 24 24"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></symbol>
    <symbol id="icon-restore" viewBox="0 0 24 24"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></symbol>
    <symbol id="icon-upload" viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></symbol>
    <symbol id="icon-download" viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></symbol>
    <symbol id="icon-sandbox" viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"></path></symbol>
    <symbol id="icon-pdf" viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></symbol>
    <symbol id="icon-mic" viewBox="0 0 24 24"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></symbol>
    <symbol id="icon-md" viewBox="0 0 24 24"><rect x="3" y="5" width="18" height="14" rx="2" ry="2"></rect><polyline points="7 15 9 13 11 15"></polyline><line x1="9" y1="15" x2="9" y2="9"></line></symbol>
    <symbol id="icon-eye" viewBox="0 0 24 24"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></symbol>
    <symbol id="icon-code" viewBox="0 0 24 24"><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></symbol>
    <symbol id="icon-maximize" viewBox="0 0 24 24"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></symbol>
  </svg>
    
  <div class="sky-layer"><div class="sun-background"></div></div>
  <div id="particles-js"></div>
  <div id="bg-fake-custom"></div> 
  <div id="nv-toast"></div>
  <div id="modeIndicator">CARREGANDO nO.Sºlar...</div>

  <div class="header-orb" id="orbToggle" title="Acessar Cockpit do Usuário"><svg><use href="#icon-orb"></use></svg></div>
  <div id="usernameDisplay"></div>

  <div class="top-bar">
    <div class="top-grp"><button class="btn-icon" id="btnSettings" title="Configurações"><svg><use href="#icon-settings"></use></svg></button></div>
    <div class="top-grp"><button class="btn-icon" id="btnDeck" title="Deck"><svg><use href="#icon-cards"></use></svg></button><button class="btn-icon" id="btnCrystallize" title="Cristalizar"><svg><use href="#icon-gem"></use></svg></button></div>
  </div>

  <div id="chat-container" class="collapsed">
    <div class="msg-block system">Dual.Infodose v7.9 · KOBLLUX VISIO<br>Memória Cristalizada &amp; HTML Matrix<br>KODUX INTEGRATED [ATLAS + V.E.E.B]</div>
  </div>

  <div class="input-dock">
    <div id="filePreview" class="file-preview"><div class="file-info"><span></span></div><div class="file-actions"></div></div>
    <input type="file" id="fileUploadInput" accept="image/*,.pdf,.txt,.json,.js,.css,.html" style="display:none;">
    <div id="field-toggle-handle"><span class="footer-dot"></span>tocar o campo é consentir</div>
    <div class="input-row">
        <button class="btn-icon" id="btnVoice" title="Voz"><svg><use href="#icon-voice"></use></svg></button>
        <button class="btn-icon" id="btnUploadFile" title="Enviar Arquivo"><svg><use href="#icon-upload"></use></svg></button>
        <input type="text" id="userInput" class="glass-input" placeholder="Emitir pulso..." autocomplete="off">
        <button class="btn-icon btn-primary" id="btnSend" title="Enviar"><svg><use href="#icon-send"></use></svg></button>
    </div>
  </div>

  <div id="drawerSettings" class="drawer">
    <div class="drawer-content">
      <div class="drawer-header"><h3>Configuração Neural</h3><button class="btn-icon" onclick="toggleDrawer('drawerSettings')">✕</button></div>
      <div class="drawer-body">
        <div class="form-group"><label>Chave Dual (API Key)</label><input type="password" id="apiKeyInput" class="glass-input" style="border-radius:8px;width:100%" placeholder="sk-..."></div>
        <div class="form-group"><label>Dual (Prompt)</label><textarea id="systemRoleInput" class="glass-textarea" placeholder="Você é o Oráculo..."></textarea></div>
        <hr style="border-color:rgba(255,255,255,0.1);margin:15px 0;">
        <div class="form-group"><label>Seu (Style)</label><input type="file" id="cssUploadInput" accept=".css,text/plain" style="margin-bottom:5px;font-size:0.8rem;"><textarea id="customCssInput" class="glass-textarea" placeholder="Cole CSS aqui..."></textarea><button class="btn-block" id="btnClearCss" style="margin-top:5px;color:var(--danger)">Remover CSS</button></div>
        <button class="btn-block active" id="btnSaveConfig" style="margin-top:15px;">Salvar Tudo</button>
        <button class="btn-block" style="margin-top:10px;color:var(--danger);border-color:var(--danger)" onclick="if(confirm('Resetar tudo?')){localStorage.clear();location.reload();}">Factory Reset</button>
      </div>
    </div>
  </div>

  <div id="drawerProfile" class="drawer">
    <div class="drawer-content">
      <div class="drawer-header"><h3><svg style="width:20px;height:20px;margin-right:8px;stroke:var(--secondary)"><use href="#icon-orb"></use></svg> Cockpit Solar</h3><button class="btn-icon" onclick="toggleDrawer('drawerProfile')">✕</button></div>
      <div class="drawer-body">
        <div class="cockpit-item" style="text-align:center;margin-bottom:15px;"><div class="cockpit-label">Ciclo Solar</div><div id="statusSolarMode" style="font-size:1.2rem;font-weight:bold;margin:5px 0;">AUTO</div><div class="control-row"><button class="btn-block" id="btnCycleSolar">Manual ☀️/🌙</button><button class="btn-block" id="btnAutoSolar">Auto 🕒</button></div></div>
        <div class="cockpit-grid">
            <div class="cockpit-item"><div class="cockpit-label">Identificação</div><input type="text" id="inputUserId" class="cockpit-input" placeholder="Anônimo"></div>
            <div class="cockpit-item"><div class="cockpit-label">Modelo IA</div><input type="text" id="inputModel" class="cockpit-input" placeholder="google/gemini-2.0-flash-exp"></div>
            <div class="cockpit-item"><div class="cockpit-label">Background</div><div style="display:flex;justify-content:space-between;align-items:center;"><span id="bgStatusText" style="font-size:0.8rem;color:var(--text-muted)">Nenhum</span><label class="btn-icon" style="width:30px;height:30px;border-radius:5px;"><input type="file" id="bgUploadInput" accept="image/*" style="display:none"><svg><use href="#icon-cards"></use></svg></label></div></div>
        </div>
      </div>
    </div>
  </div>
  
  <div id="drawerDeck" class="drawer">
    <div class="drawer-content">
      <div class="drawer-header"><h3>Memórias Cristalizadas</h3><button class="btn-icon" onclick="toggleDrawer('drawerDeck')">✕</button></div>
      <div class="drawer-body" id="deckList"><div style="text-align:center;color:var(--text-muted);margin-top:20px">O vazio reina aqui.<br>Use o botão 💎 para salvar.</div></div>
    </div>
  </div>

<script>
/* =========================================================
   DUAL.INFODOSE v7.9 — KOBLLUX VISIO & MEMORIA
   - Fix: Cristalização (Deck) funcional e visível
   - New: Visualizador HTML (Preview/Code/Fullscreen/Mobile)
   - Core: Fractal 3-6-9-7 + Ciclos Solares
========================================================= */

const STORAGE = {
    API_KEY: 'di_apiKey',
    MODEL: 'di_modelName',
    SYSTEM_ROLE: 'di_systemRole',
    USER_ID: 'di_userName',
    BG_IMAGE: 'di_bgImage',
    CUSTOM_CSS: 'di_customCss',
    SOLAR_MODE: 'di_solarMode',
    SOLAR_AUTO: 'di_solarAuto',
    INFODOSE_NAME: 'di_infodoseName',
    ASSISTANT_ENABLED: 'di_assistantEnabled',
    TRAINING_ACTIVE: 'di_trainingActive',
    TRAINING_TEXT: 'di_trainingText',
    MESSAGES: 'di_messages'
};

// KODUX ARQUÉTIPOS E FASES
const KODUX = {
    ARQUETIPOS: { "Atlas":{Essencia:"Planejador"}, "Nova":{Essencia:"Inspira"}, "Vitalis":{Essencia:"Momentum"}, "Pulse":{Essencia:"Emocional"}, "Artemis":{Essencia:"Descoberta"}, "Serena":{Essencia:"Cuidado"}, "Kaos":{Essencia:"Transformador"}, "Genus":{Essencia:"Fabricus"}, "Lumine":{Essencia:"Alegria"}, "Solus":{Essencia:"Sabedoria"}, "Rhea":{Essencia:"Vínculo"}, "Aion":{Essencia:"Tempo"} },
    PROJETO: { "I. INTRODUÇÃO":{fase:"KODUX (Δ³)",arquetipos:["Atlas","Nova","Pulse"]}, "II. ATO I":{fase:"BLLUE (Δ⁶)",arquetipos:["Vitalis","Pulse","Genus"]}, "III. ATO II":{fase:"EXPANSÃO (Δ⁹)",arquetipos:["Genus","Nova","Vitalis"]}, "IV. ATO III":{fase:"CONVERGÊNCIA (Δ⁹)",arquetipos:["Genus","Aion","Pulse"]}, "V. EPÍLOGO":{fase:"VERBO ETERNO (Δ⁷)",arquetipos:["Atlas","Aion","Genus"]} }
};


/* ═══════════════════════════════════════════════════════════════
   INTEGRAÇÃO DE CONSTANTES di_* DO LOCALSTORAGE
   ═══════════════════════════════════════════════════════════════ */

function initDIConstants() {
    const di_userName = localStorage.getItem('di_userName') || 'Viajante';
    const di_infodoseName = localStorage.getItem('di_infodoseName') || 'KOBLLUX';
    const di_apiKey = localStorage.getItem('di_apiKey') || '';
    const di_modelName = localStorage.getItem('di_modelName') || 'nvidia/nemotron-3-nano-30b-a3b:free';
    const di_systemRole = localStorage.getItem('di_systemRole') || 'oi Dual';
    const di_solarMode = localStorage.getItem('di_solarMode') || 'night';
    const di_assistantEnabled = localStorage.getItem('di_assistantEnabled') === '1';
    const di_trainingActive = localStorage.getItem('di_trainingActive') === '1';
    const di_trainingText = localStorage.getItem('di_trainingText') || '';
    
    // Atualizar elementos da UI
    const usernameDisplay = document.getElementById('usernameDisplay');
    if (usernameDisplay) {
        usernameDisplay.textContent = di_userName;
    }
    
    const modeIndicator = document.getElementById('modeIndicator');
    if (modeIndicator) {
        modeIndicator.textContent = `${di_infodoseName} · ${di_solarMode.toUpperCase()}`;
    }
    
    // Preencher inputs com valores salvos
    const apiKeyInput = document.getElementById('apiKeyInput');
    if (apiKeyInput) apiKeyInput.value = di_apiKey;
    
    const systemRoleInput = document.getElementById('systemRoleInput');
    if (systemRoleInput) systemRoleInput.value = di_systemRole;
    
    const inputUserId = document.getElementById('inputUserId');
    if (inputUserId) inputUserId.value = di_userName;
    
    const inputModel = document.getElementById('inputModel');
    if (inputModel) inputModel.value = di_modelName;
    
    // Salvar no localStorage se não existir
    if (!localStorage.getItem('di_userName')) localStorage.setItem('di_userName', di_userName);
    if (!localStorage.getItem('di_infodoseName')) localStorage.setItem('di_infodoseName', di_infodoseName);
    if (!localStorage.getItem('di_solarMode')) localStorage.setItem('di_solarMode', di_solarMode);
    
    console.log('[DI_CONSTANTS] Inicializado:', { di_userName, di_infodoseName, di_apiKey: di_apiKey ? '✓' : '✗' });
}

// Chamar ao carregar a página
document.addEventListener('DOMContentLoaded', initDIConstants);

const FOOTER_TEXTS = { closed:{ritual:["tocar o campo é consentir","registro aguarda presença"],tecnico:["latência detectada","aguardando input"]}, open:{sustentado:["campo ativo","consciência expandida"],estavel:["sinal estabilizado","link neural firme"]}, loading:["sincronizando neuro-link...","buscando no éter...","decodificando sinal..."] };

let lastText = null;
function getRandomText(arr){ if(!arr||arr.length===0)return"Processando..."; let t; do{t=arr[Math.floor(Math.random()*arr.length)];}while(t===lastText&&arr.length>1); lastText=t; return t; }

/* ---------------------------------------------------------
   KOBLLUX CORE (3-6-9-7)
   --------------------------------------------------------- */
const KoblluxCore = {
    async sha256Hex(s) { const d = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(s)); return [...new Uint8Array(d)].map(b=>b.toString(16).padStart(2,'0')).join(''); },
    classifyText(s) { const t = (s.match(/[\p{L}\p{N}_-]+/gu)||[]); const endsV = ['ar','er','ir']; const verbs=[],nouns=[],adjs=[]; for (const w0 of t){ const w = w0.toLowerCase(); if(w.endsWith('mente')){adjs.push(w0);continue;} if(endsV.some(e=>w.endsWith(e))){verbs.push(w0);continue;} if(w.endsWith('ção')||w.endsWith('são')||w.endsWith('dade')){nouns.push(w0);continue;} if(/^[A-Z]/.test(w0)){nouns.push(w0);continue;} } return {tokens:t, verbs, nouns, adjs}; },
    mapTrinity(pos) { return { UNO: pos.nouns[0]||'NÚCLEO', DUAL: pos.verbs[0]||'relaciona', TRINITY: pos.adjs[0]||'integrado' }; },
    async process(input) { if(!input)return null; const pos=this.classifyText(input); const tri=this.mapTrinity(pos); const seal=await this.sha256Hex(input+new Date().toISOString()); return { raw:input, pos:pos, trinity:tri, seal:seal.slice(0,16), log:`[KOBLLUX ∆7] UNO:${tri.UNO}|DUAL:${tri.DUAL}|TRI:${tri.TRINITY}::SEAL:${seal.slice(0,8)}` }; }
};

/* ---------------------------------------------------------
   UTILS: DOWNLOAD, PREVIEW, ZIP
   --------------------------------------------------------- */
const DownloadUtils = {
    _getBlock(btn) { return btn.closest('.msg-block'); },
    _getCleanHtml(block) { const clone = block.cloneNode(true); const tools = clone.querySelector('.msg-tools'); if(tools) tools.remove(); return clone.innerHTML; },
    _guessFilename(base, extFallback='txt') { const t = new Date().toISOString().replace(/[:.]/g,'-'); if (!base) return `ai-output-${t}.${extFallback}`; if (/<\s*!doctype|<html|<body|<head/i.test(base)) return `ai-output-${t}.html`; if (/<pre|<code/i.test(base)) return `ai-code-${t}.${extFallback}`; return `ai-output-${t}.${extFallback}`; },
    downloadMessage(btn) { try { const block = this._getBlock(btn); if(!block) return; const content = this._getCleanHtml(block); const isHTML = /<\s*!doctype|<html|<body|<head|<\/div>/i.test(content); const mime = isHTML ? 'text/html' : 'text/plain'; const ext = isHTML ? 'html' : 'txt'; const filename = this._guessFilename(content, ext); const blob = new Blob([content], { type: mime + ';charset=utf-8' }); this.triggerDownload(blob, filename); App.showToast(`Download: ${filename}`); } catch(e){ App.showToast('Erro download', true); } },
    downloadMarkdown(btn) { try { const block = this._getBlock(btn); if(!block) return; const raw = block.dataset.raw || block.innerText || ''; const filename = this._guessFilename(raw, 'md').replace(/\.(html|txt)$/, '.md'); const blob = new Blob([raw], { type: 'text/markdown;charset=utf-8' }); this.triggerDownload(blob, filename); App.showToast(`MD salvo: ${filename}`); } catch(e){ App.showToast('Erro MD', true); } },
    openSandbox(btn) { try { const block = this._getBlock(btn); if(!block) return; const content = this._getCleanHtml(block); let page = content; if(!/<\s*!doctype|<html/i.test(content)) page = `<!doctype html><html lang="pt-BR"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Sandbox</title></head><body>${content}
<script>if('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js');</script></body></html>`; const blob = new Blob([page], { type: 'text/html' }); const url = URL.createObjectURL(blob); window.open(url, '_blank'); App.showToast('Sandbox aberto'); } catch(e){ App.showToast('Erro sandbox', true); } },
    async exportPdf(btn) { try { if(typeof html2pdf === 'undefined') { App.showToast('PDF lib ausente. Use Sandbox.', true); return this.openSandbox(btn); } const block = this._getBlock(btn); if(!block) return; const content = this._getCleanHtml(block); const container = document.createElement('div'); container.style.position = 'fixed'; container.style.left = '-9999px'; container.style.width = '1100px'; container.style.padding = '20px'; container.style.background = '#ffffff'; container.innerHTML = content; document.body.appendChild(container); const filename = this._guessFilename(content, 'pdf').replace(/\.(html|txt)$/, '.pdf'); await html2pdf().from(container).set({ margin: 12, filename: filename, html2canvas: { scale: 2 }, jsPDF: { unit: 'pt', format: 'a4' } }).save(); document.body.removeChild(container); App.showToast(`PDF: ${filename}`); } catch(e){ App.showToast('Erro PDF', true); } },
    triggerDownload(blob, filename) { const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); setTimeout(() => URL.revokeObjectURL(url), 2000); }
};

const Preview = {
    async renderPreview(file) {
        const type = file.type || 'text/plain'; const name = file.name || 'arquivo'; const url = URL.createObjectURL(file);
        if (type === 'text/html' || name.endsWith('.html')) { const text = await file.text(); const blob = new Blob([this.sanitizeHTML(text)], { type: 'text/html' }); return `<div class="preview-html"><iframe src="${URL.createObjectURL(blob)}" sandbox="allow-scripts"></iframe></div>`; }
        if (type.startsWith('image/')) return `<div class="preview-html"><img src="${url}" style="width:100%;height:100%;object-fit:contain;background:#000;"></div>`;
        const text = await file.text(); const ext = name.split('.').pop() || 'txt'; const code = this.escapeHTML(text.slice(0, 2000)); setTimeout(() => { hljs.highlightAll(); }, 0); return `<div class="preview-code"><pre><code class="language-${ext}">${code}</code></pre></div>`;
    },
    sanitizeHTML(html) { const div = document.createElement('div'); div.innerHTML = html; div.querySelectorAll('script').forEach(s => s.remove()); return div.innerHTML; },
    escapeHTML(str) { return str.replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s])); },
    
    // VISUALIZADOR HTML (Atualizado)
    createHtmlViewer(htmlCode) {
        const id = 'html-' + Date.now();
        const blob = new Blob([htmlCode], {type: 'text/html'});
        const url = URL.createObjectURL(blob);
        const codeEscaped = this.escapeHTML(htmlCode);
        
        return `
        <div class="html-viewer" id="${id}">
            <div class="html-viewer-bar">
                <button class="html-viewer-btn active" onclick="Preview.switchView('${id}', 'preview')">
                    <svg class="svg-icon"><use href="#icon-eye"></use></svg> Preview
                </button>
                <button class="html-viewer-btn" onclick="Preview.switchView('${id}', 'code')">
                    <svg class="svg-icon"><use href="#icon-code"></use></svg> Código
                </button>
                <button class="html-viewer-btn" onclick="Preview.openFullscreen('${id}', '${url.replace(/'/g, "\\'")}')">
                    <svg class="svg-icon"><use href="#icon-maximize"></use></svg> Tela Cheia
                </button>
                <div class="mobile-toggle">
                    <button class="html-viewer-btn" onclick="Preview.toggleMobile('${id}')">
                        <svg class="svg-icon"><use href="#icon-eye"></use></svg> Mobile
                    </button>
                </div>
            </div>
            <div class="html-viewer-content">
                <iframe src="${url}" sandbox="allow-scripts allow-popups"></iframe>
                <div class="html-viewer-code"><pre><code class="language-html">${codeEscaped}</code></pre></div>
            </div>
        </div>`;
    },

    switchView(id, mode) {
        const container = document.getElementById(id);
        if(!container) return;
        
        if(mode === 'code') {
            container.classList.add('show-code');
        } else {
            container.classList.remove('show-code');
        }
        
        // Atualiza botões ativos
        container.querySelectorAll('.html-viewer-btn').forEach(b => b.classList.remove('active'));
        event.currentTarget.classList.add('active');
    },

    openFullscreen(id, url) {
        const container = document.getElementById(id);
        if(!container) return;
        
        // Modo tela cheia
        container.classList.add('fullscreen');
        container.querySelector('iframe').src = url;
        
        // Botão para sair
        const bar = container.querySelector('.html-viewer-bar');
        const exitBtn = document.createElement('button');
        exitBtn.className = 'html-viewer-btn';
        exitBtn.innerHTML = '<svg class="svg-icon"><use href="#icon-restore"></use></svg> Sair';
        exitBtn.onclick = () => {
            container.classList.remove('fullscreen');
            exitBtn.remove();
        };
        bar.appendChild(exitBtn);
    },

    toggleMobile(id) {
        const container = document.getElementById(id);
        if(!container) return;
        
        container.classList.toggle('mobile');
        
        // Atualiza botão mobile
        const btn = event.currentTarget;
        if(container.classList.contains('mobile')) {
            btn.innerHTML = '<svg class="svg-icon"><use href="#icon-eye"></use></svg> Desktop';
        } else {
            btn.innerHTML = '<svg class="svg-icon"><use href="#icon-eye"></use></svg> Mobile';
        }
    }
};

const ZipGenerator = {
    async generateZip() {
        try {
            const { default: JSZip } = await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');
            const zip = new JSZip();
            const root = zip.folder("KOBLLUX_INTEGRADO");
            root.folder("00_CORE").file("config.json", JSON.stringify(KODUX, null, 2));
            root.folder("00_CORE").file("timestamp.txt", new Date().toISOString());
            root.folder("01_CYCLES_3x3"); root.folder("02_PARTS"); root.folder("03_REDE"); root.folder("04_EXPORT");
            
            const content = await zip.generateAsync({ type: "blob" });
            const md5 = await this.hash(content, 'MD5');
            const sha = await this.hash(content, 'SHA-256');
            const name = `KOBLLUX_${new Date().toISOString().slice(0,10)}.zip`;
            DownloadUtils.triggerDownload(content, name);
            return { success: true, fileName: name, md5: md5, sha256: sha };
        } catch (e) { return { success: false, error: e.message }; }
    },
    async hash(blob, algo) { const b = await blob.arrayBuffer(); const h = await crypto.subtle.digest(algo, b); return Array.from(new Uint8Array(h)).map(x => x.toString(16).padStart(2,'0')).join(''); }
};

const Utils = {
    copy(btn) { const b = btn.closest('.msg-block'); if(!b)return; navigator.clipboard.writeText(b.innerText.replace("content_copy","").trim()); App.showToast("Copiado"); },
    speak(btn) { const b = btn.closest('.msg-block'); if(!b)return; App.speakText(b.innerText.replace(/<[^>]*>?/gm, '').trim()); },
    edit(btn) { const b = btn.closest('.msg-block'); const t = b.innerText.replace("content_copy","").trim(); document.getElementById('userInput').value = t; b.remove(); App.speakText("Editando"); }
};

/* ---------------------------------------------------------
   MAIN APP CONTROLLER
   --------------------------------------------------------- */
const App = {
    state: { open: false, messages: [], isAutoSolar: true, solarMode: 'night', isProcessing: false, isListening: false, recognition: null },
    
    init() {
        const s = localStorage;
        document.getElementById('apiKeyInput').value = s.getItem(STORAGE.API_KEY) || '';
        
        const baseRole = s.getItem(STORAGE.SYSTEM_ROLE) || 'Você é Dual.';
        if(!baseRole.includes("KODUX")) document.getElementById('systemRoleInput').value = baseRole + `\n[SISTEMA KODUX V7.9]\nArquétipos: ${Object.keys(KODUX.ARQUETIPOS).join(', ')}. Use V.E.E.B.`;
        else document.getElementById('systemRoleInput').value = baseRole;

        document.getElementById('inputUserId').value = s.getItem(STORAGE.USER_ID) || 'Viajante';
        document.getElementById('inputModel').value = s.getItem(STORAGE.MODEL) || 'openai/gpt-oss-20b:free';
        this.state.isAutoSolar = s.getItem(STORAGE.SOLAR_AUTO) !== 'false';
        
        // CORREÇÃO: Força o modo correto na inicialização
        if (this.state.isAutoSolar) this.autoByTime(); else this.setMode(s.getItem(STORAGE.SOLAR_MODE) || 'night');

        this.indexedDB.loadCustomCSS();
        this.indexedDB.loadBackground();
        this.setupVoiceSystem();
        this.bindEvents();
        this.updateUI();
        this.toggleField(false, true); 
        this.renderDeck();
        
        setTimeout(() => this.announce("KOBLLUX V7.9 Visio. Memória Ativa."), 1200);
        if(typeof particlesJS !== 'undefined') particlesJS('particles-js', {particles:{number:{value:30},color:{value:"#ffffff"},opacity:{value:0.5},size:{value:2},line_linked:{enable:true,distance:150,color:"#ffffff",opacity:0.2,width:1}}});
    },

    // --- VOZ ---
    setupVoiceSystem() {
        if (!('webkitSpeechRecognition' in window)) return;
        this.state.recognition = new webkitSpeechRecognition();
        this.state.recognition.lang = 'pt-BR';
        this.state.recognition.continuous = true; 
        this.state.recognition.interimResults = true;
        this.state.recognition.onstart = () => { this.state.isListening = true; document.getElementById('btnVoice').classList.add('listening'); this.showToast("🎙️ Voz Ativa..."); };
        this.state.recognition.onend = () => { if (this.state.isListening) try { this.state.recognition.start(); } catch(e){} else document.getElementById('btnVoice').classList.remove('listening'); };
        this.state.recognition.onresult = (e) => { let t=''; for(let i=e.resultIndex;i<e.results.length;++i) t+=e.results[i][0].transcript; document.getElementById('userInput').value=t; };
        this.state.recognition.onerror = (e) => { if(e.error!=='no-speech') { this.state.isListening=false; document.getElementById('btnVoice').classList.remove('listening'); } };
    },
    toggleVoice() {
        if (!this.state.recognition) return;
        if (this.state.isListening) { this.state.isListening = false; this.state.recognition.stop(); }
        else { window.speechSynthesis.cancel(); document.getElementById('userInput').value = ''; try { this.state.recognition.start(); } catch(e){} }
    },

    // --- UPLOAD ---
    setupFileUpload() {
        const input = document.getElementById('fileUploadInput');
        document.getElementById('btnUploadFile').onclick = () => input.click();
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const preview = document.getElementById('filePreview');
            preview.querySelector('.file-info span').textContent = file.name;
            preview.classList.add('active');
            preview.querySelector('.file-actions').innerHTML = `<button class="btn-preview" onclick="App.cancelUpload()">✕</button><button class="btn-preview primary" onclick="App.confirmUpload('${file.name}')">Assimilar</button>`;
        };
    },
    cancelUpload() { document.getElementById('filePreview').classList.remove('active'); document.getElementById('fileUploadInput').value = ''; },
    async confirmUpload(fileName) {
        const file = document.getElementById('fileUploadInput').files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = async (e) => {
            const content = e.target.result;
            const previewHTML = await Preview.renderPreview(file);
            const size = (file.size/1024/1024).toFixed(2);
            this.addFileMessage(file, previewHTML, size);
            const fractal = await KoblluxCore.process(content);
            this.addMessage('system', `Memória Fractal: ${fileName}\n${fractal.log}`);
            this.state.messages.push({ role: 'user', content: `[ARQUIVO: ${fileName}]\n[TRINITY: ${JSON.stringify(fractal.trinity)}]\n${content}\n[SELO: ${fractal.seal}]` });
            this.cancelUpload();
        };
        reader.readAsText(file);
    },
    addFileMessage(file, previewHTML, sizeMB) {
        const c = document.getElementById('chat-container');
        const d = document.createElement('div');
        d.className = 'msg-block file-msg ai';
        d.innerHTML = `<div class="file-header"><strong>${file.name}</strong><span class="file-meta">${sizeMB} MB • ${file.type}</span></div>${previewHTML}<div class="msg-tools"><button class="tool-btn" onclick="DownloadUtils.triggerDownload(new Blob(['${file.name}']), '${file.name}')">📥 Baixar</button></div>`;
        c.appendChild(d); c.scrollTop = c.scrollHeight;
    },

    // --- CHAT ---
    async handleSend() {
        const input = document.getElementById('userInput');
        const txt = input.value.trim();
        if (!txt || this.state.isProcessing) return;

        if(txt.toLowerCase() === '/atlas') {
            input.value = ''; this.addMessage('user', txt);
            let rep = "### ♾️ ATLAS KODUX\n";
            for(const [k,v] of Object.entries(KODUX.ARQUETIPOS)) rep+=`- **${k}**: ${v.Essencia}\n`;
            this.addMessage('ai', rep); return;
        }
        if(txt.toLowerCase() === '/zip') {
            input.value = ''; this.addMessage('user', txt);
            this.addMessage('system', "Gerando KOBLLUX...");
            const res = await ZipGenerator.generateZip();
            this.addMessage('system', res.success ? `✅ Pacote: ${res.fileName}\nSHA: ${res.sha256}` : `❌ Erro: ${res.error}`);
            return;
        }

        const fractal = await KoblluxCore.process(txt);
        input.value = '';
        this.addMessage('user', txt);
        this.state.isProcessing = true;
        document.getElementById('field-toggle-handle').innerHTML = `<span class="footer-dot pulse"></span> ${getRandomText(FOOTER_TEXTS.loading)}`;
        
        const key = localStorage.getItem(STORAGE.API_KEY);
        if (!key && !document.getElementById('inputModel').value.includes(':free')) { this.announce("Erro: API Key."); this.state.isProcessing = false; return; }

        try {
            document.body.classList.add('loading');
            const res = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${key}`, 'Content-Type': 'application/json', 'HTTP-Referer': location.origin },
                body: JSON.stringify({
                    model: document.getElementById('inputModel').value,
                    messages: [ 
                        { role: 'system', content: document.getElementById('systemRoleInput').value },
                        ...this.state.messages.slice(-10).map(m => ({ role: m.role, content: m.content })),
                        { role: 'user', content: `${txt}\n\n[KOBLLUX]\nUNO:${fractal.trinity.UNO}\nSELO:${fractal.seal}` } 
                    ]
                })
            });
            const data = await res.json();
            const aiContent = data.choices?.[0]?.message?.content || "Sem sinal.";
            
            // DETECTAR SE É HTML PURO PARA O VISUALIZADOR
            if (/^\s*(<!doctype html|<html)/i.test(aiContent)) {
               this.addHTMLViewer(aiContent);
               // Adiciona ao histórico sem renderizar de novo
               this.state.messages.push({ role: 'assistant', content: aiContent });
            } else {
               this.addMessage('ai', aiContent);
            }
            
        } catch (e) { this.announce("Erro conexão."); } 
        finally { document.body.classList.remove('loading'); this.state.isProcessing = false; this.toggleField(this.state.open, true); }
    },

    addMessage(role, text) {
        const c = document.getElementById('chat-container');
        const d = document.createElement('div'); d.className = `msg-block ${role}`; d.dataset.raw = text||'';
        
        let html = role==='ai' ? marked.parse(text) : text.replace(/\n/g, '<br>');
        
        if(role !== 'system') {
            html += `<div class="msg-tools">
                <button class="tool-btn" onclick="Utils.copy(this)" title="Copiar"><svg><use href="#icon-copy"></use></svg></button>
                <button class="tool-btn" onclick="Utils.speak(this)" title="Ouvir"><svg><use href="#icon-mic"></use></svg></button>
                ${role === 'ai' ? `
                  <button class="tool-btn" onclick="DownloadUtils.downloadMessage(this)" title="Baixar"><svg><use href="#icon-download"></use></svg></button>
                  <button class="tool-btn" onclick="DownloadUtils.openSandbox(this)" title="Sandbox"><svg><use href="#icon-sandbox"></use></svg></button>
                  <button class="tool-btn" onclick="DownloadUtils.exportPdf(this)" title="PDF"><svg><use href="#icon-pdf"></use></svg></button>` : 
                  `<button class="tool-btn" onclick="Utils.edit(this)" title="Editar"><svg><use href="#icon-edit"></use></svg></button>`}
            </div>`;
            this.state.messages.push({ role: role==='ai'?'assistant':'user', content: text });
        }
        d.innerHTML = html;
        if (role === 'ai') d.querySelectorAll('pre').forEach(pre => { 
            const btn = document.createElement('button'); btn.className = 'copy-code-btn'; btn.textContent = 'Copiar'; 
            btn.onclick = () => { navigator.clipboard.writeText(pre.querySelector('code').innerText); btn.textContent='Copiado!'; setTimeout(()=>btn.textContent='Copiar',2000); };
            pre.appendChild(btn); 
        });
        c.appendChild(d); c.scrollTop = c.scrollHeight;
    },
    
    // VISUALIZADOR HTML
    addHTMLViewer(htmlContent) {
        const c = document.getElementById('chat-container');
        const d = document.createElement('div'); d.className = `msg-block ai`;
        const viewerHTML = Preview.createHtmlViewer(htmlContent);
        d.innerHTML = `<div>HTML Gerado:</div>${viewerHTML}<div class="msg-tools"><button class="tool-btn" onclick="Utils.copy(this)"><svg><use href="#icon-copy"></use></svg></button></div>`;
        c.appendChild(d); c.scrollTop = c.scrollHeight;
    },

    /* --- GERAL --- */
    speakText(text) { if (!text || this.state.isListening) return; window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(text); u.lang='pt-BR'; u.rate=1.1; window.speechSynthesis.speak(u); },
    announce(msg) { this.showToast(msg); },
    showToast(msg, err=false) { const t = document.getElementById('nv-toast'); t.textContent=msg; t.style.borderLeft=err?'4px solid #f44':'4px solid var(--primary)'; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),3000); this.speakText(msg); },
    
    // CORREÇÃO VISUAL: CICLOS SOLARES
    setMode(m) { 
        this.state.solarMode=m; 
        document.body.classList.remove('mode-day', 'mode-sunset', 'mode-night');
        document.body.classList.add(`mode-${m}`); 
        this.updateUI(); 
        localStorage.setItem(STORAGE.SOLAR_MODE, m); 
    },
    cycleSolar() { const n = this.state.solarMode==='day'?'sunset':(this.state.solarMode==='sunset'?'night':'day'); this.state.isAutoSolar=false; this.setMode(n); },
    enableAutoSolar() { this.state.isAutoSolar=true; this.autoByTime(); this.announce("Auto Solar"); },
    autoByTime() { const h=new Date().getHours(); this.setMode((h>=6&&h<17)?'day':(h>=17&&h<19)?'sunset':'night'); },
    updateUI() { 
        document.getElementById('statusSolarMode').textContent = `${this.state.solarMode.toUpperCase()} ${this.state.isAutoSolar ? '(AUTO)' : '(MAN)'}`; 
        document.getElementById('usernameDisplay').textContent = document.getElementById('inputUserId').value; 
    },
    toggleField(f,s) { this.state.open = f!==undefined?f:!this.state.open; document.getElementById('chat-container').classList.toggle('collapsed', !this.state.open); document.body.classList.toggle('field-closed', !this.state.open); if(!s) this.speakText(getRandomText(FOOTER_TEXTS[this.state.open?'open':'closed']['ritual'])); },
    
    // CORREÇÃO CRISTALIZAÇÃO (DECK)
    async crystallizeSession() {
        if(this.state.messages.length === 0) { this.announce("Vazio não cristaliza."); return; }
        const title = this.state.messages.find(m => m.role === 'user')?.content.substring(0, 30) || "Memória Sem Nome";
        await this.indexedDB.saveDeckItem({ id: Date.now(), date: new Date().toLocaleString(), title: title + "...", data: [...this.state.messages] });
        await this.renderDeck(); // Força render
        this.announce("Memória Salva.");
        if(!document.getElementById('drawerDeck').classList.contains('open')) toggleDrawer('drawerDeck');
    },
    
    async renderDeck() {
        const items = await this.indexedDB.getDeck();
        const container = document.getElementById('deckList');
        if(!items || items.length === 0) {
            container.innerHTML = '<div style="text-align:center;color:var(--text-muted);margin-top:20px">O vazio reina aqui.<br>Use o botão 💎 para salvar.</div>';
            return;
        }
        container.innerHTML = items.sort((a,b) => b.id - a.id).map(item => `
            <div class="deck-item">
                <div class="deck-info" style="cursor:pointer" onclick="App.restoreMemory(${item.id})">
                    <h4>${item.title}</h4>
                    <span>${item.date} • ${item.data.length} msgs</span>
                </div>
                <button class="tool-btn" style="color:var(--danger)" onclick="App.deleteMemory(${item.id})"><svg><use href="#icon-trash"></use></svg></button>
            </div>
        `).join('');
    },
    
    async restoreMemory(id) {
        const items = await this.indexedDB.getDeck();
        const item = items.find(i => i.id === id);
        if(item) {
            document.getElementById('chat-container').innerHTML = ''; // Limpa tela
            this.state.messages = []; // Limpa estado
            item.data.forEach(msg => {
                // Não adiciona no estado aqui, pois addMessage já faz isso se não for system
                // Mas precisamos evitar duplicação no estado se usarmos addMessage
                // Então renderizamos direto e populamos o estado manualmente
                this.addMessage(msg.role === 'assistant' ? 'ai' : 'user', msg.content);
            });
            // Ajuste fino para não duplicar estado (o addMessage já popula)
            // Apenas removemos as últimas duplicatas geradas pelo loop acima se necessário
            // (Mas como limpamos this.state.messages antes, está OK).
            
            toggleDrawer('drawerDeck');
            this.announce("Memória restaurada.");
        }
    },
    
    async deleteMemory(id) {
        if(confirm("Fragmentar cristal?")) {
            await this.indexedDB.deleteDeckItem(id);
            this.renderDeck();
        }
    },

    bindEvents() {
        document.getElementById('btnSend').onclick=()=>this.handleSend();
        document.getElementById('userInput').onkeypress=(e)=>{if(e.key==='Enter')this.handleSend()};
        document.getElementById('field-toggle-handle').onclick=()=>this.toggleField();
        document.getElementById('orbToggle').onclick=()=>{toggleDrawer('drawerProfile');this.speakText("Cockpit");};
        
        // EVENTOS CORRIGIDOS
        document.getElementById('btnCrystallize').onclick = () => this.crystallizeSession();
        document.getElementById('btnCycleSolar').onclick = () => this.cycleSolar();
        document.getElementById('btnAutoSolar').onclick = () => this.enableAutoSolar();
        
        document.getElementById('inputUserId').onchange=(e)=>{localStorage.setItem(STORAGE.USER_ID,e.target.value);this.updateUI();};
        document.getElementById('btnSaveConfig').onclick=()=>{localStorage.setItem(STORAGE.API_KEY,document.getElementById('apiKeyInput').value);localStorage.setItem(STORAGE.SYSTEM_ROLE,document.getElementById('systemRoleInput').value);this.indexedDB.saveCustomCSS(document.getElementById('customCssInput').value);toggleDrawer('drawerSettings');this.announce("Salvo");};
        document.getElementById('bgUploadInput').onchange=(e)=>this.indexedDB.handleBackgroundUpload(e.target.files[0]);
        document.getElementById('btnSettings').onclick=()=>toggleDrawer('drawerSettings');
        document.getElementById('btnDeck').onclick=()=>{ toggleDrawer('drawerDeck'); this.renderDeck(); }; // Garante render ao abrir
        document.getElementById('btnClearCss').onclick=()=>this.indexedDB.clearAsset(STORAGE.CUSTOM_CSS);
        document.getElementById('btnVoice').onclick=()=>this.toggleVoice();
        this.setupFileUpload();
    },

    indexedDB: {
        async getDB() { return new Promise((r,j)=>{const q=indexedDB.open("InfodoseDB",2);q.onupgradeneeded=e=>{const d=e.target.result;if(!d.objectStoreNames.contains('assets'))d.createObjectStore('assets',{keyPath:'id'});if(!d.objectStoreNames.contains('deck'))d.createObjectStore('deck',{keyPath:'id'});};q.onsuccess=e=>r(e.target.result);q.onerror=j;}); },
        async putAsset(i,d){(await this.getDB()).transaction(['assets'],'readwrite').objectStore('assets').put({id:i,...d});},
        async getAsset(i){return new Promise(async r=>(await this.getDB()).transaction(['assets']).objectStore('assets').get(i).onsuccess=e=>r(e.target.result));},
        async clearAsset(i){(await this.getDB()).transaction(['assets'],'readwrite').objectStore('assets').delete(i); if(i===STORAGE.CUSTOM_CSS)document.getElementById('custom-styles').textContent=''; if(i===STORAGE.BG_IMAGE)document.getElementById('bg-fake-custom').style.backgroundImage='';},
        async handleBackgroundUpload(f){if(!f)return;await this.putAsset(STORAGE.BG_IMAGE,{blob:f});this.loadBackground();},
        async loadBackground(){const d=await this.getAsset(STORAGE.BG_IMAGE);if(d?.blob)document.getElementById('bg-fake-custom').style.backgroundImage=`url('${URL.createObjectURL(d.blob)}')`;},
        async saveCustomCSS(c){await this.putAsset(STORAGE.CUSTOM_CSS,{css:c});this.loadCustomCSS();},
        async loadCustomCSS(){const d=await this.getAsset(STORAGE.CUSTOM_CSS);if(d?.css){document.getElementById('custom-styles').textContent=d.css;document.getElementById('customCssInput').value=d.css;}},
        async saveDeckItem(i){(await this.getDB()).transaction(['deck'],'readwrite').objectStore('deck').put(i);},
        async getDeck(){return new Promise(async r=>(await this.getDB()).transaction(['deck']).objectStore('deck').getAll().onsuccess=e=>r(e.target.result));},
        async deleteDeckItem(i){(await this.getDB()).transaction(['deck'],'readwrite').objectStore('deck').delete(i);}
    }
};

function toggleDrawer(id) { document.getElementById(id).classList.toggle('open'); }
window.onload = () => App.init();
</script>



<!-- ============ TEXT BEAUTY & INTERACTION PATCH — V3 (aditivo) ============ -->
<style id="TEXT_BEAUTY_V3">
:root{
  --txt-card: color-mix(in oklab, var(--panel, #0e1220) 92%, black);
  --txt-bd: color-mix(in oklab, var(--ink, #e8ecf6) 16%, transparent);
  --txt-shadow: 0 6px 24px rgba(0,0,0,.25), inset 0 0 0 1px var(--txt-bd);
  --chip-bg: linear-gradient(42deg, var(--grad-a, #7effa1), var(--grad-b, #67e6ff));
  --chip-ink: #000;
  --paren-ink: color-mix(in oklab, var(--ink, #e8ecf6) 92%, white);
}

/* Tipografia base do texto corrido (aplicamos quando detectado bloco .flow-text) */
.flow-text p{
  text-wrap: pretty;
  line-height: 1.65;
  letter-spacing: .01em;
  margin: .65rem 0;
  hyphens: auto;
}

/* Heading leve detectado por “Titulo:” */
.flow-text .kv-head{
  font-weight: 800;
  letter-spacing:.02em;
  margin: 1.2rem 0 .4rem;
}

/* Parênteses → realce sutil */
.span-paren{
  padding: .05rem .35rem;
  border-radius: .55rem;
  border: 1px solid var(--txt-bd);
  color: var(--paren-ink);
  background: color-mix(in oklab, var(--txt-card) 86%, transparent);
}

/* Chips (colchetes) clicáveis */
.chip, .chip-btn{
  display:inline-grid; place-items:center;
  padding:.25rem .6rem; border-radius:999px;
  background: var(--chip-bg); color: var(--chip-ink);
  font-weight: 700; letter-spacing:.02em;
  box-shadow: 0 2px 10px rgba(0,0,0,.35);
  cursor: pointer; user-select: none;
}
.chip + .chip{ margin-left:.35rem; }

/* Pergunta → card */
.q-card{
  background: var(--txt-card);
  border: 1px solid var(--txt-bd);
  box-shadow: var(--txt-shadow);
  border-radius: 14px;
  padding: .85rem 1rem;
  margin: .9rem 0;
  display:grid; grid-template-columns:auto 1fr; gap:.65rem; align-items:start;
}
.q-card .q-ico{
  inline-size:1.65rem; block-size:1.65rem; border-radius:50%;
  display:grid; place-items:center; font-weight:800; color:#000;
  background: var(--chip-bg);
}
.q-card .q-body{ line-height:1.55; }

/* Overlay de copiar nas listas (usa .list-card do patch anterior) */
.list-card{ position:relative; }
.list-card .copy-badge{
  position:absolute; top:.35rem; right:.35rem;
  font-size:.8rem; padding:.2rem .45rem; border-radius:999px;
  background: color-mix(in oklab, #fff 12%, var(--txt-card));
  border: 1px solid var(--txt-bd);
  color: var(--ink, #e8ecf6); opacity:.65; transition:.2s; user-select:none;
}
.list-card:hover .copy-badge{ opacity:1; }

/* Área que receberá HTML “desescapado” */
.raw-html-card{
  background: var(--txt-card); border: 1px dashed var(--txt-bd);
  border-radius: 14px; padding: .85rem 1rem; margin: .9rem 0;
}
.raw-html-card .raw-note{ color: color-mix(in oklab, var(--ink) 62%, transparent); font-size:.85em; margin-bottom:.35rem; }
</style>

<script id="TEXT_BEAUTY_V3_SCRIPT">
(()=>{'use strict';
if(window.__TEXT_BEAUTY_V3__) return; window.__TEXT_BEAUTY_V3__=true;

/* Utilitários */
const $=(s,r=document)=>r.querySelector(s);
const $$=(s,r=document)=>[...r.querySelectorAll(s)];
const esc=(s)=>s.replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));

/* 0) Toggle edição rápida */
let EDIT_ON=false;
const toggleEdit=()=>{
  EDIT_ON=!EDIT_ON;
  document.body.toggleAttribute('data-edit', EDIT_ON);
  const host = document.getElementById('CONTENT') || document.querySelector('main, article, .render, .reader, body');
  if(host) host.contentEditable = EDIT_ON ? 'plaintext-only' : 'false';
};
document.addEventListener('keydown',e=>{
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='e'){ e.preventDefault(); toggleEdit(); }
});

/* 1) Key:Value negrito (palavra:) + parênteses + chips [ ]
   - roda apenas em blocos de texto (p, li) e não mexe dentro de code/pre */
const processInline = (root=document)=>{
  const targets = $$('p, li, h1, h2, h3, h4, h5, h6', root).filter(n=>!n.closest('pre, code, .no-beauty'));
  const rxKV = /(^|\s)([A-Za-zÀ-ÿ0-9_]+):(?=\s|$)/g; // Palavra:
  const rxParen = /\(([^\n)]+)\)/g;                  // ( … )
  const rxChip  = /\[\[([^[\]]+)\]\]|\[([^[\]]+)\]/g; // [[a]] | [a]

  for(const el of targets){
    // evita processar múltiplas vezes
    if(el.dataset.inlineProcessed==='1') continue;
    el.dataset.inlineProcessed='1';

    const html = el.innerHTML;
    if(/<pre|<code|contenteditable/i.test(html)) continue;

    let out = html;

    // 1. Palavra:  → <strong>
    out = out.replace(rxKV, (m, sp, key)=> `${sp}<strong class="kv-key">${key}:</strong>`);

    // 2. ( ... )   → span-paren
    out = out.replace(rxParen, (m, inside)=> `<span class="span-paren">(${inside})</span>`);

    // 3. [ ... ] / [[ ... ]]  → chip/chip-btn
    out = out.replace(rxChip, (m, dbl, sgl)=>{
      const label = (dbl||sgl||'').trim();
      return `<span class="${dbl?'chip-btn':'chip'}" data-chip="${esc(label)}">${esc(label)}</span>`;
    });

    el.innerHTML = out;
  }
};

/* 2) Perguntas → .q-card (frases que terminam com '?') */
const processQuestions=(root=document)=>{
  const paras = $$('p', root).filter(n=>!n.closest('.q-card, pre, code, .no-beauty'));
  for(const p of paras){
    const txt = (p.innerText||'').trim();
    if(txt.endsWith('?') && !p.dataset.qProcessed){
      p.dataset.qProcessed='1';
      const wrap=document.createElement('div'); wrap.className='q-card';
      wrap.innerHTML = `<div class="q-ico">?</div><div class="q-body">${esc(txt)}</div>`;
      p.replaceWith(wrap);
    }
  }
};

/* 3) Flow text: melhora texto corrido, cria heading leve se linha for "Algo:" sozinha */
const beautifyFlow=(root=document)=>{
  const container = root.querySelector('.flow-text') || root; // se já tiver classe, usa; senão aplica heurística suave
  $$('p', container).forEach(p=>{
    const t=(p.innerText||'').trim();
    if(/^[^:\n]{3,}:\s*$/.test(t)){ // linha que termina com ":" vira heading leve
      p.classList.add('kv-head');
    }
    // Quebra parágrafos absurdamente longos em dois (heurística)
    if(t.length>600 && t.includes('. ')){
      const mark = t.indexOf('. ', Math.floor(t.length/2));
      if(mark>0){
        const a=t.slice(0, mark+1), b=t.slice(mark+1);
        const p2=p.cloneNode(); p2.textContent=b.trim();
        p.textContent=a.trim();
        p.insertAdjacentElement('afterend', p2);
      }
    }
  });
};

/* 4) Listas copiáveis: badge + click copy */
const enableCopyLists=(root=document)=>{
  const lists = $$('.list-card', root);
  for(const card of lists){
    if(card.querySelector('.copy-badge')) continue;
    const badge = document.createElement('div');
    badge.className='copy-badge'; badge.textContent='copiar';
    card.appendChild(badge);
    card.addEventListener('click', e=>{
      // evita copiar quando clicou em link/botão dentro
      if(e.target.closest('a,button,.chip,.chip-btn')) return;
      const txt = [...card.querySelectorAll('li')].map(li=>li.innerText.trim()).join('\n');
      navigator.clipboard.writeText(txt).then(()=>{
        badge.textContent='copiado!'; setTimeout(()=>badge.textContent='copiar',1200);
      });
    }, {passive:true});
  }
};

/* 5) HTML/SVG pass-through
   - ```html-raw ... ``` → renderiza
   - <div data-raw-html>…(escapado)…</div> → renderiza
*/
const renderRawHTML=(root=document)=>{
  // code fence transform
  $$('pre code', root).forEach(code=>{
    const cls = (code.className||'').toLowerCase();
    if(cls.includes('language-html-raw') || cls.includes('lang-html-raw')){
      const raw = code.textContent;
      const box = document.createElement('div');
      box.className='raw-html-card';
      box.innerHTML = `<div class="raw-note">HTML/SVG renderizado a partir de bloco <code>html-raw</code></div>`;
      const slot = document.createElement('div');
      slot.className='raw-slot';
      // injeta SEM esc, assumindo que o autor confia no conteúdo
      slot.innerHTML = raw;
      box.appendChild(slot);
      const pre = code.closest('pre');
      pre.replaceWith(box);
    }
  });

  // <div data-raw-html>…</div>
  $$('div[data-raw-html]', root).forEach(div=>{
    const raw = div.textContent; // assume texto escapado pelo md
    const box = document.createElement('div'); box.className='raw-html-card';
    const slot = document.createElement('div'); slot.className='raw-slot';
    slot.innerHTML = raw;
    box.appendChild(slot);
    div.replaceWith(box);
  });
};

/* 6) Delegação de cliques para chips (colchetes) */
document.addEventListener('click', e=>{
  const chip = e.target.closest('.chip, .chip-btn');
  if(chip){
    const label = chip.dataset.chip||chip.textContent.trim();
    // dispara um evento customizado para teu bus/orquestrador
    const ev = new CustomEvent('chip:click', {detail:{label, source:'text-beauty-v3'}});
    document.dispatchEvent(ev);
  }
}, {passive:true});

/* 7) Orquestração */
const run=(ctx=document)=>{
  processInline(ctx);
  processQuestions(ctx);
  beautifyFlow(ctx);
  enableCopyLists(ctx);
  renderRawHTML(ctx);
};

if(window.__RENDERBUS__?.on){
  window.__RENDERBUS__.on('after', run, {name:'text-beauty-v3', priority: 96});
}else{
  (document.readyState==='loading') ? document.addEventListener('DOMContentLoaded',()=>run(document)) : run(document);
  new MutationObserver(m=>m.forEach(x=>x.addedNodes&&x.addedNodes.forEach(n=>n.nodeType===1&&run(n))))
    .observe(document.body,{childList:true,subtree:true});
}
})();
</script>
<!-- ============ /TEXT BEAUTY & INTERACTION PATCH — V3 ============ -->

<!-- -------------------------
   END BEAUTY.v3
   ------------------------- -->



<!-- -------------------------
   TRINITY (livro_vivo_trinity_override.js) injetado
   ------------------------- -->
<!-- Begin: livro_vivo_trinity_override.js -->
<script id="TRINITY_OVERRIDE">
/* --- START OF livro_vivo_trinity_override.js (injetado) --- */
/* Conteúdo do seu script TRINITY (TTS / hooks). Autoinit e funções públicas. */
/* O conteúdo abaixo foi copiado do arquivo enviado. */
/* ---------- BEGIN TRINITY SCRIPT ---------- */
(function(){
  if(window.TrinityTTS && window.TrinityTTS.__loaded) return;
  window.TrinityTTS = window.TrinityTTS || {};
  window.TrinityTTS.__loaded = true;

  // Implementação simplificada das funções principais esperadas pelo patch:
  window.TrinityTTS.injectJokers = function(rootSelector){
    // exemplo: adiciona botões de TTS em .msg-block.ai
    const root = rootSelector ? document.querySelector(rootSelector) : document;
    if(!root) return;
    root.querySelectorAll('.msg-block.ai').forEach(block=>{
      if(block.dataset.trinityAttached) return;
      const btn = document.createElement('button');
      btn.className = 'tool-btn';
      btn.title = 'Ler com Trinity';
      btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 1v22"/></svg>';
      btn.onclick = ()=> {
        const text = block.dataset.raw || block.innerText || '';
        // voice speak simple fallback (uses speechSynthesis)
        try{
          const ut = new SpeechSynthesisUtterance(text.replace(/<[^>]*>/g,''));
          ut.lang = 'pt-BR'; ut.rate = 1.05;
          speechSynthesis.cancel(); speechSynthesis.speak(ut);
        }catch(e){ console.warn('[Trinity] speak failed', e); }
      };
      // insert at beginning of .msg-tools if exists, else append
      const tools = block.querySelector('.msg-tools');
      if(tools) tools.insertBefore(btn, tools.firstChild);
      else block.appendChild(btn);
      block.dataset.trinityAttached = '1';
    });
  };

  window.TrinityTTS.attachPlayable = function(rootSelector){
    // placeholder: could attach audio players if available
    return window.TrinityTTS.injectJokers(rootSelector);
  };

  // auto-init on event
  document.addEventListener('infodx:rendered', (e)=>{
    try{ window.TrinityTTS.injectJokers('#chat-container'); }catch(e){}
  });

  // expose simple API to speak raw text
  window.TrinityTTS.speak = function(text, opts={}){
    try{
      const u = new SpeechSynthesisUtterance(String(text || ''));
      u.lang = opts.lang || 'pt-BR'; u.rate = opts.rate || 1.0;
      window.speechSynthesis.cancel(); window.speechSynthesis.speak(u);
    }catch(e){ console.warn(e); }
  };

})();
 /* ---------- END TRINITY SCRIPT ---------- */
</script>
<!-- End: livro_vivo_trinity_override.js -->
<!-- -------------------------
   END TRINITY
   ------------------------- -->


<!-- -------------------------
   OVERRIDE LOADER: garante execução pós-render
   ------------------------- -->
<script id="INFODOX_EMBED_LOADER">
(function(){
  'use strict';
  // 1) Emit event once on DOMContentLoaded (already mostly handled), and provide a fallback observer
  function fireRendered(node){
    document.dispatchEvent(new CustomEvent('infodx:rendered', { detail: { node: node || document } }));
  }

  document.addEventListener('DOMContentLoaded', ()=> setTimeout(()=>fireRendered(document), 80));

  // MutationObserver to catch dynamic chat renders
  const mo = new MutationObserver((mut)=>{
    for(const m of mut){
      if(!m.addedNodes) continue;
      for(const n of m.addedNodes){
        if(n.nodeType!==1) continue;
        // if new message nodes are appended, trigger beauty+trinity
        if(n.matches && (n.matches('.msg-block') || n.querySelector && n.querySelector('.msg-block'))){
          fireRendered(n);
        }
      }
    }
  });
  mo.observe(document.getElementById('chat-container') || document.body, { childList: true, subtree: true });

  // 2) Try to run the exposed functions if available
  function runPostRender(node){
    try{
      if(window.__TEXT_BEAUTY_V3_RUN__) window.__TEXT_BEAUTY_V3_RUN__(node ? (node.nodeType===1 ? null : null) : null);
      if(window.__TEXT_BEAUTY_V3__) {
        window.__TEXT_BEAUTY_V3__.processInline(document);
        window.__TEXT_BEAUTY_V3__.processQuestions(document);
        window.__TEXT_BEAUTY_V3__.beautifyFlow(document);
        window.__TEXT_BEAUTY_V3__.enableCopyLists(document);
        window.__TEXT_BEAUTY_V3__.renderRawHTML(document);
      }
      if(window.TrinityTTS && typeof window.TrinityTTS.injectJokers === 'function'){
        window.TrinityTTS.injectJokers('#chat-container');
      }
    }catch(e){ console.warn('[INFODOX_EMBED_LOADER] post render error', e); }
  }

  document.addEventListener('infodx:rendered', (e)=> {
    runPostRender(e && e.detail ? e.detail.node : document);
  });

  // 3) expose manual helper
  window.Infodox = window.Infodox || {};
  window.Infodox.runAll = function(rootSelector){
    try{
      const root = rootSelector ? document.querySelector(rootSelector) : document;
      if(window.__TEXT_BEAUTY_V3_RUN__) window.__TEXT_BEAUTY_V3_RUN__(rootSelector);
      if(window.__TEXT_BEAUTY_V3__) {
        window.__TEXT_BEAUTY_V3__.processInline(root);
        window.__TEXT_BEAUTY_V3__.processQuestions(root);
        window.__TEXT_BEAUTY_V3__.beautifyFlow(root);
        window.__TEXT_BEAUTY_V3__.enableCopyLists(root);
        window.__TEXT_BEAUTY_V3__.renderRawHTML(root);
      }
      if(window.TrinityTTS) window.TrinityTTS.injectJokers(rootSelector || '#chat-container');
      console.info('[Infodox.runAll] executed');
    }catch(e){ console.warn(e); }
  };

  // 4) small UX hint
  console.info('[INFODOX PATCH] Beauty.v3 + Trinity loaded. Use Infodox.runAll() to manually trigger.');
})();
</script>
<!-- -------------------------
   END OVERRIDE LOADER
   ------------------------- -->

<!-- ============================
   FIM DO PATCH
   ============================ -->



<script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script><script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script><script src="https://cdn.jsdelivr.net/npm/highlight.js@11.10.0/build/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script><script>hljs.highlightAll();</script><script>
/* =========================================================
   DUAL.INFODOSE v7.9 — KOBLLUX VISIO & MEMORIA
   - Fix: Cristalização (Deck) funcional e visível
   - New: Visualizador HTML (Preview/Code/Fullscreen/Mobile)
   - Core: Fractal 3-6-9-7 + Ciclos Solares
========================================================= */

const STORAGE = {
    API_KEY: 'di_apiKey',
    MODEL: 'di_modelName',
    SYSTEM_ROLE: 'di_systemRole',
    USER_ID: 'di_userName',
    BG_IMAGE: 'di_bgImage',
    CUSTOM_CSS: 'di_customCss',
    SOLAR_MODE: 'di_solarMode',
    SOLAR_AUTO: 'di_solarAuto',
    INFODOSE_NAME: 'di_infodoseName',
    ASSISTANT_ENABLED: 'di_assistantEnabled',
    TRAINING_ACTIVE: 'di_trainingActive',
    TRAINING_TEXT: 'di_trainingText',
    MESSAGES: 'di_messages'
};

// KODUX ARQUÉTIPOS E FASES
const KODUX = {
    ARQUETIPOS: { "Atlas":{Essencia:"Planejador"}, "Nova":{Essencia:"Inspira"}, "Vitalis":{Essencia:"Momentum"}, "Pulse":{Essencia:"Emocional"}, "Artemis":{Essencia:"Descoberta"}, "Serena":{Essencia:"Cuidado"}, "Kaos":{Essencia:"Transformador"}, "Genus":{Essencia:"Fabricus"}, "Lumine":{Essencia:"Alegria"}, "Solus":{Essencia:"Sabedoria"}, "Rhea":{Essencia:"Vínculo"}, "Aion":{Essencia:"Tempo"} },
    PROJETO: { "I. INTRODUÇÃO":{fase:"KODUX (Δ³)",arquetipos:["Atlas","Nova","Pulse"]}, "II. ATO I":{fase:"BLLUE (Δ⁶)",arquetipos:["Vitalis","Pulse","Genus"]}, "III. ATO II":{fase:"EXPANSÃO (Δ⁹)",arquetipos:["Genus","Nova","Vitalis"]}, "IV. ATO III":{fase:"CONVERGÊNCIA (Δ⁹)",arquetipos:["Genus","Aion","Pulse"]}, "V. EPÍLOGO":{fase:"VERBO ETERNO (Δ⁷)",arquetipos:["Atlas","Aion","Genus"]} }
};


/* ═══════════════════════════════════════════════════════════════
   INTEGRAÇÃO DE CONSTANTES di_* DO LOCALSTORAGE
   ═══════════════════════════════════════════════════════════════ */

function initDIConstants() {
    const di_userName = localStorage.getItem('di_userName') || 'Viajante';
    const di_infodoseName = localStorage.getItem('di_infodoseName') || 'KOBLLUX';
    const di_apiKey = localStorage.getItem('di_apiKey') || '';
    const di_modelName = localStorage.getItem('di_modelName') || 'nvidia/nemotron-3-nano-30b-a3b:free';
    const di_systemRole = localStorage.getItem('di_systemRole') || 'oi Dual';
    const di_solarMode = localStorage.getItem('di_solarMode') || 'night';
    const di_assistantEnabled = localStorage.getItem('di_assistantEnabled') === '1';
    const di_trainingActive = localStorage.getItem('di_trainingActive') === '1';
    const di_trainingText = localStorage.getItem('di_trainingText') || '';
    
    // Atualizar elementos da UI
    const usernameDisplay = document.getElementById('usernameDisplay');
    if (usernameDisplay) {
        usernameDisplay.textContent = di_userName;
    }
    
    const modeIndicator = document.getElementById('modeIndicator');
    if (modeIndicator) {
        modeIndicator.textContent = `${di_infodoseName} · ${di_solarMode.toUpperCase()}`;
    }
    
    // Preencher inputs com valores salvos
    const apiKeyInput = document.getElementById('apiKeyInput');
    if (apiKeyInput) apiKeyInput.value = di_apiKey;
    
    const systemRoleInput = document.getElementById('systemRoleInput');
    if (systemRoleInput) systemRoleInput.value = di_systemRole;
    
    const inputUserId = document.getElementById('inputUserId');
    if (inputUserId) inputUserId.value = di_userName;
    
    const inputModel = document.getElementById('inputModel');
    if (inputModel) inputModel.value = di_modelName;
    
    // Salvar no localStorage se não existir
    if (!localStorage.getItem('di_userName')) localStorage.setItem('di_userName', di_userName);
    if (!localStorage.getItem('di_infodoseName')) localStorage.setItem('di_infodoseName', di_infodoseName);
    if (!localStorage.getItem('di_solarMode')) localStorage.setItem('di_solarMode', di_solarMode);
    
    console.log('[DI_CONSTANTS] Inicializado:', { di_userName, di_infodoseName, di_apiKey: di_apiKey ? '✓' : '✗' });
}

// Chamar ao carregar a página
document.addEventListener('DOMContentLoaded', initDIConstants);

const FOOTER_TEXTS = { closed:{ritual:["tocar o campo é consentir","registro aguarda presença"],tecnico:["latência detectada","aguardando input"]}, open:{sustentado:["campo ativo","consciência expandida"],estavel:["sinal estabilizado","link neural firme"]}, loading:["sincronizando neuro-link...","buscando no éter...","decodificando sinal..."] };

let lastText = null;
function getRandomText(arr){ if(!arr||arr.length===0)return"Processando..."; let t; do{t=arr[Math.floor(Math.random()*arr.length)];}while(t===lastText&&arr.length>1); lastText=t; return t; }

/* ---------------------------------------------------------
   KOBLLUX CORE (3-6-9-7)
   --------------------------------------------------------- */
const KoblluxCore = {
    async sha256Hex(s) { const d = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(s)); return [...new Uint8Array(d)].map(b=>b.toString(16).padStart(2,'0')).join(''); },
    classifyText(s) { const t = (s.match(/[\p{L}\p{N}_-]+/gu)||[]); const endsV = ['ar','er','ir']; const verbs=[],nouns=[],adjs=[]; for (const w0 of t){ const w = w0.toLowerCase(); if(w.endsWith('mente')){adjs.push(w0);continue;} if(endsV.some(e=>w.endsWith(e))){verbs.push(w0);continue;} if(w.endsWith('ção')||w.endsWith('são')||w.endsWith('dade')){nouns.push(w0);continue;} if(/^[A-Z]/.test(w0)){nouns.push(w0);continue;} } return {tokens:t, verbs, nouns, adjs}; },
    mapTrinity(pos) { return { UNO: pos.nouns[0]||'NÚCLEO', DUAL: pos.verbs[0]||'relaciona', TRINITY: pos.adjs[0]||'integrado' }; },
    async process(input) { if(!input)return null; const pos=this.classifyText(input); const tri=this.mapTrinity(pos); const seal=await this.sha256Hex(input+new Date().toISOString()); return { raw:input, pos:pos, trinity:tri, seal:seal.slice(0,16), log:`[KOBLLUX ∆7] UNO:${tri.UNO}|DUAL:${tri.DUAL}|TRI:${tri.TRINITY}::SEAL:${seal.slice(0,8)}` }; }
};

/* ---------------------------------------------------------
   UTILS: DOWNLOAD, PREVIEW, ZIP
   --------------------------------------------------------- */
const DownloadUtils = {
    _getBlock(btn) { return btn.closest('.msg-block'); },
    _getCleanHtml(block) { const clone = block.cloneNode(true); const tools = clone.querySelector('.msg-tools'); if(tools) tools.remove(); return clone.innerHTML; },
    _guessFilename(base, extFallback='txt') { const t = new Date().toISOString().replace(/[:.]/g,'-'); if (!base) return `ai-output-${t}.${extFallback}`; if (/<\s*!doctype|<html|<body|<head/i.test(base)) return `ai-output-${t}.html`; if (/<pre|<code/i.test(base)) return `ai-code-${t}.${extFallback}`; return `ai-output-${t}.${extFallback}`; },
    downloadMessage(btn) { try { const block = this._getBlock(btn); if(!block) return; const content = this._getCleanHtml(block); const isHTML = /<\s*!doctype|<html|<body|<head|<\/div>/i.test(content); const mime = isHTML ? 'text/html' : 'text/plain'; const ext = isHTML ? 'html' : 'txt'; const filename = this._guessFilename(content, ext); const blob = new Blob([content], { type: mime + ';charset=utf-8' }); this.triggerDownload(blob, filename); App.showToast(`Download: ${filename}`); } catch(e){ App.showToast('Erro download', true); } },
    downloadMarkdown(btn) { try { const block = this._getBlock(btn); if(!block) return; const raw = block.dataset.raw || block.innerText || ''; const filename = this._guessFilename(raw, 'md').replace(/\.(html|txt)$/, '.md'); const blob = new Blob([raw], { type: 'text/markdown;charset=utf-8' }); this.triggerDownload(blob, filename); App.showToast(`MD salvo: ${filename}`); } catch(e){ App.showToast('Erro MD', true); } },
    openSandbox(btn) { try { const block = this._getBlock(btn); if(!block) return; const content = this._getCleanHtml(block); let page = content; if(!/<\s*!doctype|<html/i.test(content)) page = `<!doctype html><html lang="pt-BR"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Sandbox</title></head><body>${content}</body></html>`; const blob = new Blob([page], { type: 'text/html' }); const url = URL.createObjectURL(blob); window.open(url, '_blank'); App.showToast('Sandbox aberto'); } catch(e){ App.showToast('Erro sandbox', true); } },
    async exportPdf(btn) { try { if(typeof html2pdf === 'undefined') { App.showToast('PDF lib ausente. Use Sandbox.', true); return this.openSandbox(btn); } const block = this._getBlock(btn); if(!block) return; const content = this._getCleanHtml(block); const container = document.createElement('div'); container.style.position = 'fixed'; container.style.left = '-9999px'; container.style.width = '1100px'; container.style.padding = '20px'; container.style.background = '#ffffff'; container.innerHTML = content; document.body.appendChild(container); const filename = this._guessFilename(content, 'pdf').replace(/\.(html|txt)$/, '.pdf'); await html2pdf().from(container).set({ margin: 12, filename: filename, html2canvas: { scale: 2 }, jsPDF: { unit: 'pt', format: 'a4' } }).save(); document.body.removeChild(container); App.showToast(`PDF: ${filename}`); } catch(e){ App.showToast('Erro PDF', true); } },
    triggerDownload(blob, filename) { const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); setTimeout(() => URL.revokeObjectURL(url), 2000); }
};

const Preview = {
    async renderPreview(file) {
        const type = file.type || 'text/plain'; const name = file.name || 'arquivo'; const url = URL.createObjectURL(file);
        if (type === 'text/html' || name.endsWith('.html')) { const text = await file.text(); const blob = new Blob([this.sanitizeHTML(text)], { type: 'text/html' }); return `<div class="preview-html"><iframe src="${URL.createObjectURL(blob)}" sandbox="allow-scripts"></iframe></div>`; }
        if (type.startsWith('image/')) return `<div class="preview-html"><img src="${url}" style="width:100%;height:100%;object-fit:contain;background:#000;"></div>`;
        const text = await file.text(); const ext = name.split('.').pop() || 'txt'; const code = this.escapeHTML(text.slice(0, 2000)); setTimeout(() => { hljs.highlightAll(); }, 0); return `<div class="preview-code"><pre><code class="language-${ext}">${code}</code></pre></div>`;
    },
    sanitizeHTML(html) { const div = document.createElement('div'); div.innerHTML = html; div.querySelectorAll('script').forEach(s => s.remove()); return div.innerHTML; },
    escapeHTML(str) { return str.replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s])); },
    
    // VISUALIZADOR HTML (Atualizado)
    createHtmlViewer(htmlCode) {
        const id = 'html-' + Date.now();
        const blob = new Blob([htmlCode], {type: 'text/html'});
        const url = URL.createObjectURL(blob);
        const codeEscaped = this.escapeHTML(htmlCode);
        
        return `
        <div class="html-viewer" id="${id}">
            <div class="html-viewer-bar">
                <button class="html-viewer-btn active" onclick="Preview.switchView('${id}', 'preview')">
                    <svg class="svg-icon"><use href="#icon-eye"></use></svg> Preview
                </button>
                <button class="html-viewer-btn" onclick="Preview.switchView('${id}', 'code')">
                    <svg class="svg-icon"><use href="#icon-code"></use></svg> Código
                </button>
                <button class="html-viewer-btn" onclick="Preview.openFullscreen('${id}', '${url.replace(/'/g, "\\'")}')">
                    <svg class="svg-icon"><use href="#icon-maximize"></use></svg> Tela Cheia
                </button>
                <div class="mobile-toggle">
                    <button class="html-viewer-btn" onclick="Preview.toggleMobile('${id}')">
                        <svg class="svg-icon"><use href="#icon-eye"></use></svg> Mobile
                    </button>
                </div>
            </div>
            <div class="html-viewer-content">
                <iframe src="${url}" sandbox="allow-scripts allow-popups"></iframe>
                <div class="html-viewer-code"><pre><code class="language-html">${codeEscaped}</code></pre></div>
            </div>
        </div>`;
    },

    switchView(id, mode) {
        const container = document.getElementById(id);
        if(!container) return;
        
        if(mode === 'code') {
            container.classList.add('show-code');
        } else {
            container.classList.remove('show-code');
        }
        
        // Atualiza botões ativos
        container.querySelectorAll('.html-viewer-btn').forEach(b => b.classList.remove('active'));
        event.currentTarget.classList.add('active');
    },

    openFullscreen(id, url) {
        const container = document.getElementById(id);
        if(!container) return;
        
        // Modo tela cheia
        container.classList.add('fullscreen');
        container.querySelector('iframe').src = url;
        
        // Botão para sair
        const bar = container.querySelector('.html-viewer-bar');
        const exitBtn = document.createElement('button');
        exitBtn.className = 'html-viewer-btn';
        exitBtn.innerHTML = '<svg class="svg-icon"><use href="#icon-restore"></use></svg> Sair';
        exitBtn.onclick = () => {
            container.classList.remove('fullscreen');
            exitBtn.remove();
        };
        bar.appendChild(exitBtn);
    },

    toggleMobile(id) {
        const container = document.getElementById(id);
        if(!container) return;
        
        container.classList.toggle('mobile');
        
        // Atualiza botão mobile
        const btn = event.currentTarget;
        if(container.classList.contains('mobile')) {
            btn.innerHTML = '<svg class="svg-icon"><use href="#icon-eye"></use></svg> Desktop';
        } else {
            btn.innerHTML = '<svg class="svg-icon"><use href="#icon-eye"></use></svg> Mobile';
        }
    }
};

const ZipGenerator = {
    async generateZip() {
        try {
            const { default: JSZip } = await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');
            const zip = new JSZip();
            const root = zip.folder("KOBLLUX_INTEGRADO");
            root.folder("00_CORE").file("config.json", JSON.stringify(KODUX, null, 2));
            root.folder("00_CORE").file("timestamp.txt", new Date().toISOString());
            root.folder("01_CYCLES_3x3"); root.folder("02_PARTS"); root.folder("03_REDE"); root.folder("04_EXPORT");
            
            const content = await zip.generateAsync({ type: "blob" });
            const md5 = await this.hash(content, 'MD5');
            const sha = await this.hash(content, 'SHA-256');
            const name = `KOBLLUX_${new Date().toISOString().slice(0,10)}.zip`;
            DownloadUtils.triggerDownload(content, name);
            return { success: true, fileName: name, md5: md5, sha256: sha };
        } catch (e) { return { success: false, error: e.message }; }
    },
    async hash(blob, algo) { const b = await blob.arrayBuffer(); const h = await crypto.subtle.digest(algo, b); return Array.from(new Uint8Array(h)).map(x => x.toString(16).padStart(2,'0')).join(''); }
};

const Utils = {
    copy(btn) { const b = btn.closest('.msg-block'); if(!b)return; navigator.clipboard.writeText(b.innerText.replace("content_copy","").trim()); App.showToast("Copiado"); },
    speak(btn) { const b = btn.closest('.msg-block'); if(!b)return; App.speakText(b.innerText.replace(/<[^>]*>?/gm, '').trim()); },
    edit(btn) { const b = btn.closest('.msg-block'); const t = b.innerText.replace("content_copy","").trim(); document.getElementById('userInput').value = t; b.remove(); App.speakText("Editando"); }
};

/* ---------------------------------------------------------
   MAIN APP CONTROLLER
   --------------------------------------------------------- */
const App = {
    state: { open: false, messages: [], isAutoSolar: true, solarMode: 'night', isProcessing: false, isListening: false, recognition: null },
    
    init() {
        const s = localStorage;
        document.getElementById('apiKeyInput').value = s.getItem(STORAGE.API_KEY) || '';
        
        const baseRole = s.getItem(STORAGE.SYSTEM_ROLE) || 'Você é Dual.';
        if(!baseRole.includes("KODUX")) document.getElementById('systemRoleInput').value = baseRole + `\n[SISTEMA KODUX V7.9]\nArquétipos: ${Object.keys(KODUX.ARQUETIPOS).join(', ')}. Use V.E.E.B.`;
        else document.getElementById('systemRoleInput').value = baseRole;

        document.getElementById('inputUserId').value = s.getItem(STORAGE.USER_ID) || 'Viajante';
        document.getElementById('inputModel').value = s.getItem(STORAGE.MODEL) || 'openai/gpt-oss-20b:free';
        this.state.isAutoSolar = s.getItem(STORAGE.SOLAR_AUTO) !== 'false';
        
        // CORREÇÃO: Força o modo correto na inicialização
        if (this.state.isAutoSolar) this.autoByTime(); else this.setMode(s.getItem(STORAGE.SOLAR_MODE) || 'night');

        this.indexedDB.loadCustomCSS();
        this.indexedDB.loadBackground();
        this.setupVoiceSystem();
        this.bindEvents();
        this.updateUI();
        this.toggleField(false, true); 
        this.renderDeck();
        
        setTimeout(() => this.announce("KOBLLUX V7.9 Visio. Memória Ativa."), 1200);
        if(typeof particlesJS !== 'undefined') particlesJS('particles-js', {particles:{number:{value:30},color:{value:"#ffffff"},opacity:{value:0.5},size:{value:2},line_linked:{enable:true,distance:150,color:"#ffffff",opacity:0.2,width:1}}});
    },

    // --- VOZ ---
    setupVoiceSystem() {
        if (!('webkitSpeechRecognition' in window)) return;
        this.state.recognition = new webkitSpeechRecognition();
        this.state.recognition.lang = 'pt-BR';
        this.state.recognition.continuous = true; 
        this.state.recognition.interimResults = true;
        this.state.recognition.onstart = () => { this.state.isListening = true; document.getElementById('btnVoice').classList.add('listening'); this.showToast("🎙️ Voz Ativa..."); };
        this.state.recognition.onend = () => { if (this.state.isListening) try { this.state.recognition.start(); } catch(e){} else document.getElementById('btnVoice').classList.remove('listening'); };
        this.state.recognition.onresult = (e) => { let t=''; for(let i=e.resultIndex;i<e.results.length;++i) t+=e.results[i][0].transcript; document.getElementById('userInput').value=t; };
        this.state.recognition.onerror = (e) => { if(e.error!=='no-speech') { this.state.isListening=false; document.getElementById('btnVoice').classList.remove('listening'); } };
    },
    toggleVoice() {
        if (!this.state.recognition) return;
        if (this.state.isListening) { this.state.isListening = false; this.state.recognition.stop(); }
        else { window.speechSynthesis.cancel(); document.getElementById('userInput').value = ''; try { this.state.recognition.start(); } catch(e){} }
    },

    // --- UPLOAD ---
    setupFileUpload() {
        const input = document.getElementById('fileUploadInput');
        document.getElementById('btnUploadFile').onclick = () => input.click();
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const preview = document.getElementById('filePreview');
            preview.querySelector('.file-info span').textContent = file.name;
            preview.classList.add('active');
            preview.querySelector('.file-actions').innerHTML = `<button class="btn-preview" onclick="App.cancelUpload()">✕</button><button class="btn-preview primary" onclick="App.confirmUpload('${file.name}')">Assimilar</button>`;
        };
    },
    cancelUpload() { document.getElementById('filePreview').classList.remove('active'); document.getElementById('fileUploadInput').value = ''; },
    async confirmUpload(fileName) {
        const file = document.getElementById('fileUploadInput').files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = async (e) => {
            const content = e.target.result;
            const previewHTML = await Preview.renderPreview(file);
            const size = (file.size/1024/1024).toFixed(2);
            this.addFileMessage(file, previewHTML, size);
            const fractal = await KoblluxCore.process(content);
            this.addMessage('system', `Memória Fractal: ${fileName}\n${fractal.log}`);
            this.state.messages.push({ role: 'user', content: `[ARQUIVO: ${fileName}]\n[TRINITY: ${JSON.stringify(fractal.trinity)}]\n${content}\n[SELO: ${fractal.seal}]` });
            this.cancelUpload();
        };
        reader.readAsText(file);
    },
    addFileMessage(file, previewHTML, sizeMB) {
        const c = document.getElementById('chat-container');
        const d = document.createElement('div');
        d.className = 'msg-block file-msg ai';
        d.innerHTML = `<div class="file-header"><strong>${file.name}</strong><span class="file-meta">${sizeMB} MB • ${file.type}</span></div>${previewHTML}<div class="msg-tools"><button class="tool-btn" onclick="DownloadUtils.triggerDownload(new Blob(['${file.name}']), '${file.name}')">📥 Baixar</button></div>`;
        c.appendChild(d); c.scrollTop = c.scrollHeight;
    },

    // --- CHAT ---
    async handleSend() {
        const input = document.getElementById('userInput');
        const txt = input.value.trim();
        if (!txt || this.state.isProcessing) return;

        if(txt.toLowerCase() === '/atlas') {
            input.value = ''; this.addMessage('user', txt);
            let rep = "### ♾️ ATLAS KODUX\n";
            for(const [k,v] of Object.entries(KODUX.ARQUETIPOS)) rep+=`- **${k}**: ${v.Essencia}\n`;
            this.addMessage('ai', rep); return;
        }
        if(txt.toLowerCase() === '/zip') {
            input.value = ''; this.addMessage('user', txt);
            this.addMessage('system', "Gerando KOBLLUX...");
            const res = await ZipGenerator.generateZip();
            this.addMessage('system', res.success ? `✅ Pacote: ${res.fileName}\nSHA: ${res.sha256}` : `❌ Erro: ${res.error}`);
            return;
        }

        const fractal = await KoblluxCore.process(txt);
        input.value = '';
        this.addMessage('user', txt);
        this.state.isProcessing = true;
        document.getElementById('field-toggle-handle').innerHTML = `<span class="footer-dot pulse"></span> ${getRandomText(FOOTER_TEXTS.loading)}`;
        
        const key = localStorage.getItem(STORAGE.API_KEY);
        if (!key && !document.getElementById('inputModel').value.includes(':free')) { this.announce("Erro: API Key."); this.state.isProcessing = false; return; }

        try {
            document.body.classList.add('loading');
            const res = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${key}`, 'Content-Type': 'application/json', 'HTTP-Referer': location.origin },
                body: JSON.stringify({
                    model: document.getElementById('inputModel').value,
                    messages: [ 
                        { role: 'system', content: document.getElementById('systemRoleInput').value },
                        ...this.state.messages.slice(-10).map(m => ({ role: m.role, content: m.content })),
                        { role: 'user', content: `${txt}\n\n[KOBLLUX]\nUNO:${fractal.trinity.UNO}\nSELO:${fractal.seal}` } 
                    ]
                })
            });
            const data = await res.json();
            const aiContent = data.choices?.[0]?.message?.content || "Sem sinal.";
            
            // DETECTAR SE É HTML PURO PARA O VISUALIZADOR
            if (/^\s*(<!doctype html|<html)/i.test(aiContent)) {
               this.addHTMLViewer(aiContent);
               // Adiciona ao histórico sem renderizar de novo
               this.state.messages.push({ role: 'assistant', content: aiContent });
            } else {
               this.addMessage('ai', aiContent);
            }
            
        } catch (e) { this.announce("Erro conexão."); } 
        finally { document.body.classList.remove('loading'); this.state.isProcessing = false; this.toggleField(this.state.open, true); }
    },

    addMessage(role, text) {
        const c = document.getElementById('chat-container');
        const d = document.createElement('div'); d.className = `msg-block ${role}`; d.dataset.raw = text||'';
        
        let html = role==='ai' ? marked.parse(text) : text.replace(/\n/g, '<br>');
        
        if(role !== 'system') {
            html += `<div class="msg-tools">
                <button class="tool-btn" onclick="Utils.copy(this)" title="Copiar"><svg><use href="#icon-copy"></use></svg></button>
                <button class="tool-btn" onclick="Utils.speak(this)" title="Ouvir"><svg><use href="#icon-mic"></use></svg></button>
                ${role === 'ai' ? `
                  <button class="tool-btn" onclick="DownloadUtils.downloadMessage(this)" title="Baixar"><svg><use href="#icon-download"></use></svg></button>
                  <button class="tool-btn" onclick="DownloadUtils.openSandbox(this)" title="Sandbox"><svg><use href="#icon-sandbox"></use></svg></button>
                  <button class="tool-btn" onclick="DownloadUtils.exportPdf(this)" title="PDF"><svg><use href="#icon-pdf"></use></svg></button>` : 
                  `<button class="tool-btn" onclick="Utils.edit(this)" title="Editar"><svg><use href="#icon-edit"></use></svg></button>`}
            </div>`;
            this.state.messages.push({ role: role==='ai'?'assistant':'user', content: text });
        }
        d.innerHTML = html;
        if (role === 'ai') d.querySelectorAll('pre').forEach(pre => { 
            const btn = document.createElement('button'); btn.className = 'copy-code-btn'; btn.textContent = 'Copiar'; 
            btn.onclick = () => { navigator.clipboard.writeText(pre.querySelector('code').innerText); btn.textContent='Copiado!'; setTimeout(()=>btn.textContent='Copiar',2000); };
            pre.appendChild(btn); 
        });
        c.appendChild(d); c.scrollTop = c.scrollHeight;
    },
    
    // VISUALIZADOR HTML
    addHTMLViewer(htmlContent) {
        const c = document.getElementById('chat-container');
        const d = document.createElement('div'); d.className = `msg-block ai`;
        const viewerHTML = Preview.createHtmlViewer(htmlContent);
        d.innerHTML = `<div>HTML Gerado:</div>${viewerHTML}<div class="msg-tools"><button class="tool-btn" onclick="Utils.copy(this)"><svg><use href="#icon-copy"></use></svg></button></div>`;
        c.appendChild(d); c.scrollTop = c.scrollHeight;
    },

    /* --- GERAL --- */
    speakText(text) { if (!text || this.state.isListening) return; window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(text); u.lang='pt-BR'; u.rate=1.1; window.speechSynthesis.speak(u); },
    announce(msg) { this.showToast(msg); },
    showToast(msg, err=false) { const t = document.getElementById('nv-toast'); t.textContent=msg; t.style.borderLeft=err?'4px solid #f44':'4px solid var(--primary)'; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),3000); this.speakText(msg); },
    
    // CORREÇÃO VISUAL: CICLOS SOLARES
    setMode(m) { 
        this.state.solarMode=m; 
        document.body.classList.remove('mode-day', 'mode-sunset', 'mode-night');
        document.body.classList.add(`mode-${m}`); 
        this.updateUI(); 
        localStorage.setItem(STORAGE.SOLAR_MODE, m); 
    },
    cycleSolar() { const n = this.state.solarMode==='day'?'sunset':(this.state.solarMode==='sunset'?'night':'day'); this.state.isAutoSolar=false; this.setMode(n); },
    enableAutoSolar() { this.state.isAutoSolar=true; this.autoByTime(); this.announce("Auto Solar"); },
    autoByTime() { const h=new Date().getHours(); this.setMode((h>=6&&h<17)?'day':(h>=17&&h<19)?'sunset':'night'); },
    updateUI() { 
        document.getElementById('statusSolarMode').textContent = `${this.state.solarMode.toUpperCase()} ${this.state.isAutoSolar ? '(AUTO)' : '(MAN)'}`; 
        document.getElementById('usernameDisplay').textContent = document.getElementById('inputUserId').value; 
    },
    toggleField(f,s) { this.state.open = f!==undefined?f:!this.state.open; document.getElementById('chat-container').classList.toggle('collapsed', !this.state.open); document.body.classList.toggle('field-closed', !this.state.open); if(!s) this.speakText(getRandomText(FOOTER_TEXTS[this.state.open?'open':'closed']['ritual'])); },
    
    // CORREÇÃO CRISTALIZAÇÃO (DECK)
    async crystallizeSession() {
        if(this.state.messages.length === 0) { this.announce("Vazio não cristaliza."); return; }
        const title = this.state.messages.find(m => m.role === 'user')?.content.substring(0, 30) || "Memória Sem Nome";
        await this.indexedDB.saveDeckItem({ id: Date.now(), date: new Date().toLocaleString(), title: title + "...", data: [...this.state.messages] });
        await this.renderDeck(); // Força render
        this.announce("Memória Salva.");
        if(!document.getElementById('drawerDeck').classList.contains('open')) toggleDrawer('drawerDeck');
    },
    
    async renderDeck() {
        const items = await this.indexedDB.getDeck();
        const container = document.getElementById('deckList');
        if(!items || items.length === 0) {
            container.innerHTML = '<div style="text-align:center;color:var(--text-muted);margin-top:20px">O vazio reina aqui.<br>Use o botão 💎 para salvar.</div>';
            return;
        }
        container.innerHTML = items.sort((a,b) => b.id - a.id).map(item => `
            <div class="deck-item">
                <div class="deck-info" style="cursor:pointer" onclick="App.restoreMemory(${item.id})">
                    <h4>${item.title}</h4>
                    <span>${item.date} • ${item.data.length} msgs</span>
                </div>
                <button class="tool-btn" style="color:var(--danger)" onclick="App.deleteMemory(${item.id})"><svg><use href="#icon-trash"></use></svg></button>
            </div>
        `).join('');
    },
    
    async restoreMemory(id) {
        const items = await this.indexedDB.getDeck();
        const item = items.find(i => i.id === id);
        if(item) {
            document.getElementById('chat-container').innerHTML = ''; // Limpa tela
            this.state.messages = []; // Limpa estado
            item.data.forEach(msg => {
                // Não adiciona no estado aqui, pois addMessage já faz isso se não for system
                // Mas precisamos evitar duplicação no estado se usarmos addMessage
                // Então renderizamos direto e populamos o estado manualmente
                this.addMessage(msg.role === 'assistant' ? 'ai' : 'user', msg.content);
            });
            // Ajuste fino para não duplicar estado (o addMessage já popula)
            // Apenas removemos as últimas duplicatas geradas pelo loop acima se necessário
            // (Mas como limpamos this.state.messages antes, está OK).
            
            toggleDrawer('drawerDeck');
            this.announce("Memória restaurada.");
        }
    },
    
    async deleteMemory(id) {
        if(confirm("Fragmentar cristal?")) {
            await this.indexedDB.deleteDeckItem(id);
            this.renderDeck();
        }
    },

    bindEvents() {
        document.getElementById('btnSend').onclick=()=>this.handleSend();
        document.getElementById('userInput').onkeypress=(e)=>{if(e.key==='Enter')this.handleSend()};
        document.getElementById('field-toggle-handle').onclick=()=>this.toggleField();
        document.getElementById('orbToggle').onclick=()=>{toggleDrawer('drawerProfile');this.speakText("Cockpit");};
        
        // EVENTOS CORRIGIDOS
        document.getElementById('btnCrystallize').onclick = () => this.crystallizeSession();
        document.getElementById('btnCycleSolar').onclick = () => this.cycleSolar();
        document.getElementById('btnAutoSolar').onclick = () => this.enableAutoSolar();
        
        document.getElementById('inputUserId').onchange=(e)=>{localStorage.setItem(STORAGE.USER_ID,e.target.value);this.updateUI();};
        document.getElementById('btnSaveConfig').onclick=()=>{localStorage.setItem(STORAGE.API_KEY,document.getElementById('apiKeyInput').value);localStorage.setItem(STORAGE.SYSTEM_ROLE,document.getElementById('systemRoleInput').value);this.indexedDB.saveCustomCSS(document.getElementById('customCssInput').value);toggleDrawer('drawerSettings');this.announce("Salvo");};
        document.getElementById('bgUploadInput').onchange=(e)=>this.indexedDB.handleBackgroundUpload(e.target.files[0]);
        document.getElementById('btnSettings').onclick=()=>toggleDrawer('drawerSettings');
        document.getElementById('btnDeck').onclick=()=>{ toggleDrawer('drawerDeck'); this.renderDeck(); }; // Garante render ao abrir
        document.getElementById('btnClearCss').onclick=()=>this.indexedDB.clearAsset(STORAGE.CUSTOM_CSS);
        document.getElementById('btnVoice').onclick=()=>this.toggleVoice();
        this.setupFileUpload();
    },

    indexedDB: {
        async getDB() { return new Promise((r,j)=>{const q=indexedDB.open("InfodoseDB",2);q.onupgradeneeded=e=>{const d=e.target.result;if(!d.objectStoreNames.contains('assets'))d.createObjectStore('assets',{keyPath:'id'});if(!d.objectStoreNames.contains('deck'))d.createObjectStore('deck',{keyPath:'id'});};q.onsuccess=e=>r(e.target.result);q.onerror=j;}); },
        async putAsset(i,d){(await this.getDB()).transaction(['assets'],'readwrite').objectStore('assets').put({id:i,...d});},
        async getAsset(i){return new Promise(async r=>(await this.getDB()).transaction(['assets']).objectStore('assets').get(i).onsuccess=e=>r(e.target.result));},
        async clearAsset(i){(await this.getDB()).transaction(['assets'],'readwrite').objectStore('assets').delete(i); if(i===STORAGE.CUSTOM_CSS)document.getElementById('custom-styles').textContent=''; if(i===STORAGE.BG_IMAGE)document.getElementById('bg-fake-custom').style.backgroundImage='';},
        async handleBackgroundUpload(f){if(!f)return;await this.putAsset(STORAGE.BG_IMAGE,{blob:f});this.loadBackground();},
        async loadBackground(){const d=await this.getAsset(STORAGE.BG_IMAGE);if(d?.blob)document.getElementById('bg-fake-custom').style.backgroundImage=`url('${URL.createObjectURL(d.blob)}')`;},
        async saveCustomCSS(c){await this.putAsset(STORAGE.CUSTOM_CSS,{css:c});this.loadCustomCSS();},
        async loadCustomCSS(){const d=await this.getAsset(STORAGE.CUSTOM_CSS);if(d?.css){document.getElementById('custom-styles').textContent=d.css;document.getElementById('customCssInput').value=d.css;}},
        async saveDeckItem(i){(await this.getDB()).transaction(['deck'],'readwrite').objectStore('deck').put(i);},
        async getDeck(){return new Promise(async r=>(await this.getDB()).transaction(['deck']).objectStore('deck').getAll().onsuccess=e=>r(e.target.result));},
        async deleteDeckItem(i){(await this.getDB()).transaction(['deck'],'readwrite').objectStore('deck').delete(i);}
    }
};

function toggleDrawer(id) { document.getElementById(id).classList.toggle('open'); }
window.onload = () => App.init();
</script><script id="TEXT_BEAUTY_V3_SCRIPT">
(()=>{'use strict';
if(window.__TEXT_BEAUTY_V3__) return; window.__TEXT_BEAUTY_V3__=true;

/* Utilitários */
const $=(s,r=document)=>r.querySelector(s);
const $$=(s,r=document)=>[...r.querySelectorAll(s)];
const esc=(s)=>s.replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));

/* 0) Toggle edição rápida */
let EDIT_ON=false;
const toggleEdit=()=>{
  EDIT_ON=!EDIT_ON;
  document.body.toggleAttribute('data-edit', EDIT_ON);
  const host = document.getElementById('CONTENT') || document.querySelector('main, article, .render, .reader, body');
  if(host) host.contentEditable = EDIT_ON ? 'plaintext-only' : 'false';
};
document.addEventListener('keydown',e=>{
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='e'){ e.preventDefault(); toggleEdit(); }
});

/* 1) Key:Value negrito (palavra:) + parênteses + chips [ ]
   - roda apenas em blocos de texto (p, li) e não mexe dentro de code/pre */
const processInline = (root=document)=>{
  const targets = $$('p, li, h1, h2, h3, h4, h5, h6', root).filter(n=>!n.closest('pre, code, .no-beauty'));
  const rxKV = /(^|\s)([A-Za-zÀ-ÿ0-9_]+):(?=\s|$)/g; // Palavra:
  const rxParen = /\(([^\n)]+)\)/g;                  // ( … )
  const rxChip  = /\[\[([^[\]]+)\]\]|\[([^[\]]+)\]/g; // [[a]] | [a]

  for(const el of targets){
    // evita processar múltiplas vezes
    if(el.dataset.inlineProcessed==='1') continue;
    el.dataset.inlineProcessed='1';

    const html = el.innerHTML;
    if(/<pre|<code|contenteditable/i.test(html)) continue;

    let out = html;

    // 1. Palavra:  → <strong>
    out = out.replace(rxKV, (m, sp, key)=> `${sp}<strong class="kv-key">${key}:</strong>`);

    // 2. ( ... )   → span-paren
    out = out.replace(rxParen, (m, inside)=> `<span class="span-paren">(${inside})</span>`);

    // 3. [ ... ] / [[ ... ]]  → chip/chip-btn
    out = out.replace(rxChip, (m, dbl, sgl)=>{
      const label = (dbl||sgl||'').trim();
      return `<span class="${dbl?'chip-btn':'chip'}" data-chip="${esc(label)}">${esc(label)}</span>`;
    });

    el.innerHTML = out;
  }
};

/* 2) Perguntas → .q-card (frases que terminam com '?') */
const processQuestions=(root=document)=>{
  const paras = $$('p', root).filter(n=>!n.closest('.q-card, pre, code, .no-beauty'));
  for(const p of paras){
    const txt = (p.innerText||'').trim();
    if(txt.endsWith('?') && !p.dataset.qProcessed){
      p.dataset.qProcessed='1';
      const wrap=document.createElement('div'); wrap.className='q-card';
      wrap.innerHTML = `<div class="q-ico">?</div><div class="q-body">${esc(txt)}</div>`;
      p.replaceWith(wrap);
    }
  }
};

/* 3) Flow text: melhora texto corrido, cria heading leve se linha for "Algo:" sozinha */
const beautifyFlow=(root=document)=>{
  const container = root.querySelector('.flow-text') || root; // se já tiver classe, usa; senão aplica heurística suave
  $$('p', container).forEach(p=>{
    const t=(p.innerText||'').trim();
    if(/^[^:\n]{3,}:\s*$/.test(t)){ // linha que termina com ":" vira heading leve
      p.classList.add('kv-head');
    }
    // Quebra parágrafos absurdamente longos em dois (heurística)
    if(t.length>600 && t.includes('. ')){
      const mark = t.indexOf('. ', Math.floor(t.length/2));
      if(mark>0){
        const a=t.slice(0, mark+1), b=t.slice(mark+1);
        const p2=p.cloneNode(); p2.textContent=b.trim();
        p.textContent=a.trim();
        p.insertAdjacentElement('afterend', p2);
      }
    }
  });
};

/* 4) Listas copiáveis: badge + click copy */
const enableCopyLists=(root=document)=>{
  const lists = $$('.list-card', root);
  for(const card of lists){
    if(card.querySelector('.copy-badge')) continue;
    const badge = document.createElement('div');
    badge.className='copy-badge'; badge.textContent='copiar';
    card.appendChild(badge);
    card.addEventListener('click', e=>{
      // evita copiar quando clicou em link/botão dentro
      if(e.target.closest('a,button,.chip,.chip-btn')) return;
      const txt = [...card.querySelectorAll('li')].map(li=>li.innerText.trim()).join('\n');
      navigator.clipboard.writeText(txt).then(()=>{
        badge.textContent='copiado!'; setTimeout(()=>badge.textContent='copiar',1200);
      });
    }, {passive:true});
  }
};

/* 5) HTML/SVG pass-through
   - ```html-raw ... ``` → renderiza
   - <div data-raw-html>…(escapado)…</div> → renderiza
*/
const renderRawHTML=(root=document)=>{
  // code fence transform
  $$('pre code', root).forEach(code=>{
    const cls = (code.className||'').toLowerCase();
    if(cls.includes('language-html-raw') || cls.includes('lang-html-raw')){
      const raw = code.textContent;
      const box = document.createElement('div');
      box.className='raw-html-card';
      box.innerHTML = `<div class="raw-note">HTML/SVG renderizado a partir de bloco <code>html-raw</code></div>`;
      const slot = document.createElement('div');
      slot.className='raw-slot';
      // injeta SEM esc, assumindo que o autor confia no conteúdo
      slot.innerHTML = raw;
      box.appendChild(slot);
      const pre = code.closest('pre');
      pre.replaceWith(box);
    }
  });

  // <div data-raw-html>…</div>
  $$('div[data-raw-html]', root).forEach(div=>{
    const raw = div.textContent; // assume texto escapado pelo md
    const box = document.createElement('div'); box.className='raw-html-card';
    const slot = document.createElement('div'); slot.className='raw-slot';
    slot.innerHTML = raw;
    box.appendChild(slot);
    div.replaceWith(box);
  });
};

/* 6) Delegação de cliques para chips (colchetes) */
document.addEventListener('click', e=>{
  const chip = e.target.closest('.chip, .chip-btn');
  if(chip){
    const label = chip.dataset.chip||chip.textContent.trim();
    // dispara um evento customizado para teu bus/orquestrador
    const ev = new CustomEvent('chip:click', {detail:{label, source:'text-beauty-v3'}});
    document.dispatchEvent(ev);
  }
}, {passive:true});

/* 7) Orquestração */
const run=(ctx=document)=>{
  processInline(ctx);
  processQuestions(ctx);
  beautifyFlow(ctx);
  enableCopyLists(ctx);
  renderRawHTML(ctx);
};

if(window.__RENDERBUS__?.on){
  window.__RENDERBUS__.on('after', run, {name:'text-beauty-v3', priority: 96});
}else{
  (document.readyState==='loading') ? document.addEventListener('DOMContentLoaded',()=>run(document)) : run(document);
  new MutationObserver(m=>m.forEach(x=>x.addedNodes&&x.addedNodes.forEach(n=>n.nodeType===1&&run(n))))
    .observe(document.body,{childList:true,subtree:true});
}
})();
</script><script id="TRINITY_OVERRIDE">
/* --- START OF livro_vivo_trinity_override.js (injetado) --- */
/* Conteúdo do seu script TRINITY (TTS / hooks). Autoinit e funções públicas. */
/* O conteúdo abaixo foi copiado do arquivo enviado. */
/* ---------- BEGIN TRINITY SCRIPT ---------- */
(function(){
  if(window.TrinityTTS && window.TrinityTTS.__loaded) return;
  window.TrinityTTS = window.TrinityTTS || {};
  window.TrinityTTS.__loaded = true;

  // Implementação simplificada das funções principais esperadas pelo patch:
  window.TrinityTTS.injectJokers = function(rootSelector){
    // exemplo: adiciona botões de TTS em .msg-block.ai
    const root = rootSelector ? document.querySelector(rootSelector) : document;
    if(!root) return;
    root.querySelectorAll('.msg-block.ai').forEach(block=>{
      if(block.dataset.trinityAttached) return;
      const btn = document.createElement('button');
      btn.className = 'tool-btn';
      btn.title = 'Ler com Trinity';
      btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 1v22"/></svg>';
      btn.onclick = ()=> {
        const text = block.dataset.raw || block.innerText || '';
        // voice speak simple fallback (uses speechSynthesis)
        try{
          const ut = new SpeechSynthesisUtterance(text.replace(/<[^>]*>/g,''));
          ut.lang = 'pt-BR'; ut.rate = 1.05;
          speechSynthesis.cancel(); speechSynthesis.speak(ut);
        }catch(e){ console.warn('[Trinity] speak failed', e); }
      };
      // insert at beginning of .msg-tools if exists, else append
      const tools = block.querySelector('.msg-tools');
      if(tools) tools.insertBefore(btn, tools.firstChild);
      else block.appendChild(btn);
      block.dataset.trinityAttached = '1';
    });
  };

  window.TrinityTTS.attachPlayable = function(rootSelector){
    // placeholder: could attach audio players if available
    return window.TrinityTTS.injectJokers(rootSelector);
  };

  // auto-init on event
  document.addEventListener('infodx:rendered', (e)=>{
    try{ window.TrinityTTS.injectJokers('#chat-container'); }catch(e){}
  });

  // expose simple API to speak raw text
  window.TrinityTTS.speak = function(text, opts={}){
    try{
      const u = new SpeechSynthesisUtterance(String(text || ''));
      u.lang = opts.lang || 'pt-BR'; u.rate = opts.rate || 1.0;
      window.speechSynthesis.cancel(); window.speechSynthesis.speak(u);
    }catch(e){ console.warn(e); }
  };

})();
 /* ---------- END TRINITY SCRIPT ---------- */
</script><script id="INFODOX_EMBED_LOADER">
(function(){
  'use strict';
  // 1) Emit event once on DOMContentLoaded (already mostly handled), and provide a fallback observer
  function fireRendered(node){
    document.dispatchEvent(new CustomEvent('infodx:rendered', { detail: { node: node || document } }));
  }

  document.addEventListener('DOMContentLoaded', ()=> setTimeout(()=>fireRendered(document), 80));

  // MutationObserver to catch dynamic chat renders
  const mo = new MutationObserver((mut)=>{
    for(const m of mut){
      if(!m.addedNodes) continue;
      for(const n of m.addedNodes){
        if(n.nodeType!==1) continue;
        // if new message nodes are appended, trigger beauty+trinity
        if(n.matches && (n.matches('.msg-block') || n.querySelector && n.querySelector('.msg-block'))){
          fireRendered(n);
        }
      }
    }
  });
  mo.observe(document.getElementById('chat-container') || document.body, { childList: true, subtree: true });

  // 2) Try to run the exposed functions if available
  function runPostRender(node){
    try{
      if(window.__TEXT_BEAUTY_V3_RUN__) window.__TEXT_BEAUTY_V3_RUN__(node ? (node.nodeType===1 ? null : null) : null);
      if(window.__TEXT_BEAUTY_V3__) {
        window.__TEXT_BEAUTY_V3__.processInline(document);
        window.__TEXT_BEAUTY_V3__.processQuestions(document);
        window.__TEXT_BEAUTY_V3__.beautifyFlow(document);
        window.__TEXT_BEAUTY_V3__.enableCopyLists(document);
        window.__TEXT_BEAUTY_V3__.renderRawHTML(document);
      }
      if(window.TrinityTTS && typeof window.TrinityTTS.injectJokers === 'function'){
        window.TrinityTTS.injectJokers('#chat-container');
      }
    }catch(e){ console.warn('[INFODOX_EMBED_LOADER] post render error', e); }
  }

  document.addEventListener('infodx:rendered', (e)=> {
    runPostRender(e && e.detail ? e.detail.node : document);
  });

  // 3) expose manual helper
  window.Infodox = window.Infodox || {};
  window.Infodox.runAll = function(rootSelector){
    try{
      const root = rootSelector ? document.querySelector(rootSelector) : document;
      if(window.__TEXT_BEAUTY_V3_RUN__) window.__TEXT_BEAUTY_V3_RUN__(rootSelector);
      if(window.__TEXT_BEAUTY_V3__) {
        window.__TEXT_BEAUTY_V3__.processInline(root);
        window.__TEXT_BEAUTY_V3__.processQuestions(root);
        window.__TEXT_BEAUTY_V3__.beautifyFlow(root);
        window.__TEXT_BEAUTY_V3__.enableCopyLists(root);
        window.__TEXT_BEAUTY_V3__.renderRawHTML(root);
      }
      if(window.TrinityTTS) window.TrinityTTS.injectJokers(rootSelector || '#chat-container');
      console.info('[Infodox.runAll] executed');
    }catch(e){ console.warn(e); }
  };

  // 4) small UX hint
  console.info('[INFODOX PATCH] Beauty.v3 + Trinity loaded. Use Infodox.runAll() to manually trigger.');
})();
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script><script>
const $=(q,r=document)=>r.querySelector(q), $$=(q,r=document)=>[...r.querySelectorAll(q)];
const toast=(m)=>{const t=document.createElement('div');t.className='toast';t.textContent=m;document.body.querySelector('#toasts').appendChild(t);setTimeout(()=>t.remove(),2000)}
/* Reading */
function toggleReading(force){const el=document.documentElement; const will = typeof force==='boolean'? force : !el.classList.contains('reading'); el.classList.toggle('reading', will); localStorage.setItem('tl_reading', will?'1':'0'); toast(will?'Modo leitura':'Modo editor');}
document.getElementById('btn-reading').onclick=()=> toggleReading();
document.getElementById('read-exit').onclick=()=> toggleReading(false);
window.addEventListener('keydown',(e)=>{ if(e.key==='Escape') toggleReading(false); if(e.key.toLowerCase()==='r') toggleReading(); if(e.key.toLowerCase()==='t') cycleTheme(); });
/* Theme cycle */
const THEMES=['blue','gold','thermal'];
function setTheme(name){document.documentElement.classList.remove('theme-gold','theme-thermal'); if(name==='gold') document.documentElement.classList.add('theme-gold'); if(name==='thermal') document.documentElement.classList.add('theme-thermal'); localStorage.setItem('tl_theme',name); updateThemeLabel();}
function currentTheme(){return localStorage.getItem('tl_theme')||'blue'} function updateThemeLabel(){const map={blue:'Blue‑1',gold:'Gold',thermal:'Thermal'}; document.getElementById('btn-theme').textContent='Tema: '+map[currentTheme()];}
function cycleTheme(){const i=(THEMES.indexOf(currentTheme())+1)%THEMES.length; setTheme(THEMES[i]); toast('Tema: '+(THEMES[i]==='blue'?'Blue‑1':THEMES[i]==='gold'?'Gold':'Thermal'));}
document.getElementById('btn-theme').onclick=cycleTheme;
/* FAB & Tabs */
document.getElementById('fab-toggle').onclick=()=> document.getElementById('fab').classList.toggle('open');
document.getElementById('btn-imp').onclick=()=> openImporter(); document.getElementById('btn-pdf').onclick=()=> window.print();
function openImporter(){document.getElementById('imp').style.display='block'} function closeImporter(){document.getElementById('imp').style.display='none'}
document.querySelectorAll('.tab').forEach(t=>t.onclick=()=>{document.querySelectorAll('.tab,.tab-content').forEach(e=>e.classList.remove('active'));t.classList.add('active');document.getElementById('tab-'+t.dataset.tab).classList.add('active')})
/* Audio */
let rec;if('webkitSpeechRecognition' in window||'SpeechRecognition' in window){const SR=window.SpeechRecognition||window.webkitSpeechRecognition;rec=new SR();rec.lang='pt-BR';rec.continuous=true;rec.interimResults=true;rec.onresult=(e)=>{let txt='';for(let i=e.resultIndex;i<e.results.length;++i)txt+=e.results[i][0].transcript+(e.results[i].isFinal?'. ':'');document.getElementById('audioOutput').value=txt;};rec.onerror=()=>toast('Erro/Permissão negada');}else toast('STT não suportado.');
document.getElementById('startRec').onclick=()=>{try{rec.start();toast('Gravando...')}catch{toast('Não suportado')}};document.getElementById('stopRec').onclick=()=>{try{rec.stop();toast('Parado')}catch{}}
/* Files */

// Removed explicit onclick handler: md button is handled via data-action="md" and window.exportMD
// Legacy duplicate export function retained for reference but unused
function exportMD_deprecated(){
  const parts=[];
  document.querySelectorAll('#root details.acc').forEach(d=>{
    const h=d.querySelector('summary h2'); if(h) parts.push('# '+h.textContent.trim());
    d.querySelectorAll('.sec > *').forEach(node=>{
      if(node.matches('p')) parts.push(node.innerText.trim());
      else if(node.matches('blockquote')) parts.push('> '+node.innerText.replace('Copiar','').trim());
      else if(node.matches('pre.md-code')) parts.push('```\n'+(node.querySelector('code')?.textContent||'')+'\n```');
      else if(node.matches('.equation')) parts.push('$$\n'+node.innerText.replace('Copiar','').trim()+'\n$$');
      else if(node.matches('ul.md-task')){
        node.querySelectorAll('li').forEach(li=>{
          const chk=li.querySelector('input[type=checkbox]'); const t=li.innerText.replace('Copiar','').trim();
          parts.push(`- [${chk&&chk.checked?'x':' '}] ${t}`);
        });
      }else if(node.matches('ul,ol')){
        const isOl=node.matches('ol'); let idx=1;
        node.querySelectorAll('li').forEach(li=>{
          const txt=li.innerText.trim();
          parts.push((isOl? (idx++)+'. ' : '- ')+txt);
        });
      }else if(node.matches('table.md-table')){
        const rows=[...node.querySelectorAll('tr')].map(tr=>[...tr.children].map(td=>td.innerText.trim()));
        if(rows.length){
          parts.push('| '+rows[0].join(' | ')+' |');
          parts.push('| '+rows[0].map(()=> '---').join(' | ')+' |');
          rows.slice(1).forEach(r=>parts.push('| '+r.join(' | ')+' |'));
        }
      }
    });
  });
  const blob=new Blob([parts.join('\n\n')],{type:'text/markdown'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='export.md'; a.click(); URL.revokeObjectURL(a.href);
  toast('.md exportado');
}

document.getElementById('fileInput').addEventListener('change',async e=>{const f=e.target.files[0];if(!f)return;document.getElementById('filePreview').textContent='Lendo '+f.name+'...'; if(f.name.endsWith('.pdf')){const buf=await f.arrayBuffer();const pdf=await pdfjsLib.getDocument({data:buf}).promise;let txt='';for(let i=1;i<=pdf.numPages;i++){const p=await pdf.getPage(i);const c=await p.getTextContent();txt+=c.items.map(it=>it.str).join(' ')+'\n';}autoBuild(txt);} else {autoBuild(await f.text());}});
/* Builder */


/* Builder (Markdown+ → DOM com seções) */

function autoBuild(text){
  closeImporter();
  const root = document.getElementById('root');
  root.innerHTML = '';

  const AUTO_SPLIT_EVERY = 14;
  let sectionCount = 0, blocksInSection = 0;
  let sec = null;

  function newSection(title){
    sectionCount++;
    const details = document.createElement('details');
    details.className = 'acc';
    details.open = false;
    const sum = document.createElement('summary');
    sum.innerHTML = '<span class="chev"></span><h2>'+ (title || ('Seção '+sectionCount)) +'</h2>';
    const cont = document.createElement('div'); cont.className = 'sec';
    details.append(sum, cont);
    root.appendChild(details);
    blocksInSection = 0;
    return details;
  }
  function ensureSection(titleIfNew){
    if(!sec) sec = newSection(titleIfNew||'Seção 1');
    if(blocksInSection >= AUTO_SPLIT_EVERY){
      sec = newSection((getSummary(sec)+' (cont.)'));
    }
    return sec;
  }
  function getSummary(details){
    const h = details.querySelector('summary h2');
    return h ? h.textContent : 'Seção';
  }
  function appendToSection(el){ ensureSection(); sec.lastChild.appendChild(el); blocksInSection++; }

  const lines = text.replace(/\r\n?/g,'\n').split('\n');
  let i = 0, inCode = false, codeLang = '', buf = [];
  let inFn = false, fnDepth = 0;

  const flushParagraph = ()=>{
    if(!buf.length) return;
    const content = buf.join(' ').trim();
    if(/^\s*(?:export\s+)?function\s+\w+\s*\([^)]*\)\s*\{[^]*\}\s*$/.test(content)){
      const div = document.createElement('div');
      div.className = 'equation copyable fn';
      div.innerHTML = '<span class="copy-hint">Copiar</span>' + content;
      div.onclick = ()=>copy(div);
      appendToSection(div);
      buf.length = 0;
      return;
    }
    const p = document.createElement('p');
    p.innerHTML = inlineMD(content);
    appendToSection(p);
    buf.length = 0;
  };

  while(i < lines.length){
    let line = lines[i];
    let norm = line.replace(/[’‘]/g, "'");

    // cercas de código: ``` e '''
    const mFenceOpen = norm.match(/^\s*(?:```|''')([\w-]+)?\s*$/);
    if(!inCode && mFenceOpen){
      flushParagraph();
      inCode = true; codeLang = (mFenceOpen[1]||'').toLowerCase();
      i++; continue;
    }
    if(inCode){
      const mFenceClose = norm.match(/^\s*(?:```|''')+\s*$/);
      if(mFenceClose){
        const pre = document.createElement('pre');
        pre.className = 'md-code copyable';
        const hint = document.createElement('span'); hint.className = 'copy-hint'; hint.textContent = 'Copiar';
        const code = document.createElement('code');
        if(codeLang) code.className = 'lang-'+codeLang;
        code.textContent = buf.join('\n');
        pre.append(hint, code);
        pre.onclick = ()=>copy(pre);
        appendToSection(pre);
        buf.length = 0; inCode = false; codeLang = '';
      }else{
        buf.push(line);
      }
      i++; continue;
    }

    // função JS multi-linha sem cercas
    if(!inFn){
      const mFnStart = norm.match(/^\s*(?:export\s+)?function\s+\w+\s*\([^)]*\)\s*\{\s*$/);
      if(mFnStart){
        flushParagraph();
        inFn = true; fnDepth = 1; buf.length = 0; i++; continue;
      }
    }
    if(inFn){
      buf.push(line);
      const open = (line.match(/\{/g) || []).length;
      const close = (line.match(/\}/g) || []).length;
      fnDepth += open - close;
      i++;
      if(fnDepth <= 0){
        const div = document.createElement('div');
        div.className = 'equation copyable fn';
        div.innerHTML = '<span class="copy-hint">Copiar</span>' + escapeHtml(buf.join('\\n'));
        div.onclick = ()=>copy(div);
        appendToSection(div);
        buf.length = 0; inFn = false; fnDepth = 0;
      }
      continue;
    }

    // headings
    const mH = line.match(/^\s*(#{1,6})\s+(.+?)\s*$/);
    if(mH){
      flushParagraph();
      sec = newSection(mH[2].trim());
      i++; continue;
    }

    // hr
    if(/^\s*(?:---|\*\*\*)\s*$/.test(line)){
      flushParagraph();
      const hr = document.createElement('div'); hr.className = 'hr';
      appendToSection(hr); i++; continue;
    }

    // blockquotes aninhados
    if(/^\s*>+/.test(line)){
      flushParagraph();
      const items = [];
      while(i < lines.length && /^\s*>+/.test(lines[i])){
        const m = lines[i].match(/^\s*(>+)\s?(.*)$/);
        items.push({ level: m[1].length, text: m[2] });
        i++;
      }
      const rootBQ = document.createElement('blockquote');
      rootBQ.className = 'bq copyable bq-l1';
      rootBQ.innerHTML = '<span class="copy-hint">Copiar</span>';
      let currentLevel = 1;
      const stack = [rootBQ];
      items.forEach(({level, text})=>{
        while(level > currentLevel){
          const inner = document.createElement('blockquote');
          inner.className = 'bq bq-l' + Math.min(currentLevel+1,3);
          stack[stack.length-1].appendChild(inner);
          stack.push(inner);
          currentLevel++;
        }
        while(level < currentLevel){
          stack.pop();
          currentLevel--;
        }
        const div = document.createElement('div');
        div.className = 'bq-line';
        div.innerHTML = inlineMD(text);
        stack[stack.length-1].appendChild(div);
      });
      rootBQ.onclick = ()=>copy(rootBQ);
      appendToSection(rootBQ);
      continue;
    }

    // callouts estendidos
    const mCallAny = norm.match(/^\s*(::(info|warn|tip|note|success|danger)|::\.|:|\?)\s+(.*)$/i);
    if(mCallAny){
      flushParagraph();
      let kind = 'note';
      if(mCallAny[1] === '::.') kind = 'aside';
      else if(mCallAny[1] === ':') kind = 'note';
      else if(mCallAny[1] === '?') kind = 'question';
      else kind = (mCallAny[2] || 'info').toLowerCase();

      let textBuf = [mCallAny[3]];
      let j = i + 1;
      while (j < lines.length) {
        const nextLine = lines[j];
        const nextNorm = nextLine.replace(/[’‘]/g, "'").trim();
        // stop if blank line or another callout marker encountered
        if (nextNorm === '') break;
        if (/^\s*(::(info|warn|tip|note|success|danger)|::\.|:|\?)\s+/i.test(nextNorm)) break;
        textBuf.push(nextLine.trim());
        j++;
      }
      i = j;
      const div = document.createElement('div');
      div.className = 'callout copyable ' + kind;
      div.innerHTML = '<span class="copy-hint">Copiar</span>' + inlineMD(textBuf.join(' '));
      div.onclick = ()=>copy(div);
      appendToSection(div);
      continue;
    }

    // math $$ … $$
    if(/^\s*\$\$\s*$/.test(line)){
      flushParagraph(); i++;
      let math = '';
      while(i<lines.length && !/^\s*\$\$\s*$/.test(lines[i])){ math += lines[i++] + '\\n'; }
      const eq = document.createElement('div');
      eq.className = 'equation copyable';
      eq.innerHTML = '<span class="copy-hint">Copiar</span>'+ escapeHtml(math.trim());
      eq.onclick = ()=>copy(eq);
      appendToSection(eq);
      if(i<lines.length) i++;
      continue;
    }

    // table
    if(/^\s*\|.*\|\s*$/.test(line)){
      flushParagraph();
      let rows = [ line ];
      while(i+1<lines.length && /^\s*\|.*\|\s*$/.test(lines[i+1])){ rows.push(lines[++i]); }
      const tbl = document.createElement('table'); tbl.className='md-table';
      rows.forEach((r,idx)=>{
        const tr = document.createElement('tr');
        const cells = r.trim().slice(1,-1).split('|').map(c=>c.trim());
        const isSep = (idx===1 && cells.every(x=>/^:?-{3,}:?$/.test(x)));
        if(isSep) return;
        cells.forEach(c=>{
          const cell = document.createElement((idx===0)?'th':'td');
          cell.innerHTML = inlineMD(c);
          tr.appendChild(cell);
        });
        tbl.appendChild(tr);
      });
      appendToSection(tbl); i++; continue;
    }

    // listas
    const mLi = line.match(/^\s*(?:([-*+])\s+|\d+\.\s+)(.+)$/);
    if(mLi){
      flushParagraph();
      const ordered = /^\s*\d+\.\s+/.test(line);
      const list = document.createElement(ordered?'ol':'ul');
      list.className = 'md-list';
      while(i<lines.length){
        const l = lines[i];
        if(!/^\s*(?:[-*+]\s+|\d+\.\s+)/.test(l)) break;
        const raw = l.replace(/^\s*(?:[-*+]\s+|\d+\.\s+)/,'');
        const task = raw.match(/^\s*\[( |x|X)\]\s*(.*)$/);
        const li = document.createElement('li');
        li.className = 'md-li';
        if(task){
          if(!list.classList.contains('md-task')) list.classList.add('md-task');
          const box = document.createElement('input'); box.type='checkbox'; box.checked = /x/i.test(task[1]); box.disabled = true;
          const span = document.createElement('span'); span.innerHTML = inlineMD(task[2]);
          li.append(box, span);
        }else{
          li.innerHTML = inlineMD(raw);
        }
        list.appendChild(li); i++;
      }
      appendToSection(list); continue;
    }

    // parágrafos
    if(line.trim()===''){ flushParagraph(); i++; continue; }
    buf.push(line.trim()); i++;
  }
  flushParagraph();
  toast('Livro gerado!');
}


/* ===== Helpers p/ Markdown inline & util ===== */
function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function autoLink(url){
  try{ const u = new URL(url); return `<a href="${u.href}" target="_blank" rel="noopener">${u.href}</a>`; }catch{return url;}
}

function inlineMD(s){
  s = escapeHtml(s);
  // imagens ![alt](src)
  s = s.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (_,a,src)=>`<img class="md-img" alt="${a}" src="${src}">`);
  // links [txt](url)
  s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (_,t,href)=>`<a href="${href}" target="_blank" rel="noopener">${t}</a>`);
  // inline code
  s = s.replace(/`([^`]+)`/g, (_,c)=> `<code class="code-inline">${c}</code>`);
  // strong + em
  s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  s = s.replace(/(^|[^*])\*([^*]+)\*(?!\*)/g, '$1<em>$2</em>');
  // strike
  s = s.replace(/~~([^~]+)~~/g, '<del>$1</del>');
  // autolink
  s = s.replace(/\bhttps?:\/\/[^\s)]+/g, m => autoLink(m));
  // action buttons: [[btn:act|Label]] and [Label](action:act)
  s = s.replace(/\[\[btn:([a-z0-9_-]+)(?:\|([^\]]+))?\]\]/gi, (_,a,label)=>`<button class="btn action" data-action="${a}">${label?escapeHtml(label):a}</button>`);
  s = s.replace(/\[([^\]]+)\]\(action:([a-z0-9_-]+)\)/gi, (_,label,act)=>`<button class="btn action" data-action="${act}">${escapeHtml(label)}</button>`);
  return s;
}




/* Restore */
(function(){ setTheme(localStorage.getItem('tl_theme')||'blue'); if(localStorage.getItem('tl_reading')==='1') document.documentElement.classList.add('reading'); })();

// ====== TTS (SpeechSynthesis) ======
(function(){
  if(!('speechSynthesis' in window)){ console.warn('SpeechSynthesis não suportado'); return; }
  window.__tts_on = false;
  let __tts_voice = null;
  function pickPTBRVoice(){
    const voices = speechSynthesis.getVoices();
    const cand = voices.find(v => /pt[-_]BR/i.test(v.lang)) || voices.find(v => /pt/i.test(v.lang));
    return cand || voices[0] || null;
  }
  function ensureVoice(){
    if(!__tts_voice){ __tts_voice = pickPTBRVoice(); }
  }
  function speakText(text){
    if(!window.__tts_on) { if(window.toast) toast('Ative a Voz'); return; }
    if(!text || !text.trim()) return;
    ensureVoice();
    speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(text);
    if(__tts_voice) u.voice = __tts_voice;
    u.lang = (__tts_voice && __tts_voice.lang) || 'pt-BR';
    u.rate = 1.0; u.pitch = 1.0; u.volume = 1.0;
    speechSynthesis.speak(u);
  }
  function stopTTS(){ speechSynthesis.cancel(); }
  function getSelectedText(){ return (window.getSelection && String(window.getSelection())) || ''; }
  function setTTS(on){
    window.__tts_on = !!on;
    const b = document.getElementById('btn-tts');
    if(b) b.textContent = 'Voz: ' + (window.__tts_on ? 'On' : 'Off');
    if(window.toast) toast(window.__tts_on ? 'Voz ativada' : 'Voz desativada');
  }
  document.addEventListener('click',(e)=>{
    if(e.target && e.target.id==='btn-tts'){ setTTS(!window.__tts_on); return; }
    if(e.target && e.target.id==='btn-tts-sel'){ const t=getSelectedText(); if(t) speakText(t); else if(window.toast) toast('Selecione um trecho primeiro'); return; }
    if(e.target && e.target.id==='btn-tts-stop'){ stopTTS(); return; }
    if(!window.__tts_on) return;
    const block = e.target.closest('p, li, blockquote, .coach, .callout, .equation, pre, td, th');
    if(!block) return;
    if(e.target.closest('button,a,.emoji-btn,.chip,.btn,#fab,.menu,#ttsDock')) return;
    let text = block.innerText || '';
    text = text.replace('Copiar','').trim();
    if(text) speakText(text);
  });
  if('speechSynthesis' in window){
    speechSynthesis.onvoiceschanged = () => { if(!__tts_voice) __tts_voice = pickPTBRVoice(); };
  }
  window.__tts = { set:setTTS, speak:speakText, stop:stopTTS };
})();
// ====================================

async function copy(el){
  const txt=(el.innerText||'').replace('Copiar','').trim();
  try{ await navigator.clipboard.writeText(txt); toast('Copiado'); }
  catch(e){ console.warn('copy fail', e); }
}

  // Allow pasting clipboard content into the Auto‑Gerar textarea.
  async function pasteSrcText(){
    try{
      const text = await navigator.clipboard.readText();
      const ta = document.getElementById('srcText');
      if(ta){
        ta.value = text || '';
        toast('Colado do clipboard');
      }
    }catch(e){
      console.warn('paste fail', e);
      toast('Falha ao colar');
    }
  }

</script><script id="STORAGE_FORCE_BRUTE_V1">
(()=>{ 'use strict';
const NS_VER = 'infodose::v3::';
const SUSPECT = ['infodose','book','reject','metalux','kodux','livro','tl_','LIVRO_LIB_V','LIVRO_CUR_V'];
function isSuspect(k){ return SUSPECT.some(p=>k.toLowerCase().includes(p)); }
function now(){return new Date().toISOString().replace(/[:.]/g,'-');}
function backupKey(k){
  const v = localStorage.getItem(k);
  if(v!==null){ localStorage.setItem(`backup::${k}::${Date.now()}`, v); }
}
function migrateAndClean(){
  try{
    // Migrate JSON suspect keys into namespaced infodose::v3::<safe>
    const keys = Object.keys(localStorage);
    for(const k of keys){
      if(k.startsWith(NS_VER)) continue;
      if(!isSuspect(k)) continue;
      const raw = localStorage.getItem(k);
      try{
        const val = JSON.parse(raw);
        // save under safe key
        const safeKey = k.replace(/[^a-z0-9]/gi,'_').toLowerCase();
        localStorage.setItem(`${NS_VER}${safeKey}`, JSON.stringify(Object.assign({}, val, {version:3})));
        backupKey(k);
      }catch(e){
        // not JSON, backup then remove
        backupKey(k);
      }
    }
    // Now remove suspect keys that are outside namespace
    for(const k of Object.keys(localStorage)){
      if(k.startsWith(NS_VER)) continue;
      if(isSuspect(k)){
        // Already backed up above; remove to avoid old code pulling it
        localStorage.removeItem(k);
      }
    }
    // Mark done
    localStorage.setItem(`${NS_VER}__migration_done`, now());
    console.info('[FORCE_BRUTE] migration+clean done');
  }catch(e){
    console.error('[FORCE_BRUTE] failed', e);
  }
}
window.addEventListener('DOMContentLoaded', ()=>{
  try{
    const done = localStorage.getItem(`${NS_VER}__migration_done`);
    if(!done){
      // run migration/clean
      migrateAndClean();
      // reload to let app start fresh
      try{ location.reload(); }catch(e){ console.warn('reload failed', e); }
    }
  }catch(e){ console.error(e); }
});
})();

function autoBuildNested(text){
  closeImporter();
  const root = document.getElementById('root');
  root.innerHTML = '';

  const stack = [];
  function newSectionAt(level, title){
    const details = document.createElement('details');
    details.className = 'acc';
    details.open = false;
    const sum = document.createElement('summary');
    sum.innerHTML = '<span class="chev"></span><h2>'+ title +'</h2>';
    const cont = document.createElement('div'); cont.className = 'sec';
    details.append(sum, cont);
    const parentContainer = stack.length ? stack[stack.length-1].container : root;
    parentContainer.appendChild(details);
    stack.push({level, details, container: cont});
  }
  function currentContainer(){ return stack.length ? stack[stack.length-1].container : root; }

  const lines = text.replace(/\r\n?/g,'\n').split('\n');
  let i = 0, inCode = false, codeLang = '', buf = [];
  let inFn = false, fnDepth = 0;
  // RAW HTML inline (iframe, video, etc.) para o builder aninhado
  const RX_RAW_INLINE = /^\s*<\s*(iframe|video|audio|img|figure|div|section|article|embed|object|svg)\b/i;
    const flushParagraph = ()=>{
    if(!buf.length) return;
    const content = buf.join(' ').trim();

    // Bloco de função inteira (continua igual)
    if(/^\s*(?:export\s+)?function\s+\w+\s*\([^)]*\)\s*\{[^]*\}\s*$/.test(content)){
      const div = document.createElement('div');
      div.className = 'equation copyable fn';
      div.innerHTML = '<span class="copy-hint">Copiar</span>' + content;
      div.onclick = ()=>copy(div);
      currentContainer().appendChild(div);
      buf.length = 0;
      return;
    }

    // 🔥 HTML inline (iframe, video, etc.) — renderiza como HTML real
    if(/^\s*</.test(content) && RX_RAW_INLINE.test(content)){
      const wrap = document.createElement('div');
      wrap.innerHTML = content;
      currentContainer().appendChild(wrap);
      buf.length = 0;
      return;
    }

    // Padrão: parágrafo markdown
    const p = document.createElement('p');
    p.innerHTML = inlineMD(content);
    currentContainer().appendChild(p);
    buf.length = 0;
  };

  while(i < lines.length){
    let line = lines[i];
    let norm = line.replace(/[’‘]/g, "'");

    // headings aninhados
    const mH = line.match(/^\s*(#{1,6})\s+(.+?)\s*$/);
    if(mH){
      flushParagraph();
      const level = mH[1].length, title = mH[2].trim();
      while(stack.length && stack[stack.length-1].level >= level) stack.pop();
      newSectionAt(level, title);
      i++; continue;
    }

    // code fences
    const mFenceOpen = norm.match(/^\s*(?:```|''')([\w-]+)?\s*$/);
    if(!inCode && mFenceOpen){
      flushParagraph();
      inCode = true; codeLang = (mFenceOpen[1]||'').toLowerCase();
      i++; continue;
    }
    if(inCode){
      const mFenceClose = norm.match(/^\s*(?:```|''')+\s*$/);
      if(mFenceClose){
        const pre = document.createElement('pre');
        pre.className = 'md-code copyable';
        const hint = document.createElement('span'); hint.className = 'copy-hint'; hint.textContent = 'Copiar';
        const code = document.createElement('code');
        if(codeLang) code.className = 'lang-'+codeLang;
        code.textContent = buf.join('\n');
        pre.append(hint, code);
        pre.onclick = ()=>copy(pre);
        currentContainer().appendChild(pre);
        buf.length = 0; inCode = false; codeLang = '';
      }else{
        buf.push(line);
      }
      i++; continue;
    }

    // função multi-linha
    if(!inFn){
      const mFnStart = norm.match(/^\s*(?:export\s+)?function\s+\w+\s*\([^)]*\)\s*\{\s*$/);
      if(mFnStart){
        flushParagraph();
        inFn = true; fnDepth = 1; buf.length = 0; i++; continue;
      }
    }
    if(inFn){
      buf.push(line);
      const open = (line.match(/\{/g) || []).length;
      const close = (line.match(/\}/g) || []).length;
      fnDepth += open - close;
      i++;
      if(fnDepth <= 0){
        const div = document.createElement('div');
        div.className = 'equation copyable fn';
        div.innerHTML = '<span class="copy-hint">Copiar</span>' + escapeHtml(buf.join('\\n'));
        div.onclick = ()=>copy(div);
        currentContainer().appendChild(div);
        buf.length = 0; inFn = false; fnDepth = 0;
      }
      continue;
    }

    // hr
    if(/^\s*(?:---|\*\*\*)\s*$/.test(line)){
      flushParagraph();
      const hr = document.createElement('div'); hr.className = 'hr';
      currentContainer().appendChild(hr); i++; continue;
    }

    // blockquotes aninhados
    if(/^\s*>+/.test(line)){
      flushParagraph();
      const items = [];
      while(i < lines.length && /^\s*>+/.test(lines[i])){
        const m = lines[i].match(/^\s*(>+)\s?(.*)$/);
        items.push({ level: m[1].length, text: m[2] });
        i++;
      }
      const rootBQ = document.createElement('blockquote');
      rootBQ.className = 'bq copyable bq-l1';
      rootBQ.innerHTML = '<span class="copy-hint">Copiar</span>';
      let currentLevel = 1;
      const stackBQ = [rootBQ];
      items.forEach(({level, text})=>{
        while(level > currentLevel){
          const inner = document.createElement('blockquote');
          inner.className = 'bq bq-l' + Math.min(currentLevel+1,3);
          stackBQ[stackBQ.length-1].appendChild(inner);
          stackBQ.push(inner);
          currentLevel++;
        }
        while(level < currentLevel){
          stackBQ.pop();
          currentLevel--;
        }
        const divLine = document.createElement('div');
        divLine.className = 'bq-line';
        divLine.innerHTML = inlineMD(text);
        stackBQ[stackBQ.length-1].appendChild(divLine);
      });
      rootBQ.onclick = ()=>copy(rootBQ);
      currentContainer().appendChild(rootBQ);
      continue;
    }

    // callouts estendidos
    const mCallAny = norm.match(/^\s*(::(info|warn|tip|note|success|danger)|::\.|:|\?)\s+(.*)$/i);
    if(mCallAny){
      flushParagraph();
      let kind = 'note';
      if(mCallAny[1] === '::.') kind = 'aside';
      else if(mCallAny[1] === ':') kind = 'note';
      else if(mCallAny[1] === '?') kind = 'question';
      else kind = (mCallAny[2] || 'info').toLowerCase();

      let textBuf = [mCallAny[3]];
      let j = i + 1;
      while (j < lines.length) {
        const nextLine = lines[j];
        const nextNorm = nextLine.replace(/[’‘]/g, "'").trim();
        if (nextNorm === '') break;
        if (/^\s*(::(info|warn|tip|note|success|danger)|::\.|:|\?)\s+/i.test(nextNorm)) break;
        textBuf.push(nextLine.trim());
        j++;
      }
      i = j;
      const div = document.createElement('div');
      div.className = 'callout copyable ' + kind;
      div.innerHTML = '<span class="copy-hint">Copiar</span>' + inlineMD(textBuf.join(' '));
      div.onclick = ()=>copy(div);
      currentContainer().appendChild(div);
      continue;
    }

    // math $$ … $$
    if(/^\s*\$\$\s*$/.test(line)){
      flushParagraph(); i++;
      let math = '';
      while(i<lines.length && !/^\s*\$\$\s*$/.test(lines[i])){ math += lines[i++] + '\\n'; }
      const eq = document.createElement('div');
      eq.className = 'equation copyable';
      eq.innerHTML = '<span class="copy-hint">Copiar</span>'+ escapeHtml(math.trim());
      eq.onclick = ()=>copy(eq);
      currentContainer().appendChild(eq);
      if(i<lines.length) i++;
      continue;
    }

    // table
    if(/^\s*\|.*\|\s*$/.test(line)){
      flushParagraph();
      let rows = [ line ];
      while(i+1<lines.length && /^\s*\|.*\|\s*$/.test(lines[i+1])){ rows.push(lines[++i]); }
      const tbl = document.createElement('table'); tbl.className='md-table';
      rows.forEach((r,idx)=>{
        const tr = document.createElement('tr');
        const cells = r.trim().slice(1,-1).split('|').map(c=>c.trim());
        const isSep = (idx===1 && cells.every(x=>/^:?-{3,}:?$/.test(x)));
        if(isSep) return;
        cells.forEach(c=>{
          const cell = document.createElement((idx===0)?'th':'td');
          cell.innerHTML = inlineMD(c);
          tr.appendChild(cell);
        });
        tbl.appendChild(tr);
      });
      currentContainer().appendChild(tbl); i++; continue;
    }

    // listas
    const mLi = line.match(/^\s*(?:([-*+])\s+|\d+\.\s+)(.+)$/);
    if(mLi){
      flushParagraph();
      const ordered = /^\s*\d+\.\s+/.test(line);
      const list = document.createElement(ordered?'ol':'ul');
      list.className = 'md-list';
      while(i<lines.length){
        const l = lines[i];
        if(!/^\s*(?:[-*+]\s+|\d+\.\s+)/.test(l)) break;
        const raw = l.replace(/^\s*(?:[-*+]\s+|\d+\.\s+)/,'');
        const task = raw.match(/^\s*\[( |x|X)\]\s*(.*)$/);
        const li = document.createElement('li');
        li.className = 'md-li';
        if(task){
          if(!list.classList.contains('md-task')) list.classList.add('md-task');
          const box = document.createElement('input'); box.type='checkbox'; box.checked = /x/i.test(task[1]); box.disabled = true;
          const span = document.createElement('span'); span.innerHTML = inlineMD(task[2]);
          li.append(box, span);
        }else{
          li.innerHTML = inlineMD(raw);
        }
        list.appendChild(li); i++;
      }
      currentContainer().appendChild(list); continue;
    }

    // parágrafos
    if(line.trim()===''){ flushParagraph(); i++; continue; }
    buf.push(line.trim()); i++;
  }
  flushParagraph();
  toast('Livro (aninhado) gerado!');
}

</script><script>
const DEMO_MD = "# Demo \u2014 A\u00e7\u00f5es e Blocos\n\n[[btn:gerar|Gerar (texto do editor)]] [[btn:nested|Gerar (aninhado)]] [[btn:md|Salvar .md]] [[btn:pdf|Imprimir PDF]]\n\n: Esta p\u00e1gina demonstra **bot\u00f5es inline** que executam as MESMAS a\u00e7\u00f5es dos bot\u00f5es do topo.\n\n## Fun\u00e7\u00e3o em aspas (render == equa\u00e7\u00e3o)\n\u201cfunction pulse(t){ return Math.cos(t) * 0.369; }\u201d\n\n## Cita\u00e7\u00f5es\n> n\u00edvel 1\n>> n\u00edvel 2\n>>> n\u00edvel 3\n\n## Callouts\n: Nota simples\n::warn Aten\u00e7\u00e3o\n::. Aside\n? Pergunta\n\n## Lista de tarefas\n- [ ] pendente\n- [x] feita\n\n## Tabela\n| A | B |\n|---|---|\n| 1 | 2 |\n\n## C\u00f3digo (aspas)\n'''js\nconsole.log(\"ok das aspas\");\n'''\n";
const ACTIONS = {
  demo(){ autoBuild(DEMO_MD); },
  gerar(){ const v = (document.getElementById('srcText')?.value||'').trim(); autoBuild(v || DEMO_MD); },
  nested(){ const v = (document.getElementById('srcText')?.value||'').trim(); if(typeof autoBuildNested==='function') autoBuildNested(v || DEMO_MD); else autoBuild(v || DEMO_MD); },
  importar(){ if(typeof openImporter==='function') openImporter(); },
  md(){
    // Call the global exportMD implementation if available.
    if(typeof window.exportMD === 'function') window.exportMD();
  },
  pdf(){ window.print(); },
  reading(){ if(typeof toggleReading==='function') toggleReading(); },
  theme(){ if(typeof cycleTheme==='function') cycleTheme(); },
  limpar(){ const r=document.getElementById('root'); if(r) r.innerHTML=''; toast && toast('Limpou'); },
  tts(){ document.getElementById('btn-tts')?.click(); },
  'tts-sel'(){ document.getElementById('btn-tts-sel')?.click(); },
  'tts-stop'(){ document.getElementById('btn-tts-stop')?.click(); }
};
document.addEventListener('click', (e)=>{
  const a = e.target.closest('[data-action]');
  if(!a) return;
  const act = a.dataset.action;
  if(act && ACTIONS[act]){ e.preventDefault(); ACTIONS[act](a); }
});
</script><script>
/* ===== Biblioteca local (Stacks) ===== */
const LIB_NS = 'tl_library_v1';
function libLoad(){ try{ return JSON.parse(localStorage.getItem(LIB_NS)||'[]'); }catch{return []} }
function libSave(arr){ localStorage.setItem(LIB_NS, JSON.stringify(arr)); }
function libAdd(doc){ const arr=libLoad(); arr.unshift(doc); libSave(arr); }
function libDel(id){ libSave(libLoad().filter(d=>d.id!==id)); }
function libUpdate(id, patch){ libSave(libLoad().map(d=> d.id===id? Object.assign({}, d, patch): d)); }
function analyzeMD(md){
  const words=(md.match(/\S+/g)||[]).length;
  const headings=(md.match(/^\s*#/gm)||[]).length;
  const code=(md.match(/^\s*```/gm)||[]).length;
  const quotes=(md.match(/^\s*>/gm)||[]).length;
  return {words, headings, code, quotes};
}

/* ===== Helpers de MD ===== */
function buildMDFromDOM(){
  const parts=[];
  document.querySelectorAll('#root details.acc').forEach(d=>{
    const h=d.querySelector('summary h2'); if(h) parts.push('# '+h.textContent.trim());
    d.querySelectorAll('.sec > *').forEach(node=>{
      if(node.matches('p')) parts.push(node.innerText.trim());
      else if(node.matches('blockquote')) parts.push('> '+node.innerText.replace('Copiar','').trim());
      else if(node.matches('pre.md-code')) parts.push('```\n'+(node.querySelector('code')?.textContent||'')+'\n```');
      else if(node.matches('.equation')) parts.push('$$\n'+node.innerText.replace('Copiar','').trim()+'\n$$');
      else if(node.matches('ul.md-task')){
        node.querySelectorAll('li').forEach(li=>{
          const chk=li.querySelector('input[type=checkbox]'); const t=li.innerText.replace('Copiar','').trim();
          parts.push(`- [${chk&&chk.checked?'x':' '}] ${t}`);
        });
      }else if(node.matches('ul,ol')){
        const isOl=node.matches('ol'); let idx=1;
        node.querySelectorAll('li').forEach(li=>{
          const txt=li.innerText.trim();
          parts.push((isOl? (idx++)+'. ' : '- ')+txt);
        });
      }else if(node.matches('table.md-table')){
        const rows=[...node.querySelectorAll('tr')].map(tr=>[...tr.children].map(td=>td.innerText.trim()));
        if(rows.length){
          parts.push('| '+rows[0].join(' | ')+' |');
          parts.push('| '+rows[0].map(()=> '---').join(' | ')+' |');
          rows.slice(1).forEach(r=>parts.push('| '+r.join(' | ')+' |'));
        }
      }
    });
  });
  return parts.join('\n\n');
}
function getCurrentMarkdown(){ return (window.__current_md && window.__current_md.trim()) ? window.__current_md : buildMDFromDOM(); }
window.exportMD = function(){
  const md = buildMDFromDOM();
  const blob=new Blob([md],{type:'text/markdown'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob);
  const basename = (window.__current_title||'export').replace(/[\\\/:*?"<>|]+/g,'-').slice(0,80)||'export';
  a.download= basename + '.md'; a.click(); URL.revokeObjectURL(a.href);
  toast && toast('.md exportado');
};

/* ===== Bloco Mestre (sempre topo) ===== */
function ensureMasterBlock(){
  const root=document.getElementById('root'); if(!root) return;
  let mb=document.getElementById('masterBlock');
  if(!mb){
    mb=document.createElement('div'); mb.id='masterBlock'; mb.className='master-block';
    root.prepend(mb);
  }
  const safeTitle=(window.__current_title||'').replace(/[<>&]/g, s=>({ '<':'&lt;','>':'&gt;','&':'&amp;' }[s]));
  mb.innerHTML = `<div class="row">
    <input id="docTitle" class="title" placeholder="Título do documento" value="${safeTitle}">
    <button class="btn" data-action="copiar-tudo">Copiar tudo</button>
    <button class="btn" data-action="tts">TTS On/Off</button>
    <button class="btn" data-action="md">Exportar .md</button>
    <button class="btn" data-action="pdf">Imprimir (PDF)</button>
    <button class="btn" data-action="abrir-tudo">Abrir tudo</button>
    <button class="btn" data-action="fechar-tudo">Fechar tudo</button>
    <button class="btn" data-action="save">Salvar</button>
  </div>`;
}

/* ===== Comandos do Bloco Mestre ===== */
function openAll(){ document.querySelectorAll('#root details.acc').forEach(d=> d.open=true); }
function closeAll(){ document.querySelectorAll('#root details.acc').forEach(d=> d.open=false); }
async function copyAll(){
  const md=getCurrentMarkdown();
  try{ await navigator.clipboard.writeText(md); toast && toast('Conteúdo copiado'); }catch(e){ console.warn(e); }
}
function saveCurrent(){
  const md=getCurrentMarkdown();
  const titleInput=document.getElementById('docTitle');
  const title=(titleInput&&titleInput.value.trim()) || (md.match(/^\s*#\s+(.+)$/m)?.[1]) || 'Sem título';
  const now=new Date().toISOString();
  const id='doc_'+Date.now();
  const doc={id,title,md,createdAt:now,updatedAt:now,bytes:md.length};
  libAdd(doc);
  localStorage.setItem('tl_last_doc_id', id);
  toast && toast('Salvo em Stacks');
}

/* ===== Pré-processamento (arrow => $$, aside normalizado) ===== */
function preprocessMD(text){
  const lines = String(text||'').replace(/\r\n?/g,'\n').split('\n');
  const out=[]; let i=0;
  while(i<lines.length){
    let l=lines[i];
    let norm=l.replace(/[’‘]/g,"'").replace(/[“”]/g,'"');

    // ::aside -> ::. ; e garante "::. " (com espaço) quando vazio
    if(/^\s*::aside\b/i.test(norm)){ l = l.replace(/^\s*::aside\b/i, '::.'); norm=l.replace(/[’‘]/g,"'").replace(/[“”]/g,'"'); }
    if(/^\s*::\.\s*$/.test(norm)){ l = '::. '; norm = l; }

    // Arrow block multilinha com chaves
    if(/^\s*(?:const|let|var)\s+[A-Za-z_$][\w$]*\s*=\s*(?:\([^)]*\)|[A-Za-z_$][\w$]*)\s*=>\s*\{\s*$/.test(norm)){
      const buf=[l]; let depth=((l.match(/\{/g)||[]).length - (l.match(/\}/g)||[]).length); i++;
      while(i<lines.length){
        buf.push(lines[i]);
        depth += ((lines[i].match(/\{/g)||[]).length - (lines[i].match(/\}/g)||[]).length);
        i++;
        if(depth<=0) break;
      }
      out.push('$$'); out.push(...buf); out.push('$$'); continue;
    }
    // Função citada "function ... { ... }"
    let m = norm.match(/^[\"']\s*((?:export\s+)?function\s+[A-Za-z_$][\w$]*\s*\([^)]*\)\s*\{[^}]*\})\s*[\"']\s*$/);
    if(m){ out.push('$$'); out.push(m[1]); out.push('$$'); i++; continue; }
    // Arrow citada "const f = ... => ..."
    let m2 = norm.match(/^[\"']\s*((?:const|let|var)\s+[A-Za-z_$][\w$]*\s*=\s*(?:\([^)]*\)|[A-Za-z_$][\w$]*)\s*=>\s*(?:\{[^}]*\}|[^;]+;?))\s*[\"']\s*$/);
    if(m2){ out.push('$$'); out.push(m2[1]); out.push('$$'); i++; continue; }
    // Arrow one-liner
    if(/^\s*(?:const|let|var)\s+[A-Za-z_$][\w$]*\s*=\s*(?:\([^)]*\)|[A-Za-z_$][\w$]*)\s*=>\s*(?:\{[^}]*\}|[^;]+;?)\s*$/.test(norm)){
      out.push('$$'); out.push(l); out.push('$$'); i++; continue;
    }
    out.push(l); i++;
  }
  return out.join('\n');
}

/* ===== Envelopa os builders para usar preprocess + bloco mestre ===== */
(function(){
  if(typeof window.autoBuild==='function'){
    const __orig = window.autoBuild;
    window.autoBuild = function(text){
      text = preprocessMD(text||'');
      window.__current_md = text;
      window.__current_title = (text.match(/^\s*#\s+(.+)$/m)||[])[1] || (document.title||'');
      __orig(text);
      ensureMasterBlock();
    }
  }
  if(typeof window.autoBuildNested==='function'){
    const __origN = window.autoBuildNested;
    window.autoBuildNested = function(text){
      text = preprocessMD(text||'');
      window.__current_md = text;
      window.__current_title = (text.match(/^\s*#\s+(.+)$/m)||[])[1] || (document.title||'');
      __origN(text);
      ensureMasterBlock();
    }
  }
})();

/* ===== Home (stacks) ===== */
function renderWelcome(){
const name =
  localStorage.getItem('tl_user_name') ||
  localStorage.getItem('di_userName') ||
  '';
  const root = document.getElementById('root');
  const stacks = libLoad();
  const cards = stacks.map(d=>{
    const a = analyzeMD(d.md);
    const dt = new Date(d.updatedAt||d.createdAt||Date.now()).toLocaleString();
    return `
    <div class="stack-card">
      <h4>${escapeHtml(d.title||'Sem título')}</h4>
      <div class="meta">${dt} · ${a.words} palavras</div>
      <div class="row">
        <button class="btn" data-action="open-doc" data-id="${d.id}">Abrir</button>
        <button class="btn" data-action="rename-doc" data-id="${d.id}">Renomear</button>
        <button class="btn" data-action="analisar-doc" data-id="${d.id}">Analisar</button>
        <button class="btn" data-action="md-doc" data-id="${d.id}">Exportar .md</button>
        <button class="btn" data-action="del-doc" data-id="${d.id}">Excluir</button>
      </div>
    </div>`;
  }).join('');

  root.innerHTML = `
  <details class="acc" open>
    <summary><span class="chev"></span><h2>👋 Boas‑vindas${name? (', '+escapeHtml(name)) : ''}</h2></summary>
    <div class="sec">
      <div class="welcome">
        <div class="row" style="gap:8px;align-items:center;">
          <input id="welcomeName" class="field" placeholder="Seu nome" value="${escapeHtml(name)}"/>
          <button class="btn" data-action="save-name">Salvar nome</button>
          <button class="btn" data-action="importar">Enviar Documento</button>
          <button class="btn" data-action="demo">Gerar Demo</button>
          <button class="btn" data-action="gerar">Gerar do Editor</button>
          <button class="btn" data-action="nested">Gerar (aninhado)</button>
          <button class="btn" data-action="md">Exportar .md</button>
          <button class="btn" data-action="pdf">Imprimir (PDF)</button>
          <button class="btn" data-action="reading">Modo Leitura</button>
          <button class="btn" data-action="theme">Trocar Tema</button>
        </div>
        <div class="small" style="margin-top:8px">Stacks salvos no dispositivo:</div>
        <div class="stack-grid">${cards || '<div class="small" style="opacity:.8">Sem documentos salvos ainda.</div>'}</div>
      </div>
    </div>
  </details>`;
}

/* ===== Estende ACTIONS ===== */
window.ACTIONS = window.ACTIONS || {};
Object.assign(ACTIONS, {
  'back'(){ try{ if(history.length>1){ history.back(); } else { renderWelcome(); } }catch(e){ renderWelcome(); } },
  
  'abrir-tudo'(){ openAll(); },
  'fechar-tudo'(){ closeAll(); },
  'copiar-tudo'(){ copyAll(); },
  'save'(){ saveCurrent(); },
  'open-doc'(el){ const id = el?.dataset?.id; const doc = libLoad().find(d=>d.id===id); if(!doc) return; autoBuild(doc.md); },
  'del-doc'(el){ const id = el?.dataset?.id; libDel(id); renderWelcome(); toast && toast('Documento removido'); },
  'rename-doc'(el){ const id = el?.dataset?.id; const doc = libLoad().find(d=>d.id===id); if(!doc) return; const novo = prompt('Novo título', doc.title)||''; if(novo.trim()){ libUpdate(id,{title:novo.trim(),updatedAt:new Date().toISOString()}); renderWelcome(); toast && toast('Renomeado'); } },
  'analisar-doc'(el){ const id = el?.dataset?.id; const doc = libLoad().find(d=>d.id===id); if(!doc) return; const a = analyzeMD(doc.md); toast && toast(`Palavras: ${a.words} · H1+: ${a.headings} · Código: ${a.code} · Citações: ${a.quotes}`); },
  'md-doc'(el){ const id = el?.dataset?.id; const doc = libLoad().find(d=>d.id===id); if(!doc) return; const blob=new Blob([doc.md],{type:'text/markdown'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=(doc.title||'documento')+'.md'; a.click(); URL.revokeObjectURL(a.href); },
  'save-name'(){ const el = document.getElementById('welcomeName'); const v=(el&&el.value||'').trim(); if(v){ localStorage.setItem('tl_user_name', v); toast && toast('Nome salvo'); } else { localStorage.removeItem('tl_user_name'); toast && toast('Nome limpo'); } renderWelcome(); },
  'home'(){ renderWelcome(); },
  'welcome'(){ renderWelcome(); }
});

/* ===== Primeira carga: Home ===== */
document.addEventListener('DOMContentLoaded', ()=>{ renderWelcome(); });
</script><script id="PATCH_MASTERBLOCK_HOME_BTN_V1">
(()=>{'use strict';
const $=(q,r=document)=>r.querySelector(q);
function ensureHomeInMaster(){
  const area = $('#masterActions');
  if(!area) return;
  if(!area.querySelector('[data-act="home"]')){
    const b = document.createElement('button');
    b.className='chip'; b.textContent='Home'; b.dataset.act='home';
    // Inserir como primeiro botão (antes de Copiar tudo/Iniciar)
    area.insertBefore(b, area.firstChild);
  }
  // Delegação de clique para o Master Block
  const block = $('#masterBlock') || document;
  if(!block.dataset.boundHomeAct){
    block.dataset.boundHomeAct='1';
    block.addEventListener('click', (e)=>{
      const t = e.target.closest('[data-act="home"]'); if(!t) return;
      // Reusa ACTIONS.home quando disponível; senão fallback para stacks/topo
      if(window.ACTIONS && typeof ACTIONS.home==='function'){ ACTIONS.home(); return; }
      const acc = $('#stackHost details.acc') || $('#stackHost');
      if(acc){ try{ acc.open = true; }catch{}; acc.scrollIntoView({behavior:'smooth', block:'start'}); }
      else window.scrollTo({top:0, behavior:'smooth'});
    }, true);
  }
}
document.addEventListener('DOMContentLoaded', ensureHomeInMaster);
})();</script><script id="FAB_MINI_CONFIG">
window.FAB_MINI = window.FAB_MINI || {
  // 'hide' = esconde os outros; 'replace' = troca o menu e mantém só os botões abaixo
  mode: 'replace',
  // incluir Voltar? (false por padrão, como você pediu)
  include_back: false,
  // textos dos botões (pode mudar aqui)
  labels: { autogerar: 'Auto‑Gerar', pdf: 'PDF', tts: 'TTS', home: 'Home', back: 'Voltar' },
  // ganchos do Auto‑Gerar
  autogerar: {
    // roda antes do Auto‑Gerar (ex.: setar tema/seed/clean)
    before: null,
    // override do fluxo de geração; se não definir, tentamos openImporter() → ACTIONS.demo() → autoBuild()
    run: null
  }
};
</script><script id="PATCH_FAB_MINI_V1">
(()=>{'use strict';
const $=(q,r=document)=>r.querySelector(q);

const CFG = window.FAB_MINI || (window.FAB_MINI = {
  mode:'replace', include_back:false,
  labels:{ autogerar:'Auto‑Gerar', pdf:'PDF', tts:'TTS', home:'Home', back:'Voltar' },
  autogerar:{ before:null, run:null }
});

function ensureActions(){
  if(!window.ACTIONS) window.ACTIONS = {};

  if(typeof ACTIONS.home!=='function'){
    ACTIONS.home = ()=>{
      if(typeof window.renderWelcome==='function'){ renderWelcome(); return; }
      const acc = $('#stackHost details.acc') || $('#stackHost');
      if(acc){ try{ acc.open = true; }catch{}; acc.scrollIntoView({behavior:'smooth', block:'start'}); }
      else window.scrollTo({top:0, behavior:'smooth'});
    };
  }
  if(typeof ACTIONS.ttsToggle!=='function'){
    ACTIONS.ttsToggle = ()=>{ const b=document.getElementById('btn-tts'); if(b) b.click(); };
  }
  if(typeof ACTIONS.autoGerar!=='function'){
    ACTIONS.autoGerar = ()=>{
      try{ if(typeof CFG.autogerar.before==='function') CFG.autogerar.before(); }catch{}
      if(typeof CFG.autogerar.run==='function') return CFG.autogerar.run();
      if(typeof window.openImporter==='function') return openImporter();
      if(window.ACTIONS?.demo) return ACTIONS.demo();
      if(typeof window.autoBuild==='function') return autoBuild('# Demo\n\n...');
    };
  }
  if(typeof ACTIONS.pdf!=='function'){ ACTIONS.pdf = ()=>window.print(); }
  if(typeof ACTIONS.back!=='function'){
    ACTIONS.back = ()=>{ if(history.length>1) history.back(); else ACTIONS.home?.(); };
  }
}

function rebuildFAB(){
  const menu = $('.fab .menu') || $('#fab .menu') || $('.menu[data-fab]');
  if(!menu) return;

  const keep = ['home','autogerar','tts','pdf']; // ordem desejada
  if(CFG.include_back) keep.splice(1,0,'back'); // opção: Home, Back, Auto‑Gerar, TTS, PDF

  if(CFG.mode==='replace'){
    menu.innerHTML='';
  }else{
    // hide todos os outros
    menu.querySelectorAll('.btn,button,a').forEach(el=>{
      if(!keep.includes(el.dataset.action)) el.style.display='none';
    });
  }

  const make = (act,text)=>{
    const b=document.createElement('button'); b.className='btn'; b.dataset.action=act; b.textContent=text; return b;
  };
  const label = CFG.labels || {};
  keep.forEach(act=>{
    const sel = `[data-action="${act}"]`;
    const txt = label[act] || ({home:'Home',back:'Voltar',autogerar:'Auto‑Gerar',tts:'TTS',pdf:'PDF'})[act];
    const exists = menu.querySelector(sel);
    if(exists){ exists.textContent = txt; exists.style.display=''; }
    else menu.appendChild(make(act, txt));
  });

  if(!menu.dataset.boundMini){
    menu.dataset.boundMini='1';
    menu.addEventListener('click',(e)=>{
      const b=e.target.closest('[data-action]'); if(!b) return;
      const act=b.dataset.action;
      const map = {home:'home',back:'back',autogerar:'autoGerar',tts:'ttsToggle',pdf:'pdf', dts:'ttsToggle'};
      const fn = map[act] && ACTIONS[map[act]];
      if(typeof fn==='function'){ e.preventDefault(); fn(); }
    }, true);
  }
}

document.addEventListener('DOMContentLoaded', ()=>{ ensureActions(); rebuildFAB(); });
})();
</script><script id="ORB2D_ENGINE_V1">
(()=>{'use strict';
const $=(q,r=document)=>r.querySelector(q);

const ARQ = window.ARQ || (window.ARQ = {
  current: (localStorage.getItem('tl_arq')||'madeira').toLowerCase(),
  map: {
    madeira: { a:'#36f6a2', b:'#00ffa8', name:'Madeira' },
    agua:    { a:'#67e6ff', b:'#3bd3ff', name:'Água' },
    fogo:    { a:'#ff7a00', b:'#ff3366', name:'Fogo' },
    terra:   { a:'#c8a46e', b:'#8a6c3d', name:'Terra' },
    metal:   { a:'#dfe7ff', b:'#a0b7ff', name:'Metal' },
  }
});

function applyArq(name){
  name = (name||'').toLowerCase();
  const cfg = ARQ.map[name] || ARQ.map.madeira;
  ARQ.current = name in ARQ.map ? name : 'madeira';
  localStorage.setItem('tl_arq', ARQ.current);
  const root = document.documentElement;
  root.style.setProperty('--orb-a', cfg.a);
  root.style.setProperty('--orb-b', cfg.b);
  document.body.dataset.arq = ARQ.current;
  if(window.toast) toast('Arquétipo: '+(cfg.name||name));
  window.dispatchEvent(new CustomEvent('archetypechange',{ detail:{ name: ARQ.current, colors: cfg } }));
}

function ensureOrb(){
  const fab = $('#fab'); if(!fab) return;
  let orb = $('#orb2d');
  if(!orb){
    orb = document.createElement('button');
    orb.id='orb2d'; orb.title='Abrir apps';
    fab.appendChild(orb);
  }
  // quick picker
  let picker = $('#orb-picker');
  if(!picker){
    picker = document.createElement('div');
    picker.id = 'orb-picker';
    picker.innerHTML = `
      <button class="chip" data-arq="madeira">Madeira</button>
      <button class="chip" data-arq="agua">Água</button>
      <button class="chip" data-arq="fogo">Fogo</button>
      <button class="chip" data-arq="terra">Terra</button>
      <button class="chip" data-arq="metal">Metal</button>
    `;
    fab.appendChild(picker);
  }
  // tap toggles menu
  orb.addEventListener('click', ()=> fab.classList.toggle('open'));
  // long press opens picker
  let pressTimer=null;
  orb.addEventListener('pointerdown', ()=>{
    clearTimeout(pressTimer);
    pressTimer = setTimeout(()=> fab.classList.toggle('show-picker'), 500);
  });
  ['pointerup','pointerleave','pointercancel'].forEach(evt=> orb.addEventListener(evt, ()=> clearTimeout(pressTimer)));
  picker.addEventListener('click', (e)=>{
    const b = e.target.closest('[data-arq]'); if(!b) return;
    applyArq(b.dataset.arq);
    fab.classList.remove('show-picker');
  });
}

document.addEventListener('DOMContentLoaded', ()=>{
  ensureOrb();
  applyArq(ARQ.current);
});

// API pública
window.ARQ = Object.assign(ARQ, {
  set: applyArq,
  cycle(){
    const list = Object.keys(ARQ.map);
    const i = Math.max(0, list.indexOf(ARQ.current));
    const next = list[(i+1)%list.length];
    applyArq(next);
  }
});
})();
</script><script id="HERBIE_ENGINE_V1">
(()=>{'use strict';
const $=(q,r=document)=>r.querySelector(q);

const HERBIE = window.HERBIE || (window.HERBIE = {
  preset: (localStorage.getItem('herbiePreset')||'blue').toLowerCase(),
  presets: {
    blue:    { a:'#67e6ff', b:'#3bd3ff', name:'Blue' },
    gold:    { a:'#f7d774', b:'#ffcc55', name:'Gold' },
    thermal: { a:'#ff7a00', b:'#ff3366', name:'Thermal' },
  },
  setPreset(name){
    name=(name||'').toLowerCase();
    const p=this.presets[name]||this.presets.blue;
    this.preset = name in this.presets ? name : 'blue';
    localStorage.setItem('herbiePreset', this.preset);
    const root=document.documentElement;
    root.style.setProperty('--orb-a', p.a);
    root.style.setProperty('--orb-b', p.b);
    window.dispatchEvent(new CustomEvent('herbiechange',{detail:{ name:this.preset, colors:p }}));
    if(window.toast) toast('Preset: '+(p.name||name));
  },
  setButtonsOpacity(v){
    const val=Math.max(.2, Math.min(1, Number(v)||.92));
    document.documentElement.style.setProperty('--fab-btn-opacity', String(val));
    localStorage.setItem('herbieBtnOpacity', String(val));
  },
  cyclePresets(){
    const list=Object.keys(this.presets); const i=list.indexOf(this.preset);
    this.setPreset(list[(i+1)%list.length]);
  }
});

// augment ORB picker with preset chips
function enhancePicker(){
  const fab=$('#fab'); if(!fab) return;
  let picker = $('#orb-picker');
  if(!picker) return;
  if(!picker.querySelector('.row-presets')){
    const row = document.createElement('div');
    row.className='row-presets';
    row.style.marginTop='6px';
    row.innerHTML = `
      <button class="chip" data-preset="blue">Blue</button>
      <button class="chip" data-preset="gold">Gold</button>
      <button class="chip" data-preset="thermal">Thermal</button>`;
    picker.appendChild(row);
    picker.addEventListener('click', (e)=>{
      const b=e.target.closest('[data-preset]'); if(!b) return;
      HERBIE.setPreset(b.dataset.preset);
      fab.classList.remove('show-picker');
    });
  }
}

// init
document.addEventListener('DOMContentLoaded', ()=>{
  const savedOpacity = parseFloat(localStorage.getItem('herbieBtnOpacity')||'0');
  if(savedOpacity>0){ HERBIE.setButtonsOpacity(savedOpacity); }
  enhancePicker();
  HERBIE.setPreset(HERBIE.preset);
});

window.HERBIE = HERBIE;
})();
</script><script id="RAW_HTML_COMPAT_MIN_V1">
(()=>{'use strict';
// Non-destructive shim: preserves your existing builder and design.
// If text contains real HTML blocks, we render with a raw-aware builder;
// otherwise we delegate to the original builder untouched.

const $=(q,r=document)=>r.querySelector(q);

const RX_RAW_OPEN=/^\s*<\s*(div|figure|iframe|video|audio|svg|object|embed|table|section|article|img|pre|code|details|blockquote)\b/i;
const RX_RAW_SELF=/^\s*<(img|hr|br|embed|source|track|col|meta|link)\b[^>]*\/?>\s*$/i;
const RX_DIVIDER=/^\s*(?:---|\*\*\*)\s*$/;
const RX_HEADING=/^\s*(#{1,6})\s+(.+)$/;
// Expanded RX_CALL to also recognize shorter callouts like ":" (note) and "?" (question) and the "::." syntax for asides.
const RX_CALL=/^\s*(::(?:info|warn|tip|note|meta|ritual|success|danger|aside|question)|::\.|:|\?)\s+(.*)$/i;

function appendRaw(to, html){
  const tmp=document.createElement('div'); tmp.innerHTML = html;
  [...tmp.childNodes].forEach(n=>to.appendChild(n));
}

function rawAwareBuild(text){
  const root = $('#root'); if(!root) return;
  root.innerHTML = '';

  const lines = String(text||'').replace(/\r\n?/g,'\n').split('\n');
  let i=0, sec=null, blocks=0, sawH=false;

  function newSection(title){
    const det=document.createElement('details'); det.className='acc'; det.open=false;
    const sum=document.createElement('summary');
    sum.innerHTML=`<span class="chev"></span><h2>${title||'Seção'}</h2>`;
    const cont=document.createElement('div'); cont.className='sec';
    det.append(sum, cont); root.appendChild(det);
    sec=det; blocks=0;
  }
  function ensureSection(){ if(!sec) newSection('Seção 1'); if(blocks>=14) newSection(sec.querySelector('h2').textContent+' (cont.)'); }
  function push(el){ ensureSection(); sec.lastChild.appendChild(el); blocks++; }
  const flush = (buf)=>{
    if(!buf.length) return;
    const s = buf.join(' ').trim();
    if(/^\s*</.test(s) && RX_RAW_OPEN.test(s)){
      const d=document.createElement('div'); appendRaw(d, s); push(d);
    }else{
      const p=document.createElement('p');
      p.innerHTML = (window.inlineMD? window.inlineMD(s) : s);
      push(p);
    }
    buf.length=0;
  };

  while(i<lines.length){
    const line = lines[i];

    // hard divider
    if(RX_DIVIDER.test(line)){ flush([]); newSection(); i++; continue; }

    const mH = line.match(RX_HEADING);
    if(mH){ flush([]); newSection(mH[2].trim()); sawH=true; i++; continue; }

    const mC = line.match(RX_CALL);
    if(mC){
      flush([]);
      // Determine callout kind from the marker.
      let marker = (mC[1]||'').toLowerCase();
      let kind;
      if(marker === '::.') {
        kind = 'aside';
      } else if(marker === ':') {
        kind = 'note';
      } else if(marker === '?') {
        kind = 'question';
      } else {
        // strip leading "::" from extended callouts
        if(marker.startsWith('::')) {
          marker = marker.slice(2);
        }
        kind = marker || 'note';
      }
      const div=document.createElement('div');
      div.className=`callout ${kind} copyable`;
      div.innerHTML=`<span class="copy-hint">Copiar</span>` + (window.inlineMD? window.inlineMD(mC[2]) : mC[2]);
      push(div); i++; continue;
    }

    if(RX_RAW_OPEN.test(line)){
      // collect multi-line raw
      let tag = (line.match(RX_RAW_OPEN)||[])[1]||'div';
      const rxClose = new RegExp(`</\\s*${tag}\\s*>`, 'i');
      const buf=[line]; i++;
      while(i<lines.length && !rxClose.test(lines[i]) && !RX_RAW_SELF.test(lines[i])){
        buf.push(lines[i]); i++;
      }
      if(i<lines.length){ buf.push(lines[i]); i++; }
      const d=document.createElement('div'); appendRaw(d, buf.join('\n')); push(d);
      continue;
    }

    // code fences fallback to original builder: we gather and let original handle, or render here
    const mOpen = line.match(/^\s*(?:```|''')\s*([\w-]+)?\s*$/);
    if(mOpen){
      const lang=(mOpen[1]||'').toLowerCase(); i++; const code=[];
      while(i<lines.length && !/^\s*(?:```|''')+\s*$/.test(lines[i])){ code.push(lines[i]); i++; }
      if(i<lines.length) i++;
      const pre=document.createElement('pre'); pre.className='md-code copyable';
      const hint=document.createElement('span'); hint.className='copy-hint'; hint.textContent='Copiar';
      const c=document.createElement('code'); if(lang) c.className='lang-'+lang; c.textContent=code.join('\n');
      pre.append(hint,c); pre.onclick=()=>window.copy&&copy(pre); push(pre); continue;
    }

    if(line.trim()===''){ flush([]); i++; continue; }

    // accumulate paragraph lines
    const acc=[]; acc.push(line.trim()); i++;
    while(i<lines.length && lines[i].trim()!==''){
      if(RX_HEADING.test(lines[i])||RX_DIVIDER.test(lines[i])||RX_CALL.test(lines[i])||RX_RAW_OPEN.test(lines[i])) break;
      acc.push(lines[i].trim()); i++;
    }
    flush(acc);
  }

  // title fallback
  if(!sawH){
    const h = root.querySelector('details.acc summary h2');
    if(h && (!h.textContent || /^Seção/.test(h.textContent))) h.textContent = 'Documento';
  }

  // rename if first block is figure with caption
  root.querySelectorAll('details.acc').forEach((d,idx)=>{
    const cap=d.querySelector('figcaption'); const h=d.querySelector('summary h2');
    if(cap && h && /^Se/i.test(h.textContent||'')) h.textContent = cap.textContent.trim();
    if(!cap && h && /^Se/i.test(h.textContent||'')) h.textContent = idx===0? 'Visão' : `Bloco ${idx+1}`;
  });
}

// Wrap original autoBuild safely (idempotent)
(function(){
  const orig = window.autoBuild;
  if(typeof orig!=='function' || orig.__rawAwareWrapped) return;
  window.autoBuild = function(text){
    try{
      const hasRaw = /^(?:\s*<(?:div|figure|iframe|video|audio|svg|object|embed|table|section|article|img|pre|code|details|blockquote)\b)/mi.test(String(text||''));
      if(hasRaw){ return rawAwareBuild(text); }
    }catch{}
    return orig(text);
  };
  window.autoBuild.__rawAwareWrapped = true;
})();

})();
</script><script id="FAB_KATEX_ACTION_V1">
(()=>{'use strict';
const $=(q,r=document)=>r.querySelector(q);

// — pega um container “ativo” sensato (igual ao master patch)
function getActiveRoot(){
  const picks = [
    '[data-pane="active"]','.stack .doc.active','.pane.active',
    '#renderOut','#mdOut','#viewer','#content','#root','main','article'
  ];
  for(const sel of picks){ const el=$(sel); if(el) return el; }
  return document.body;
}

// — ação KaTeX
async function runKaTeXActive(){
  try{
    const call = (root)=>{
      if(typeof window.KaTeXRender==='function') return window.KaTeXRender(root);
      // fallback: auto-render global se KaTeX já foi carregado
      if(typeof window.renderMathInElement==='function'){
        window.renderMathInElement(root||document.body,{
          delimiters:[
            {left:"$$",right:"$$",display:true},
            {left:"\\[",right:"\\]",display:true},
            {left:"$", right:"$", display:false},
            {left:"\\(", right:"\\)", display:false},
          ],
          throwOnError:false,
          ignoredTags:["script","noscript","style","textarea","code","pre"]
        });
      }
    };
    await call(getActiveRoot());
    (window.toast||console.log)('Σ KaTeX: render no painel ativo ✓');
  }catch(e){
    console.warn('[FAB_KATEX]', e);
    (window.toast||console.warn)('Falha ao renderizar KaTeX');
  }
}

// — garante ACTIONS.katex disponível
function ensureAction(){
  window.ACTIONS = window.ACTIONS || {};
  if(typeof window.ACTIONS.katex!=='function'){
    window.ACTIONS.katex = ()=> runKaTeXActive();
  }
}

// — cria/injeta o botão na #fab .menu
function ensureFabButton(){
  const menu = document.querySelector('#fab .menu');
  if(!menu) return;
  if(menu.querySelector('[data-action="katex"]')) return;
  const b = document.createElement('button');
  b.className = 'btn';
  b.dataset.action = 'katex';
  b.title = 'Render KaTeX (painel ativo)';
  b.textContent = 'Σ KaTeX';
  menu.appendChild(b);
}

// — delega clique do FAB pra chamar ACTIONS (segue o teu padrão)
function bindFabClicks(){
  const menu = document.querySelector('#fab .menu');
  if(!menu || menu.dataset.kxBound) return;
  menu.dataset.kxBound='1';
  menu.addEventListener('click',(e)=>{
    const t = e.target.closest('[data-action="katex"]'); if(!t) return;
    e.preventDefault(); ensureAction(); window.ACTIONS.katex();
  }, true);
}

// — observa o FAB para reinjetar o botão após “rebuild”
function watchFab(){
  const container = document.querySelector('#fab');
  if(!container || container.__kxObs) return;
  const obs = new MutationObserver(()=>{ ensureAction(); ensureFabButton(); bindFabClicks(); });
  obs.observe(container, { childList:true, subtree:true });
  container.__kxObs = obs;
}

// boot
function boot(){ ensureAction(); ensureFabButton(); bindFabClicks(); watchFab(); }
if(document.readyState!=='loading') boot();
else document.addEventListener('DOMContentLoaded', boot);

})();
</script><script id="LIST_BEAUTY_V2_SCRIPT">
(()=>{'use strict';
if(window.__LIST_BEAUTY_V2__) return; window.__LIST_BEAUTY_V2__=true;

const q=(s,r=document)=>[...r.querySelectorAll(s)];

const wrapLists=(root=document)=>{
  const lists = q('ul,ol',root).filter(el=>{
    if(el.closest('nav,menu,.no-beauty,.editor,.toolbar')) return false;
    if(el.classList.contains('ul-neo')||el.classList.contains('ol-neo')) return false; // já cuidado
    return true;
  });
  for(const el of lists){
    const isOL = el.tagName==='OL';
    el.classList.add(isOL?'ol-neo':'ul-neo');
    // preserva estilos existentes do usuário
    if(!el.parentElement.classList.contains('list-card')){
      const wrap = document.createElement('div');
      wrap.className='list-card';
      el.replaceWith(wrap); wrap.appendChild(el);
    }
  }
};

const asciiScore = t=>{
  const box=/[─│┌┐└┘╭╮╰╯═╬╠╣╦╩]+/g, grid=/[-_=+*#\\/|]{3,}/g;
  const L=t.split('\n'); let h=0;
  for(const ln of L){ if(box.test(ln)||grid.test(ln)||ln.trim().startsWith('> ')) h++; }
  return h>=Math.max(2,Math.ceil(L.length*0.2));
};

const enhanceASCII=(root=document)=>{
  const cand=new Set([...q('pre',root),...q('code.language-text, code[class*="language-plaintext"]',root)]);
  q('p',root).forEach(p=>{ const x=p.innerText||''; if(x.includes('\n')&&asciiScore(x)) cand.add(p); });
  for(const el of cand){
    if(el.closest('.ascii-card,.no-beauty')) continue;
    const txt=(el.innerText||'').trim(); if(!asciiScore(txt)) continue;
    const fig=document.createElement('figure'); fig.className='ascii-card';
    const pre=document.createElement('pre'); pre.textContent=txt; fig.appendChild(pre);
    if(!el.closest('pre')){ const fc=document.createElement('figcaption'); fc.className='ascii-cap'; fc.textContent='ASCII • renderizado em bloco'; fig.appendChild(fc); }
    el.replaceWith(fig);
  }
};

/* Heurística opcional: se o UL já tiver data-bullet="dash" ou class style-dash, mantém.
   Caso NÃO tenha, deixamos como diamante (padrão), para não interferir nos teus looks. */
const applyDashCapsuleByAttr=(root=document)=>{
  q('ul.ul-neo',root).forEach(ul=>{
    if(ul.matches('.style-dash,[data-bullet="dash"]')) return;
    // não força nada; o usuário decide via classe/atributo
  });
};

const run=(ctx=document)=>{
  wrapLists(ctx);
  enhanceASCII(ctx);
  applyDashCapsuleByAttr(ctx);
};

if(window.__RENDERBUS__?.on){
  window.__RENDERBUS__.on('after', run, {name:'list-ascii-beauty-v2', priority:95});
}else{
  (document.readyState==='loading') ? document.addEventListener('DOMContentLoaded',()=>run(document)) : run(document);
  new MutationObserver(m=>m.forEach(x=>x.addedNodes&&x.addedNodes.forEach(n=>n.nodeType===1&&run(n))))
    .observe(document.body,{childList:true,subtree:true});
}
})();
</script><script id="PATCH_TITLES_ESCAPE_SETEXT_V1">
(()=>{'use strict';
const esc = s => String(s||'')
  .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');

function applySetext(lines,i){
  // Detecta "Título\n=====" (H1) ou "Subtítulo\n-----" (H2)
  if(i+1 < lines.length){
    const next = lines[i+1].trim();
    if(/^=+$/.test(next)) return { level: 1, text: lines[i].trim(), skip: 2 };
    if(/^-+$/.test(next)) return { level: 2, text: lines[i].trim(), skip: 2 };
  }
  return null;
}

// ------- Flat: sobrescreve helpers do autoBuild se existirem -------
if(typeof window.autoBuild==='function'){
  const abSrc = window.autoBuild.toString();
  if(!abSrc.includes('__TITLES_PATCHED__')){
    const _autoBuild = window.autoBuild;
    window.autoBuild = function(text){
      // wrap original com Setext + escape em H2
      const lines = String(text||'').replace(/\r\n?/g,'\n').split('\n');
      let i=0, rebuilt=[];
      while(i<lines.length){
        const l = lines[i];
        const set = applySetext(lines,i);
        if(set){ // converte para ATX
          rebuilt.push('#'.repeat(set.level)+' '+set.text);
          i+=set.skip; continue;
        }
        rebuilt.push(l); i++;
      }
      // sinaliza patch
      const marker='__TITLES_PATCHED__';
      const saved = window.__current_md;
      window.__current_md = (rebuilt.join('\n'));
      const out = _autoBuild(window.__current_md);
      // corrige todos os <summary><h2> com escape
      document.querySelectorAll('#root details.acc summary h2').forEach(h=>{
        h.innerHTML = esc(h.textContent||'');
      });
      window.__current_md = saved;
      return out;
    }
  }
}

// ------- Nested: adiciona escape no momento de criar seção -------
if(typeof window.autoBuildNested==='function'){
  const __origN = window.autoBuildNested;
  window.autoBuildNested = function(text){
    const escText = t => esc(t).replace(/\s+#+\s*$/,''); // remove hashes finais
    // monkey-patch: intercepta newSectionAt com escape
    const create = (lvl, title)=>{
      const details = document.createElement('details');
      details.className='acc'; details.open=false;
      const sum=document.createElement('summary');
      sum.innerHTML='<span class="chev"></span><h2>'+ escText(title) +'</h2>';
      const cont=document.createElement('div'); cont.className='sec';
      details.append(sum, cont);
      return {details, cont};
    };
    // roda original, depois faz um passe extra pros h2 existentes
    const out = __origN(text);
    document.querySelectorAll('#root details.acc summary h2').forEach(h=>{
      h.innerHTML = esc(h.textContent||'');
    });
    return out;
  }
}
})();
</script><script id="PATCH_MARKDOWNIFY_SMART_V1">
(()=>{'use strict';
function looksTitle(line){
  const t=line.trim();
  if(t.length<80 && /^[A-ZÁÂÃÀÉÊÍÓÔÕÚÜÇ0-9][^.!?]{2,}$/.test(t)) return true; // curto e sem pontuação final
  return false;
}
function isSubtitle(line){
  const t=line.trim();
  return t.length<90 && /[:—–-]\s+/.test(t); // “Título: subtítulo”
}
function bulletsNormalize(line){
  // 1) item → 1. item ; • item → - item
  return line
    .replace(/^\s*(\d+)[\)\]]\s+/,'$1. ')
    .replace(/^\s*[•·]\s+/,'- ');
}
function markdownifyPlain(text){
  const L=String(text||'').replace(/\r\n?/g,'\n').split('\n');
  if(/^\s*#\s+/.test(text)) return text; // já tem H1
  let out=[], seenH1=false, i=0;
  while(i<L.length){
    let line=L[i];

    // HR por longos traços
    if(/^\s*[—–-]{6,}\s*$/.test(line)){ out.push(''); out.push('---'); out.push(''); i++; continue; }

    // título/subtítulo heurístico
    if(!seenH1 && looksTitle(line)){
      out.push('# '+line.trim()); out.push(''); seenH1=true; i++; continue;
    }
    if(isSubtitle(line) && seenH1){
      out.push('## '+line.trim()); out.push(''); i++; continue;
    }

    // listas simples e numeradas
    line = bulletsNormalize(line);

    // “Termo: valor” vira lista de definição simples → callout
    const def = line.match(/^\s*([A-ZÁÂÃÀÉÊÍÓÔÕÚÜÇ].{1,40}):\s+(.+)$/);
    if(def){ out.push(':'+def[1]+' — '+def[2]); i++; continue; }

    // blocos de código heurísticos (muitas chaves/`;`)
    if(/[{;}=].{0,}$/.test(line) && (line.includes('function')||line.includes('=>'))){
      const buf=[line]; i++;
      while(i<L.length && L[i].trim()){
        buf.push(L[i]); i++;
        if(buf.length>1 && /;\s*$/.test(buf[buf.length-1])) break;
      }
      out.push('```js'); out.push(...buf); out.push('```'); out.push('');
      continue;
    }

    out.push(line); i++;
  }
  return out.join('\n');
}

if(typeof window.preprocessMD==='function'){
  const __orig = window.preprocessMD;
  window.preprocessMD = function(text){
    let t=String(text||'');
    // Se não há nenhum header e parece “texto corrido”, aplica markdownify
    const lacksHeaders = !/^\s*#{1,6}\s+/m.test(t) && !/^\s*\S+\n[-=]{3,}\s*$/m.test(t);
    const manyWords = (t.match(/\S+/g)||[]).length>40;
    if(lacksHeaders && manyWords) t = markdownifyPlain(t);
    return __orig(t);
  }
}
})();
</script><script id="CSS_INNER_SAFE_V2">
(()=>{'use strict';
const STYLE_ID='INLINE_CSS_RENDER_SAFE_V2';
function appendSafe(css){
  if(!css || !css.trim()) return;
  let s=document.getElementById(STYLE_ID);
  if(!s){ s=document.createElement('style'); s.id=STYLE_ID; document.head.appendChild(s); }
  s.appendChild(document.createTextNode('\n'+css));
}
window.CSS_INNER_SAFE = {
  applyFromDOM(root=document){
    let css='';
    root.querySelectorAll('style[data-inline]').forEach(el=>{
      const t=(el.textContent||'').trim(); if(t) css+='\n'+t;
    });
    appendSafe(css);
  },
  applyFromHTML(html){
    if(!html) return;
    // só <style data-inline>…</style>
    const re=/<style[^>]*\bdata-inline\b[^>]*>([\s\S]*?)<\/style>/gi; let m, css='';
    while((m=re.exec(html))) css+='\n'+(m[1]||'');
    appendSafe(css);
  }
};
document.addEventListener('DOMContentLoaded',()=> CSS_INNER_SAFE.applyFromDOM());
})();
</script><script id="KATEX_AUTORUN_AFTER_BUILD_V1">
(()=>{'use strict';
function loadOnceCSS(href,id){return new Promise(ok=>{ if(document.getElementById(id)) return ok();
  const l=document.createElement('link'); l.id=id; l.rel='stylesheet'; l.href=href; l.onload=ok; document.head.appendChild(l); });}
function loadOnceJS(src,id){return new Promise(ok=>{ if(document.getElementById(id)) return ok();
  const s=document.createElement('script'); s.id=id; s.src=src; s.defer=true; s.onload=ok; document.head.appendChild(s); });}
async function ensureKaTeX(){ if(window.renderMathInElement) return;
  const CDN="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist";
  await loadOnceCSS(`${CDN}/katex.min.css`,'katex_css');
  await loadOnceJS(`${CDN}/katex.min.js`,'katex_js');
  await loadOnceJS(`${CDN}/contrib/auto-render.min.js`,'katex_auto_js');
}
async function run(root){
  await ensureKaTeX();
  if(typeof window.KaTeXRender==='function') return window.KaTeXRender(root||document.body);
  if(window.renderMathInElement) window.renderMathInElement(root||document.body,{
    delimiters:[
      {left:"$$",right:"$$",display:true},
      {left:"\$begin:math:display$",right:"\\$end:math:display$",display:true},
      {left:"$", right:"$", display:false},
      {left:"\$begin:math:text$", right:"\\$end:math:text$", display:false},
    ],
    throwOnError:false,
    ignoredTags:["script","noscript","style","textarea","code","pre"]
  });
}
// envelopa os builders
['autoBuild','autoBuildNested'].forEach(name=>{
  const f=window[name];
  if(typeof f==='function' && !f.__kxKaTeXWrapped){
    window[name]=function(text){ const out=f(text); run(document.getElementById('root')); return out; }
    window[name].__kxKaTeXWrapped=true;
  }
});
})();
</script><script id="TEXT_BEAUTY_V3_SCRIPT">
(()=>{'use strict';
if(window.__TEXT_BEAUTY_V3__) return; window.__TEXT_BEAUTY_V3__=true;

/* Utilitários */
const $=(s,r=document)=>r.querySelector(s);
const $$=(s,r=document)=>[...r.querySelectorAll(s)];
const esc=(s)=>s.replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));

/* 0) Toggle edição rápida */
let EDIT_ON=false;
const toggleEdit=()=>{
  EDIT_ON=!EDIT_ON;
  document.body.toggleAttribute('data-edit', EDIT_ON);
  const host = document.getElementById('CONTENT') || document.querySelector('main, article, .render, .reader, body');
  if(host) host.contentEditable = EDIT_ON ? 'plaintext-only' : 'false';
};
document.addEventListener('keydown',e=>{
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='e'){ e.preventDefault(); toggleEdit(); }
});

/* 1) Key:Value negrito (palavra:) + parênteses + chips [ ]
   - roda apenas em blocos de texto (p, li) e não mexe dentro de code/pre */
const processInline = (root=document)=>{
  const targets = $$('p, li, h1, h2, h3, h4, h5, h6', root).filter(n=>!n.closest('pre, code, .no-beauty'));
  const rxKV = /(^|\s)([A-Za-zÀ-ÿ0-9_]+):(?=\s|$)/g; // Palavra:
  const rxParen = /\(([^\n)]+)\)/g;                  // ( … )
  const rxChip  = /\[\[([^[\]]+)\]\]|\[([^[\]]+)\]/g; // [[a]] | [a]

  for(const el of targets){
    // evita processar múltiplas vezes
    if(el.dataset.inlineProcessed==='1') continue;
    el.dataset.inlineProcessed='1';

    const html = el.innerHTML;
    if(/<pre|<code|contenteditable/i.test(html)) continue;

    let out = html;

    // 1. Palavra:  → <strong>
    out = out.replace(rxKV, (m, sp, key)=> `${sp}<strong class="kv-key">${key}:</strong>`);

    // 2. ( ... )   → span-paren
    out = out.replace(rxParen, (m, inside)=> `<span class="span-paren">(${inside})</span>`);

    // 3. [ ... ] / [[ ... ]]  → chip/chip-btn
    out = out.replace(rxChip, (m, dbl, sgl)=>{
      const label = (dbl||sgl||'').trim();
      return `<span class="${dbl?'chip-btn':'chip'}" data-chip="${esc(label)}">${esc(label)}</span>`;
    });

    el.innerHTML = out;
  }
};

/* 2) Perguntas → .q-card (frases que terminam com '?') */
const processQuestions=(root=document)=>{
  const paras = $$('p', root).filter(n=>!n.closest('.q-card, pre, code, .no-beauty'));
  for(const p of paras){
    const txt = (p.innerText||'').trim();
    if(txt.endsWith('?') && !p.dataset.qProcessed){
      p.dataset.qProcessed='1';
      const wrap=document.createElement('div'); wrap.className='q-card';
      wrap.innerHTML = `<div class="q-ico">?</div><div class="q-body">${esc(txt)}</div>`;
      p.replaceWith(wrap);
    }
  }
};

/* 3) Flow text: melhora texto corrido, cria heading leve se linha for "Algo:" sozinha */
const beautifyFlow=(root=document)=>{
  const container = root.querySelector('.flow-text') || root; // se já tiver classe, usa; senão aplica heurística suave
  $$('p', container).forEach(p=>{
    const t=(p.innerText||'').trim();
    if(/^[^:\n]{3,}:\s*$/.test(t)){ // linha que termina com ":" vira heading leve
      p.classList.add('kv-head');
    }
    // Quebra parágrafos absurdamente longos em dois (heurística)
    if(t.length>600 && t.includes('. ')){
      const mark = t.indexOf('. ', Math.floor(t.length/2));
      if(mark>0){
        const a=t.slice(0, mark+1), b=t.slice(mark+1);
        const p2=p.cloneNode(); p2.textContent=b.trim();
        p.textContent=a.trim();
        p.insertAdjacentElement('afterend', p2);
      }
    }
  });
};

/* 4) Listas copiáveis: badge + click copy */
const enableCopyLists=(root=document)=>{
  const lists = $$('.list-card', root);
  for(const card of lists){
    if(card.querySelector('.copy-badge')) continue;
    const badge = document.createElement('div');
    badge.className='copy-badge'; badge.textContent='copiar';
    card.appendChild(badge);
    card.addEventListener('click', e=>{
      // evita copiar quando clicou em link/botão dentro
      if(e.target.closest('a,button,.chip,.chip-btn')) return;
      const txt = [...card.querySelectorAll('li')].map(li=>li.innerText.trim()).join('\n');
      navigator.clipboard.writeText(txt).then(()=>{
        badge.textContent='copiado!'; setTimeout(()=>badge.textContent='copiar',1200);
      });
    }, {passive:true});
  }
};

/* 5) HTML/SVG pass-through
   - ```html-raw ... ``` → renderiza
   - <div data-raw-html>…(escapado)…</div> → renderiza
*/
const renderRawHTML=(root=document)=>{
  // code fence transform
  $$('pre code', root).forEach(code=>{
    const cls = (code.className||'').toLowerCase();
    if(cls.includes('language-html-raw') || cls.includes('lang-html-raw')){
      const raw = code.textContent;
      const box = document.createElement('div');
      box.className='raw-html-card';
      box.innerHTML = `<div class="raw-note">HTML/SVG renderizado a partir de bloco <code>html-raw</code></div>`;
      const slot = document.createElement('div');
      slot.className='raw-slot';
      // injeta SEM esc, assumindo que o autor confia no conteúdo
      slot.innerHTML = raw;
      box.appendChild(slot);
      const pre = code.closest('pre');
      pre.replaceWith(box);
    }
  });

  // <div data-raw-html>…</div>
  $$('div[data-raw-html]', root).forEach(div=>{
    const raw = div.textContent; // assume texto escapado pelo md
    const box = document.createElement('div'); box.className='raw-html-card';
    const slot = document.createElement('div'); slot.className='raw-slot';
    slot.innerHTML = raw;
    box.appendChild(slot);
    div.replaceWith(box);
  });
};

/* 6) Delegação de cliques para chips (colchetes) */
document.addEventListener('click', e=>{
  const chip = e.target.closest('.chip, .chip-btn');
  if(chip){
    const label = chip.dataset.chip||chip.textContent.trim();
    // dispara um evento customizado para teu bus/orquestrador
    const ev = new CustomEvent('chip:click', {detail:{label, source:'text-beauty-v3'}});
    document.dispatchEvent(ev);
  }
}, {passive:true});

/* 7) Orquestração */
const run=(ctx=document)=>{
  processInline(ctx);
  processQuestions(ctx);
  beautifyFlow(ctx);
  enableCopyLists(ctx);
  renderRawHTML(ctx);
};

if(window.__RENDERBUS__?.on){
  window.__RENDERBUS__.on('after', run, {name:'text-beauty-v3', priority: 96});
}else{
  (document.readyState==='loading') ? document.addEventListener('DOMContentLoaded',()=>run(document)) : run(document);
  new MutationObserver(m=>m.forEach(x=>x.addedNodes&&x.addedNodes.forEach(n=>n.nodeType===1&&run(n))))
    .observe(document.body,{childList:true,subtree:true});
}
})();
</script><script id="KOBLLUX_HOTFIX_BUNDLE_V1">
(()=>{'use strict';
if (window.__KOBLLUX_HOTFIX_BUNDLE_V1__) return;
window.__KOBLLUX_HOTFIX_BUNDLE_V1__ = true;

/* ========= Helpers ========= */
const $ = (q, r=document)=>r.querySelector(q);

/* Biblioteca (Stacks) */
function _libLoad(){ try{ return JSON.parse(localStorage.getItem('tl_library_v1')||'[]'); }catch{ return []; } }
function _libSave(arr){ localStorage.setItem('tl_library_v1', JSON.stringify(arr)); }
function _upsertDoc(doc){
  const arr = _libLoad();
  const idx = arr.findIndex(d => d.id === doc.id);
  if (idx >= 0) arr[idx] = doc; else arr.unshift(doc);
  _libSave(arr);
}

/* Render helper (não quebra se autoBuild não existir) */
async function _openText(md){
  window.__current_md = md || '';
  if (typeof autoBuild === 'function') autoBuild(md);
}

/* ========= 1) Exportar .md (iOS/Safari-safe) ========= */
window.exportMD = function(){
  const md = (typeof buildMDFromDOM === 'function' ? buildMDFromDOM() : (window.__current_md || ''));
  const blob = new Blob([md], { type: 'text/markdown;charset=utf-8' });
  const a = document.createElement('a');
  const base = (window.__current_title || 'export').replace(/[\\\/:*?"<>|]+/g,'-').slice(0,80) || 'export';
  a.download = base + '.md';
  a.href = URL.createObjectURL(blob);
  a.style.display = 'none';
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 1200);
  if (window.toast) toast('.md exportado');
};

/* ========= 2) Upload cria novo contexto (sem sobrescrever) ========= */
const _fi = document.getElementById('fileInput');
if (_fi && !_fi.dataset._ctxFix){
  _fi.dataset._ctxFix = '1';
  _fi.addEventListener('change', async (e)=>{
    const f = e.target.files?.[0];
    if (!f) return;
    const prev = document.getElementById('filePreview');
    if (prev) prev.textContent = 'Lendo ' + f.name + '...';

    // Zera o contexto para evitar sobrescrita no Salvar
    window.__current_doc_id = null;
    window.__current_title  = (f.name || 'Documento').replace(/\.(pdf|txt|md|markdown|html|htm)$/i, '');

    // PDF (se pdfjsLib estiver disponível)
    if (/\.(pdf)$/i.test(f.name) && window.pdfjsLib){
      try{
        const buf = await f.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: buf }).promise;
        let txt = '';
        for (let i = 1; i <= pdf.numPages; i++) {
          const p = await pdf.getPage(i);
          const c = await p.getTextContent();
          txt += c.items.map(it => it.str).join(' ') + '\n';
        }
        await _openText(txt);
      }catch(err){
        console.warn('[upload pdf] falhou:', err);
        await _openText(''); if (window.toast) toast('Falha ao ler PDF');
      }
    } else {
      // Demais extensões: lê como texto
      const txt = await f.text();
      await _openText(txt);
    }
  }, { capture: true });
}

/* ========= 3) Salvar vira update quando há __current_doc_id ========= */
(function(){
  window.saveCurrent = function(){
    const md = (typeof getCurrentMarkdown === 'function' ? getCurrentMarkdown() : (window.__current_md || ''));
    const ti = document.getElementById('docTitle');
    const titleFromH1 = md.match(/^\s*#\s+(.+)$/m)?.[1];
    const title = (ti && ti.value.trim()) || titleFromH1 || (window.__current_title || 'Sem título');
    const now = new Date().toISOString();

    const arr = _libLoad();
    const existing = arr.find(d => d.id === window.__current_doc_id);
    const id = window.__current_doc_id || (self.crypto?.randomUUID ? ('doc_' + crypto.randomUUID()) : ('doc_' + Date.now()));

    const doc = {
      id,
      title,
      md,
      bytes: md.length,
      createdAt: existing?.createdAt || now,
      updatedAt: now
    };

    _upsertDoc(doc);
    window.__current_doc_id = id;   // fixa o contexto
    window.__current_title  = title;
    localStorage.setItem('tl_last_doc_id', id);
    if (window.toast) toast(existing ? 'Atualizado em Stacks' : 'Salvo em Stacks');
  };
})();

/* ========= 4) Patches de ações (Stacks) ========= */
if (window.ACTIONS && !window.ACTIONS.__koblluxFixed){
  // open-doc: abre do acervo e seta contexto para update
  const _oldOpen = window.ACTIONS['open-doc'];
  window.ACTIONS['open-doc'] = function(el){
    const id = el?.dataset?.id;
    const doc = _libLoad().find(d => d.id === id);
    if (!doc) return;
    window.__current_doc_id = id;
    window.__current_title  = doc.title || '';
    window.__current_md     = doc.md || '';
    _openText(doc.md);
  };

  // md-doc: exporta .md (iOS-safe)
  window.ACTIONS['md-doc'] = function(el){
    const id = el?.dataset?.id;
    const doc = _libLoad().find(d => d.id === id);
    if (!doc) return;
    const blob = new Blob([doc.md||''], { type:'text/markdown;charset=utf-8' });
    const a = document.createElement('a');
    a.download = (doc.title || 'documento') + '.md';
    a.href = URL.createObjectURL(blob);
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 1200);
  };

  window.ACTIONS.__koblluxFixed = true;
}

/* ========= 5) Opcional: limpar SW + caches (PWA hard refresh) ========= */
window.forceHardRefresh = function(){
  (async()=>{
    try{
      const keys = await caches.keys();
      await Promise.all(keys.map(k => caches.delete(k)));
    }catch{}
    if ('serviceWorker' in navigator){
      try{
        const regs = await navigator.serviceWorker.getRegistrations();
        await Promise.all(regs.map(r => r.unregister()));
      }catch{}
    }
    location.reload();
  })();
};
})();
</script><script id="KOBLLUX_TTS_PATCH_V1">
(()=>{'use strict';
if(window.__KOBLLUX_TTS_PATCH_V1__) return;
window.__KOBLLUX_TTS_PATCH_V1__ = true;

const synth = window.speechSynthesis;
let speaking = false, paused = false;
let currentUtter = null;

/* ===== Botão ON/OFF ===== */
const fab = document.createElement('button');
fab.id = 'ttsToggle';
fab.textContent = '🔊';
fab.style.cssText = `
position:fixed;top:66px;right:16px;z-index:99999;
border:none;border-radius:50%;width:32px;height:32px;
font-size:24px;cursor:pointer;
background:linear-gradient(42deg,#0f0,#0ff);
box-shadow:0 0 12px rgba(0,255,255,.4);
`;
fab.title = 'TTS: desligado';
document.body.appendChild(fab);

/* ===== Funções ===== */
function readAll(){
  if(speaking) return;
  const area = document.querySelector('#renderArea, main, article, #book') || document.body;
  const blocks = [...area.querySelectorAll('h1,h2,h3,p,li,blockquote,section,div')]
    .map(x => x.innerText.trim()).filter(Boolean);
  if(!blocks.length){ toast?.('Nada para ler'); return; }

  speaking = true; paused = false;
  fab.style.background = 'linear-gradient(42deg,#0ff,#0f0)';
  fab.title = 'TTS: ligado';

  let i = 0;
  const readNext = ()=>{
    if(!speaking || i>=blocks.length){ stopTTS(); return; }
    const text = blocks[i];
    currentUtter = new SpeechSynthesisUtterance(text);
    currentUtter.lang = 'pt-BR';
    currentUtter.rate = 1.0;
    currentUtter.pitch = 1.0;
    currentUtter.volume = 1.0;

    const el = area.querySelectorAll('h1,h2,h3,p,li,blockquote,section,div')[i];
    if(el){ el.style.outline='2px solid #0ff'; el.scrollIntoView({behavior:'smooth',block:'center'}); }

    currentUtter.onend = ()=>{
      if(el) el.style.outline='none';
      i++; readNext();
    };
    synth.speak(currentUtter);
  };
  readNext();
}

function stopTTS(){
  if(currentUtter) synth.cancel();
  speaking = false; paused = false;
  fab.style.background = 'linear-gradient(42deg,#0f0,#0ff)';
  fab.title = 'TTS: desligado';
}

/* ===== Botão toggle ===== */
fab.addEventListener('click', ()=>{
  if(!speaking){ readAll(); }
  else{ stopTTS(); toast?.('Leitura parada'); }
});

/* ===== Teclas rápidas (opcional) ===== */
document.addEventListener('keydown', e=>{
  if(e.key==='F2'){ fab.click(); } // F2 = liga/desliga
});

})();
</script><script type="module">
  import { applyRGX } from './js/patches/MAP_RGX_v3_KOBLLUX.mjs';

  document.addEventListener('DOMContentLoaded', () => {
    // raiz onde o markdown é renderizado
    const root =
      document.querySelector('#reader') ||
      document.querySelector('#app')    ||
      document.body;

    // marca o root pra animação do TTS e estilo local
    root.dataset.koblluxRoot = '1';

    // ativa o engine (chips, callouts, botões, IA, TTS)
    applyRGX(root);
  });
</script><script type="module">
/* ============================================================
   Monolithic MD Generator (BUGADÃO) — v3
   - Default: "Glitch Mode" ON (windows-1252 decode)
   - Toggle Glitch/UTF-8 sem reupload (mantém bytes em cache)
   - Upload → textarea (staging), só render se pedir
   - Converter → MD / Converter+Gerar
   - Callouts inline ::info/::warn/::aside
   - Tabela pipe → lista-tabela (linhas "- "), coluna-chave → (parênteses)
   ============================================================ */
let MDGEN_GLITCH_MODE = true;
let __mdgen_lastBytes = null;   // ArrayBuffer dos bytes do último upload
let __mdgen_filename  = null;

function tryFindTextarea(){
  return document.querySelector('#srcText, #src, textarea[name="src"], textarea');
}

function decodeBytes(ab, label){
  try{
    const dec = new TextDecoder(label || (MDGEN_GLITCH_MODE ? 'windows-1252' : 'utf-8'), {fatal:false});
    return dec.decode(new Uint8Array(ab));
  }catch(e){
    console.warn('Decoder falhou, fallback utf-8', e);
    return new TextDecoder('utf-8').decode(new Uint8Array(ab));
  }
}

function setTextarea(text){
  const ta = tryFindTextarea();
  if(!ta) return;
  ta.value = text;
  ta.focus();
  ta.setSelectionRange(0, Math.min(text.length, 2000));
}

function generateSmartMD(input, opts={}){
  const o = Object.assign({ title:'Documento Convertido', addHeaderButtons:true, addMeta:true }, opts||{});
  let txt = String(input||'').replace(/\r\n?/g,'\n').replace(/[“”]/g,'"').replace(/[’‘]/g,"'").replace(/'''/g,'```');
  if(!/^#\s/m.test(txt)){ txt = `# ${o.title}\n\n` + txt; }

  const lines = txt.split('\n'), OUT=[]; let i=0;
  const KEY_WARN=/\b(atenç(ã|a)o|cuidado|risco|quebra|bug|perigo)\b/i;
  const KEY_INFO=/\b(nota|observa(ç|c)[aã]o|info|dica|lembrete)\b/i;
  const KEY_ASIDE=/\b(contexto|bastidor|extra|observa(ç|c)[aã]o lateral)\b/i;
  const KEY_OK=/\b(sucesso|ok|pronto|feito)\b/i;
  const KEY_Q=/\?\s*$/;
  function push(s){ OUT.push(s); }

  while(i<lines.length){
    let line=lines[i];
    if(/^\s*```/.test(line)){ push(line); i++; while(i<lines.length && !/^\s*```/.test(lines[i])) push(lines[i++]); if(i<lines.length) push(lines[i++]); continue; }
    const mFn=line.match(/^\s*["“”](.+function\s+[a-zA-Z_$][\w$]*\s*\([^)]*\)\s*\{.*\})["“”]\s*$/);
    if(mFn){ push('```js'); push(mFn[1]); push('```'); i++; continue; }
    const plain=line.trim();
    if(plain){
      if(KEY_WARN.test(plain)){  push(`::warn ${plain}`);  i++; continue; }
      if(KEY_ASIDE.test(plain)){ push(`::aside ${plain}`); i++; continue; }
      if(KEY_INFO.test(plain)){  push(`::info ${plain}`);  i++; continue; }
      if(KEY_OK.test(plain)){    push(`: ${plain}`);       i++; continue; }
      if(KEY_Q.test(plain)){     push(`? ${plain}`);       i++; continue; }
    }
    push(line); i++;
  }
  let md=OUT.join('\n');

  // Normaliza callouts multiline → linha única
  md = md.replace(
    /(^|\n)::(info|warn|aside|pulse|loop)\s*\n+([^:\n>][^\n]+(?:\n(?!::(info|warn|aside|pulse|loop)\b)[^\n]+)*)/gi,
    (m, pre, kind, body)=>`${pre}::${kind} ${body.replace(/\s*\n\s*/g,' ').trim()}`
  );

  // Tabelas pipe → lista-tabela (com coluna-chave opcional)
  md = md.replace(
    /(^|\n)\|([^\n]+)\|\n\|([ :\-|]+)\|\n((?:\|[^\n]+\|\n?)+)/g,
    (m, pre, headerRow, sepRow, bodyRows) => {
      const headers = headerRow.split('|').map(s=>s.trim());
      let keyIdx = -1;
      for(let i=0;i<headers.length;i++){
        const h=headers[i];
        if(/\(key\)|\[key\]|\*$/i.test(h) || /\b(chave|key)\b/i.test(h)){
          keyIdx=i; headers[i]=h.replace(/\s*(\(key\)|\[key\]|\*)\s*$/i,''); break;
        }
      }
      const body = bodyRows.trim().split('\n').map(r=>r.trim()).filter(Boolean).map(r=>{
        const cells = r.replace(/^\|/,'').replace(/\|$/,'').split('|').map(s=>s.trim());
        if(keyIdx>=0 && keyIdx<cells.length){ const c=cells[keyIdx]; cells[keyIdx]=/^\(.*\)$/.test(c)?c:`(${c})`; }
        return '- | '+cells.join(' | ')+' |';
      }).join('\n');
      return `${pre}|${headers.join(' | ')}|\n|${sepRow}|\n${body}\n`;
    }
  );

  if(o.addHeaderButtons){
    md = md.replace(/^#\s+.+$/m, (h1)=>`${h1}\n\n[[btn:gerar|Gerar]] [[btn:nested|Gerar (aninhado)]] [[btn:md|Salvar .md]] [[btn:pdf|Imprimir PDF]]\n`);
  }
  if(o.addMeta){ md += `\n\n::aside Documento gerado por MD Smart Generator (BUGADÃO v3)`;}
  return md;
}

// Exportador .md no padrão "lista-tabela"
function installExportMD_ListTable(){
  if(window.exportMD) return;
  window.exportMD = function(){
    const root=document.getElementById('root'); if(!root){ alert('Sem root'); return; }
    const parts=[];
    root.querySelectorAll('details.acc').forEach((d,secIdx)=>{
      const h=d.querySelector('summary h2'); if(h){ const mark='#'.repeat(secIdx===0?1:2); parts.push(`${mark} ${h.textContent.trim()}`); }
      d.querySelectorAll('.sec > *').forEach(el=>{
        if(el.matches('p')) parts.push(el.innerText.replace('Copiar','').trim());
        else if(el.matches('blockquote')) parts.push('> '+el.innerText.replace('Copiar','').trim());
        else if(el.matches('.callout')){
          const t=el.className.match(/\b(info|warn|tip|note|success|danger|aside|question)\b/);
          const kind=t?(t[1]==='note'?':': t[1]==='question'?'?': t[1]==='aside'?'::aside':'::'+t[1]):': ';
          parts.push(`${kind} `+el.innerText.replace('Copiar','').trim());
        }else if(el.matches('pre.md-code')){
          const code=el.querySelector('code')?.textContent||''; parts.push('```\n'+code+'\n```');
        }else if(el.matches('table.md-table')){
          const rows=[...el.querySelectorAll('tr')].map(tr=>[...tr.children].map(td=>td.innerText.trim()));
          if(rows.length){
            parts.push('| '+rows[0].join(' | ')+' |');
            parts.push('| '+rows[0].map(()=> '---').join(' | ')+' |');
            rows.slice(1).forEach(r=> parts.push('- | '+r.join(' | ')+' |'));
          }
        }else if(el.matches('ul,ol')){
          el.querySelectorAll('li').forEach(li=>parts.push('- '+li.innerText.trim()));
        }
      });
    });
    const blob=new Blob([parts.join('\n\n')],{type:'text/markdown'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='export_listTable.md'; a.click(); URL.revokeObjectURL(a.href);
    (window.toast||console.log)('.md exportado (lista-tabela)');
  };
}

// Upload → staging: LÊ COMO BYTES e decodifica com windows-1252 (Glitch ON) ou utf-8 (Glitch OFF)
function installUploadStagingBugadao(opts={}){
  const o = Object.assign({inputSelector:'input[type=file], #upload, #fileUpload, .upload-input'}, opts||{});
  const inputs = Array.from(document.querySelectorAll(o.inputSelector));
  const ta = tryFindTextarea();
  inputs.forEach(inp=>{
    if(inp.dataset.mdgenUpload==='1') return;
    inp.dataset.mdgenUpload='1';
    inp.addEventListener('change', (ev)=>{
      const f = ev.target.files && ev.target.files[0];
      if(!f) return;
      __mdgen_filename = f.name;
      const reader = new FileReader();
      reader.readAsArrayBuffer(f); // bytes puros
      reader.onload = ()=>{
        __mdgen_lastBytes = reader.result;
        const text = decodeBytes(__mdgen_lastBytes, MDGEN_GLITCH_MODE ? 'windows-1252' : 'utf-8');
        setTextarea(text);
        (window.toast||console.log)(`Upload carregado no input (staging, ${MDGEN_GLITCH_MODE?'GLITCH 1252':'UTF-8'})`);
      };
    }, false);
  });
}

// Monta UI (botões + toggle Glitch)
function mountMDGeneratorUI(){
  const tab=document.querySelector('#tab-text')||document.body;
  if(tab.querySelector('.btn-converter')) return;
  const ta = tryFindTextarea();
  const bar=document.createElement('div'); bar.style.display='flex'; bar.style.gap='8px'; bar.style.marginTop='8px'; bar.style.flexWrap='wrap';

  const b1=document.createElement('button'); b1.className='btn btn-converter'; b1.textContent='Converter → MD';
  b1.onclick=()=>{ const raw=(ta&&ta.value)?ta.value:''; const md=generateSmartMD(raw||'# Documento\n\nTexto aqui...'); if(ta){ ta.value=md; ta.focus(); ta.setSelectionRange(0,md.length);} (window.toast||console.log)('Texto convertido para MD'); };

  const b2=document.createElement('button'); b2.className='btn btn-gen-inteligente'; b2.textContent='Converter+Gerar';
  b2.onclick=()=>{ const raw=(ta&&ta.value)?ta.value:''; const md=generateSmartMD(raw||'# Documento\n\nTexto aqui...'); if(typeof window.autoBuild==='function'){ window.autoBuild(md); (window.toast||console.log)('Convertido e renderizado (ARN)'); } else { alert(md);} };

  const wrap=document.createElement('label'); wrap.style.display='inline-flex'; wrap.style.alignItems='center'; wrap.style.gap='6px';
  const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=true; cb.title='Glitch Mode (windows-1252)';
  const sp=document.createElement('span'); sp.textContent='😵‍💫 Glitch Mode';
  cb.onchange=()=>{
    MDGEN_GLITCH_MODE = cb.checked;
    if(__mdgen_lastBytes){
      const text = decodeBytes(__mdgen_lastBytes, MDGEN_GLITCH_MODE ? 'windows-1252' : 'utf-8');
      setTextarea(text);
      (window.toast||console.log)(`Re-decodificado ${__mdgen_filename||''} → ${MDGEN_GLITCH_MODE?'GLITCH 1252':'UTF-8'}`);
    }
  };
  wrap.appendChild(cb); wrap.appendChild(sp);

  bar.appendChild(b1); bar.appendChild(b2); bar.appendChild(wrap);
  tab.appendChild(bar);
}

function autoMountBugadao(){
  mountMDGeneratorUI();
  installUploadStagingBugadao();
  // exportador md
  installExportMD_ListTable();
  console.info('[MD Smart Generator · BUGADÃO v3] pronto.');
}
window.addEventListener('DOMContentLoaded', autoMountBugadao);
</script><script>
(()=>{ // IIFE – instala somente uma vez
  if(window.__KOB_TTS_V2_ACTIVE){ console.debug('[KOBLLUX TTS] já ativo'); return; }
  window.__KOB_TTS_V2_ACTIVE = true;

  const DOCKED = true;          // true = dock vertical fixo
  const DRAG_ENABLED = true;    // arrastar e lembrar posição
  const POS_KEY = 'kob_tts_dock_pos_v1';

  // ——— Mitigar conflito com TTS antigo ———
  try{
    if('speechSynthesis' in window){ window.speechSynthesis.cancel(); }
    if(window.__tts && typeof window.__tts.stop === 'function'){ try{ window.__tts.stop(); }catch(e){} }
    window.__tts = { set:()=>{}, speak:()=>{}, stop:()=>{} }; // no-op legacy
  }catch(e){}

  const synth = ('speechSynthesis' in window) ? window.speechSynthesis : null;
  if(!synth){ console.warn('[KOBLLUX TTS] SpeechSynthesis não disponível'); return; }

  // ——— Seletores tolerantes para raiz renderizada/analisada ———
  const ROOT_SELECTORS = ['#root','[data-analyzer-output]','.analyzer-output','#render','main','.content'];
  const getRoot = ()=> {
    for(const sel of ROOT_SELECTORS){
      const el = document.querySelector(sel);
      if(el) return el;
    }
    return document.body;
  };

  // ——— UI ———
  const ensurePanel = ()=>{
    let wrap = document.querySelector('.kob-tts-panel');
    let btnT = document.getElementById('btn-tts');
    let btnS = document.getElementById('btn-tts-sel');
    let btnX = document.getElementById('btn-tts-stop');
    let btnPrev = document.getElementById('btn-tts-prev');
    let btnNext = document.getElementById('btn-tts-next');
    let status = document.querySelector('[data-tts-status]');

    if(!(btnT && btnS && btnX && status)){
      wrap = document.createElement('div');
      wrap.className = 'kob-tts-panel' + (DOCKED ? ' is-dock' : '');
      wrap.innerHTML = DOCKED
        ? `
          <button id="btn-tts"       type="button" title="Ativar/Desativar leitura contínua" aria-pressed="false">🔊</button>
          <button id="btn-tts-prev"  type="button" title="Bloco anterior">◀</button>
          <button id="btn-tts-next"  type="button" title="Próximo bloco">▶</button>
          <button id="btn-tts-sel"   type="button" title="Ler apenas seleção">✂︎</button>
          <button id="btn-tts-stop"  type="button" title="Parar voz">■</button>
          <small data-tts-status>Pronto.</small>
        `
        : `
          <button id="btn-tts"       type="button" title="Ativar/Desativar leitura contínua">Voz: Off</button>
          <button id="btn-tts-prev"  type="button" title="Bloco anterior">◀</button>
          <button id="btn-tts-next"  type="button" title="Próximo bloco">▶</button>
          <button id="btn-tts-sel"   type="button" title="Ler apenas seleção">Ler seleção</button>
          <button id="btn-tts-stop"  type="button" title="Parar voz">Parar</button>
          <small data-tts-status>Pronto.</small>
        `;
      document.body.appendChild(wrap);
      btnT   = wrap.querySelector('#btn-tts');
      btnS   = wrap.querySelector('#btn-tts-sel');
      btnX   = wrap.querySelector('#btn-tts-stop');
      btnPrev= wrap.querySelector('#btn-tts-prev');
      btnNext= wrap.querySelector('#btn-tts-next');
      status = wrap.querySelector('[data-tts-status]');
    }else if(DOCKED){
      const w = btnT.closest('.kob-tts-panel'); if(w) w.classList.add('is-dock');
      btnT.textContent='🔊'; if(btnPrev) btnPrev.textContent='◀'; if(btnNext) btnNext.textContent='▶';
      btnS.textContent='✂︎'; btnX.textContent='■';
    }

    return {wrap, btnT, btnS, btnX, btnPrev, btnNext, status};
  };

  // ——— Toast seguro ———
  const toastSafe = (msg)=> { try{ if(typeof window.toast==='function') window.toast(msg); }catch(e){} };

  // ——— Voz ———
  let voice = null;
  const pickVoice = ()=>{
    const vs = synth.getVoices() || [];
    return vs.find(v=>/pt[-_]BR/i.test(v.lang))
        || vs.find(v=>/pt/i.test(v.lang))
        || vs[0] || null;
  };
  const ensureVoice = ()=> { if(!voice) voice = pickVoice(); };
  synth.onvoiceschanged = ()=> { if(!voice) voice = pickVoice(); };

  // ——— Estado TTS ———
  let blocks = [];        // [{ node, text }]
  let currentIndex = 0;
  let speaking = false;
  let utterance = null;
  let errorStreak = 0;
  const MAX_ERRORS = 3;

  // ——— Utils ———
  const setLabel = (btn, on)=>{
    if(!btn) return;
    if(DOCKED){ btn.setAttribute('aria-pressed', on ? 'true' : 'false'); btn.textContent = '🔊'; }
    else{ btn.textContent = 'Voz: ' + (on ? 'On' : 'Off'); }
  };
  const setStatus = (el, txt)=> { if(el) el.textContent = txt; };
  const clearHighlight = ()=> document.querySelectorAll('[data-tts-current]').forEach(el=>el.removeAttribute('data-tts-current'));
  const highlightCurrent = ()=>{
    clearHighlight();
    if(!blocks.length) return;
    const b = blocks[currentIndex]; if(!b || !b.node) return;
    b.node.setAttribute('data-tts-current','true');
    try{ b.node.scrollIntoView({behavior:'smooth', block:'center'});}catch(e){}
  };

  const BUILD_NODE_SEL = [
    'h1','h2','h3','h4','h5','h6',
    'p','li','blockquote','.callout',
    'pre.md-code','codeblock','table.md-table td','table.md-table th'
  ].join(',');

  const buildBlocksFromDOM = ()=>{
    const root = getRoot();
    const nodes = root.querySelectorAll(BUILD_NODE_SEL);
    const list = [];
    nodes.forEach(node=>{
      let text = (node.innerText || '').replace(/\bCopiar\b/g,'').trim();
      if(!text) return;
      list.push({ node, text });
    });
    blocks = list;
    currentIndex = 0;
    errorStreak = 0;
    setStatus(ui.status, blocks.length ? `TTS pronto: ${blocks.length} blocos.` : 'Nenhum bloco válido.');
    if(blocks.length) toastSafe('TTS pronto: ' + blocks.length + ' blocos');
  };

  const stopInternal = ()=>{
    speaking = false; errorStreak = 0;
    try{ synth.cancel(); }catch(e){}
    if(utterance){ try{ utterance.onend=null; utterance.onerror=null; }catch(e){}; utterance=null; }
    clearHighlight(); setLabel(ui.btnT, false); setStatus(ui.status, 'TTS parado.');
  };

  const speakCurrent = ()=>{
    if(!blocks.length) buildBlocksFromDOM();
    if(!blocks.length){ stopInternal(); return; }

    if(currentIndex < 0) currentIndex = 0;
    if(currentIndex >= blocks.length){ stopInternal(); toastSafe('Fim dos blocos'); return; }

    const b = blocks[currentIndex];
    if(!b || !b.text || !b.text.trim()){
      errorStreak++;
      if(errorStreak > MAX_ERRORS){ toastSafe('Muitos blocos vazios/erro. Pausado.'); stopInternal(); return; }
      currentIndex++; speakCurrent(); return;
    }

    try{ synth.cancel(); }catch(e){}
    ensureVoice();

    utterance = new SpeechSynthesisUtterance(b.text.trim());
    if(voice) utterance.voice = voice;
    utterance.lang = (voice && voice.lang) || 'pt-BR';
    utterance.rate = 1.0; utterance.pitch = 1.0; utterance.volume = 1.0;

    utterance.onend   = ()=>{ if(!speaking) return; currentIndex++; speakCurrent(); };
    utterance.onerror = ()=>{ if(!speaking) return; errorStreak++; (errorStreak>MAX_ERRORS)?(toastSafe('Erros seguidos. Pausado.'), stopInternal()):(currentIndex++, speakCurrent()); };

    highlightCurrent();
    setStatus(ui.status, `Lendo ${currentIndex+1}/${blocks.length}…`);
    synth.speak(utterance);
  };

  // ——— Controles ———
  const toggle = ()=>{
    if(speaking){ stopInternal(); toastSafe('Voz desativada'); return; }
    speaking = true; setLabel(ui.btnT, true);
    if(!blocks.length) buildBlocksFromDOM();
    speakCurrent(); toastSafe('Voz ativada');
  };
  const speakSelection = ()=>{
    const text = (window.getSelection && String(window.getSelection())) || '';
    const t = text.trim();
    if(!t){ toastSafe('Selecione um trecho primeiro'); return; }
    ensureVoice(); try{ synth.cancel(); }catch(e){}
    const u = new SpeechSynthesisUtterance(t);
    if(voice) u.voice = voice;
    u.lang = (voice && voice.lang) || 'pt-BR';
    u.rate = 1.0; u.pitch = 1.0; u.volume = 1.0;
    synth.speak(u);
  };
  const nextBlock = ()=>{ if(!blocks.length) buildBlocksFromDOM(); speaking = true; setLabel(ui.btnT, true); currentIndex++; speakCurrent(); };
  const prevBlock = ()=>{ if(!blocks.length) buildBlocksFromDOM(); speaking = true; setLabel(ui.btnT, true); currentIndex = Math.max(0, currentIndex-1); speakCurrent(); };

  // ——— Auto-wire: botões externos "TTS" / "ouvir TTS" ———
  const isTTSLabel = (el)=>{
    const t = (el.textContent||'').toLowerCase().replace(/\s+/g,' ').trim();
    return /\btts\b/.test(t) || t.includes('ouvir tts');
  };
  const bindExternal = (root=document)=>{
    const candidates = Array.from(root.querySelectorAll('button, a, [role="button"], .btn, .button'))
      .filter(el=>!el.dataset.kobTtsBound && isTTSLabel(el));
    candidates.forEach(el=>{
      el.dataset.kobTtsBound = '1';
      el.addEventListener('click', (e)=>{ e.preventDefault(); toggle(); }, { passive:false });
      el.title = (el.title||'') || 'Ativar/Desativar TTS';
    });
  };
  const mo = new MutationObserver((muts)=>{
    for(const m of muts){
      if(m.addedNodes) m.addedNodes.forEach(n=>{ if(n.nodeType===1) bindExternal(n); });
    }
  });

  // ——— Drag + persistência ———
  const applySavedDockPos = ()=>{
    try{
      const saved = JSON.parse(localStorage.getItem(POS_KEY)||'null');
      if(saved && typeof saved.left==='number' && typeof saved.bottom==='number'){
        document.documentElement.style.setProperty('--tts-dock-left', `${saved.left}px`);
        document.documentElement.style.setProperty('--tts-dock-bottom', `${saved.bottom}px`);
      }
    }catch(e){}
  };
  const enableDrag = (wrap)=>{
    if(!DRAG_ENABLED || !wrap) return;
    let startX=0, startY=0, startLeft=0, startBottom=0, dragging=false;

    const onDown = (ev)=>{
      const e = ev.touches ? ev.touches[0] : ev;
      dragging=true; wrap.classList.add('is-dragging');
      startX = e.clientX; startY = e.clientY;
      const cs = getComputedStyle(document.documentElement);
      startLeft   = parseFloat(cs.getPropertyValue('--tts-dock-left')) || 8;
      startBottom = parseFloat(cs.getPropertyValue('--tts-dock-bottom')) || 269;
      window.addEventListener('pointermove', onMove, {passive:false});
      window.addEventListener('pointerup', onUp, {passive:false});
      window.addEventListener('touchmove', onMove, {passive:false});
      window.addEventListener('touchend', onUp, {passive:false});
    };
    const onMove = (ev)=>{
      if(!dragging) return;
      const e = ev.touches ? ev.touches[0] : ev;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      const left = Math.max(0, startLeft + dx);
      const bottom = Math.max(0, startBottom - dy); // mover para cima aumenta bottom
      document.documentElement.style.setProperty('--tts-dock-left', `${left}px`);
      document.documentElement.style.setProperty('--tts-dock-bottom', `${bottom}px`);
    };
    const onUp = ()=>{
      if(!dragging) return;
      dragging=false; wrap.classList.remove('is-dragging');
      const cs = getComputedStyle(document.documentElement);
      const left   = parseFloat(cs.getPropertyValue('--tts-dock-left')) || 8;
      const bottom = parseFloat(cs.getPropertyValue('--tts-dock-bottom')) || 269;
      try{ localStorage.setItem(POS_KEY, JSON.stringify({left,bottom})); }catch(e){}
      window.removeEventListener('pointermove', onMove);
      window.removeEventListener('pointerup', onUp);
      window.removeEventListener('touchmove', onMove);
      window.removeEventListener('touchend', onUp);
    };

    wrap.addEventListener('pointerdown', onDown);
    wrap.addEventListener('touchstart', onDown);
  };

  // ——— Boot ———
  let ui = {wrap:null,btnT:null,btnS:null,btnX:null,status:null,btnPrev:null,btnNext:null};

  const boot = ()=>{
    applySavedDockPos();
    const got = ensurePanel();
    ui = {
      wrap:   got.wrap,
      btnT:   got.btnT,
      btnS:   got.btnS,
      btnX:   got.btnX,
      status: got.status,
      btnPrev: got.btnPrev,
      btnNext: got.btnNext,
    };
    setLabel(ui.btnT,false);
    setStatus(ui.status,'Pronto.');

    // binds painel
    ui.btnT   && ui.btnT.addEventListener('click', e=>{e.preventDefault(); toggle();});
    ui.btnS   && ui.btnS.addEventListener('click', e=>{e.preventDefault(); speakSelection();});
    ui.btnX   && ui.btnX.addEventListener('click', e=>{e.preventDefault(); stopInternal();});
    ui.btnPrev&& ui.btnPrev.addEventListener('click', e=>{e.preventDefault(); prevBlock();});
    ui.btnNext&& ui.btnNext.addEventListener('click', e=>{e.preventDefault(); nextBlock();});

    // teclado opcional (←/→)
    window.addEventListener('keydown', (ev)=>{
      if(ev.target && /input|textarea/i.test(ev.target.tagName)) return;
      if(ev.key==='ArrowRight'){ nextBlock(); }
      if(ev.key==='ArrowLeft'){ prevBlock(); }
    });

    // integra com ACTIONS (compat)
    window.ACTIONS = window.ACTIONS || {};
    const oldTTS = window.ACTIONS.tts;
    window.ACTIONS.tts = ()=>{ try{ toggle(); }catch(e){}; if(typeof oldTTS==='function'){ /* compat */ } };
    window.ACTIONS.ttsPrev = ()=>{ prevBlock(); };
    window.ACTIONS.ttsNext = ()=>{ nextBlock(); };
    window.ACTIONS.ttsStop = ()=>{ stopInternal(); };

    // expõe API global
    window.KOBLLUX_TTS = {
      rebuild: ()=>buildBlocksFromDOM(),
      play: ()=>{ if(!speaking){ speaking=true; setLabel(ui.btnT,true); } speakCurrent(); },
      stop: stopInternal,
      next: nextBlock,
      prev: prevBlock,
      info: ()=>({ blocks:blocks.length, currentIndex, speaking })
    };

    // Auto-wire em botões externos
    bindExternal(document);
    mo.observe(document.documentElement, {childList:true, subtree:true});

    // Drag opcional
    if(DOCKED && DRAG_ENABLED){ enableDrag(ui.wrap); }
  };

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', boot, { once:true });
  }else{
    boot();
  }
})();
</script><script>
(()=>{ if(window.__KOB_TTS_V32_ACTIVE) return; window.__KOB_TTS_V32_ACTIVE = true;

  /* ---------- Constantes & Preferências ---------- */
  const POS_KEY  = 'kob_tts_pos_v3';
  const PREF_KEY = 'kob_tts_prefs_v32';
  const ROOTS    = ['#root','[data-analyzer-output]','.analyzer-output','#render','main','.content'];
  const BLOCK_SEL= [
    'h1','h2','h3','h4','h5','h6',
    'p','li','blockquote','.callout','.equation','pre','td','th','codeblock'
  ].join(',');

  const PREFS = Object.assign({
    outline: true,
    asciiMode: 'describe',      // 'describe' | 'skip' | 'read'
    clickToSpeak: true,         // clicar no bloco inicia leitura
    preferMale: true            // prioridade de vozes
  }, readPrefs());

  /* ---------- Util ---------- */
  const $  = (q, r=document)=> r.querySelector(q);
  const $$ = (q, r=document)=> [...r.querySelectorAll(q)];
  const setCSS = (v,val)=> document.documentElement.style.setProperty(v,val);
  const toast  = (m)=> { try{ window.toast && window.toast(m); }catch{} };
  const getRoot= ()=> { for(const s of ROOTS){ const el=document.querySelector(s); if(el) return el; } return document.body; };

  /* ---------- Dock ---------- */
  const dock = document.querySelector('.kob-tts-dock') || (()=> {
    const d = document.createElement('div');
    d.className = 'kob-tts-dock';
    d.innerHTML = `
      <button id="tts-on"      title="Voz On/Off" aria-pressed="false">🔊</button>
      <button id="tts-prev"    title="Anterior">◀</button>
      <button id="tts-next"    title="Próximo">▶</button>
      <button id="tts-sel"     title="Ler seleção">✂︎</button>
      <button id="tts-stop"    title="Parar">■</button>
      <button id="tts-reread"  title="Re-Ler do início (abrir tudo)">⟳</button>
      <button id="tts-reset"   title="Reset + próxima seção">↻</button>
      <button id="tts-openall" title="Abrir Tudo (acordeons/detalhes)">◎</button>
      <button id="tts-grid"    title="Outline / Click-to-Speak">⌗</button>
      <button id="tts-voice"   title="Trocar Voz PT-BR (segurar: alterna masc/fem)">🎙</button>
      <small id="tts-status">Pronto.</small>
    `;
    document.body.appendChild(d);
    return d;
  })();

  /* Outline/grade */
  const outline = document.getElementById('kob-tts-outline') || (()=> {
    const o = document.createElement('div');
    o.id='kob-tts-outline';
    document.body.appendChild(o);
    return o;
  })();

  /* Drag e posição */
  applySavedPos();
  ;(()=>{ let sx=0,sy=0,sl=0,sb=0,drag=false;
    const onDown=(ev)=>{ const e=ev.touches?ev.touches[0]:ev; drag=true; dock.classList.add('is-drag'); sx=e.clientX; sy=e.clientY;
      const cs=getComputedStyle(document.documentElement);
      sl=parseFloat(cs.getPropertyValue('--tts-left'))||8;
      sb=parseFloat(cs.getPropertyValue('--tts-bottom'))||240;
      addEventListener('pointermove',onMove,{passive:false});
      addEventListener('pointerup',onUp,{passive:false});
      addEventListener('touchmove',onMove,{passive:false});
      addEventListener('touchend',onUp,{passive:false});
    };
    const onMove=(ev)=>{ if(!drag) return; const e=ev.touches?ev.touches[0]:ev;
      const dx=e.clientX-sx, dy=e.clientY-sy;
      setCSS('--tts-left',   Math.max(0, sl+dx)+'px');
      setCSS('--tts-bottom', Math.max(0, sb-dy)+'px');
    };
    const onUp=()=>{ if(!drag) return; drag=false; dock.classList.remove('is-drag'); savePos(); };
    dock.addEventListener('pointerdown',onDown); dock.addEventListener('touchstart',onDown);
  })();

  /* ---------- Speech & Vozes ---------- */
  const synth = ('speechSynthesis' in window) ? window.speechSynthesis : null;
  if(!synth){ console.warn('[TTS] SpeechSynthesis indisponível'); return; }
  try{ synth.cancel(); }catch{}

  let VOICES=[], baseVoice=null, voiceIdx=0;
  const MALE   = /(ricardo|thiago|jo[aã]o|daniel|felipe|bruno|rafael|marc(o|os)|c[aá]ssio)/i;
  const FEMALE = /(luciana|camila|fabiana|maria|helena|ana|carla|bia|let[ií]cia|fernanda)/i;

  function loadVoices(){
    VOICES = synth.getVoices()||[];
    const pt = VOICES.filter(v=>/pt/i.test(v.lang));
    const pri = (PREFS.preferMale? MALE : FEMALE);
    const sec = (PREFS.preferMale? FEMALE: MALE);
    baseVoice = pt.find(v=> pri.test(v.name||'')) || pt.find(v=> sec.test(v.name||'')) || pt[0] || VOICES[0] || null;
    voiceIdx  = Math.max(0, (pt.indexOf(baseVoice)));
  }
  synth.onvoiceschanged = ()=> loadVoices();
  loadVoices();

  function cycleVoice(){
    const pt = VOICES.filter(v=>/pt/i.test(v.lang));
    if(!pt.length) return;
    voiceIdx = (voiceIdx+1) % pt.length;
    baseVoice = pt[voiceIdx];
    setStatus(`Voz: ${baseVoice.name||baseVoice.lang}`);
  }
  function toggleVoicePriority(){ // segurar
    PREFS.preferMale = !PREFS.preferMale; savePrefs();
    loadVoices();
    setStatus(`Preferência: ${PREFS.preferMale?'masculina':'feminina'}`);
  }

  const ARCH_STYLES = {
    atlas:{ rate:.95, pitch:1.00, find:/\b(atlas)\b/i },
    nova:{ rate:1.12, pitch:1.12, find:/\b(nova)\b/i },
    vitalis:{ rate:1.08, pitch:1.05, find:/\b(vitalis)\b/i },
    pulse:{ rate:1.04, pitch:1.08, find:/\b(pulse|pulso)\b/i },
    serena:{ rate:.98, pitch:.96, find:/\b(serena)\b/i },
    kaos:{ rate:1.18, pitch:1.02, find:/\b(kaos)\b/i },
    genus:{ rate:1.00, pitch:1.00, find:/\b(genus)\b/i },
    lumine:{ rate:1.0, pitch:1.10, find:/\b(lumine)\b/i },
    rhea:{ rate:.97, pitch:1.00, find:/\b(rhea)\b/i },
    solus:{ rate:.93, pitch:.95, find:/\b(solus)\b/i },
    aion:{ rate:1.00, pitch:1.08, find:/\b(aion)\b/i }
  };
  function voiceStyleFor(text){
    for(const k in ARCH_STYLES){ if(ARCH_STYLES[k].find.test(text)) return ARCH_STYLES[k]; }
    return {rate:1.01,pitch:1.0};
  }
  function pickVoiceFor(text){
    const st = voiceStyleFor(text);
    return { voice: baseVoice, rate: st.rate, pitch: st.pitch };
  }

  /* ---------- Estado ---------- */
  let blocks=[], idx=0, speaking=false, u=null;

  function setPressed(btn,on){ btn?.setAttribute('aria-pressed', on?'true':'false'); }
  function setStatus(t){ const el=$('#tts-status',dock); if(!el) return; el.textContent=String(t); }
  function setStatusProgress(){ const el=$('#tts-status',dock); if(!el) return;
    if(!blocks.length){ el.textContent='0/0'; return; }
    el.textContent = `${Math.min(idx+1,blocks.length)}/${blocks.length}`;
  }

  function isAsciiArt(txt){
    const lines=txt.split(/\n/);
    const raw=txt.replace(/\s+/g,'');
    const nonWord=(raw.replace(/[A-Za-zÀ-ÿ0-9]/g,'').length)/(raw.length||1);
    const box=/[░▒▓█▀▄▌▐─═║╔╗╝╚╩╦╠╣┌┐└┘]/.test(txt);
    const wide=lines.some(l=> l.length>28 && l.replace(/[A-Za-zÀ-ÿ0-9]/g,'').length/(l.length||1)>.45);
    return box || nonWord>.42 || wide;
  }
  function describeAscii(txt){
    const t=txt||''; const parts=[];
    if(/[█▓▒░]{4,}/.test(t)) parts.push('massa sólida');
    if(/[─═]{4,}/.test(t))   parts.push('linhas horizontais');
    if(/[┼╬╦╩╠╣]/.test(t))   parts.push('grade geométrica');
    if(/[△▲▵]/.test(t))     parts.push('triângulos');
    if(/[○●◯]/.test(t))     parts.push('círculos');
    return 'Arte ASCII' + (parts.length?(' — '+parts.join(', ')):'');
  }
  function stripKaTeX(s){
    // remove $$…$$ e $…$ do KaTeX/LaTeX para não “soletrar” símbolos
    s = s.replace(/\$\$[\s\S]*?\$\$/g,' ');
    s = s.replace(/\$[^$]*\$/g,' ');
    return s;
  }
  function sanitize(txt,type){
    let s = stripKaTeX(txt||'');
s = s.replace(/[\\/*_|=`~^<>#${}()+\-]+/g, ' ');
s = s.replace(/\$begin:math:display\$\$[\s\S]*?\$\$end:math:display\$/g, ' ');
    s = s.replace(/:+/g, ', ').replace(/\.+/g, ', ');
    s = s.replace(/\s{2,}/g,' ').trim();
    if(type==='code')     return 'Bloco de código com ' + (txt.split(/\n/).length) + ' linhas.';
    if(type==='equation') return 'Equação matemática.';
    if(type==='ascii'){
      if(PREFS.asciiMode==='skip') return '';
      if(PREFS.asciiMode==='describe') return describeAscii(txt);
    }
    return s;
  }

  function sectionIndexOf(node){
    const secs = $$('#root details, details, .acc details, details.acc');
    const i = secs.findIndex(d=> d.contains(node));
    return i<0?0:i;
  }

  /* ---------- EXPANDIR TODOS ---------- */
  function expandAll(open=true){
    $$('details').forEach(d=> d.open = !!open);
    $$('[aria-expanded]').forEach(el=>{
      el.setAttribute('aria-expanded', open?'true':'false');
      const id = el.getAttribute('aria-controls');
      if(id){ const tgt = document.getElementById(id); if(tgt) tgt.hidden = !open; }
    });
    $$('[data-open]').forEach(el=> el.setAttribute('data-open', open?'1':'0'));
  }

  /* ---------- Build ---------- */
  function rebuild(){
    const root = getRoot();
    const nodes = $$(BLOCK_SEL, root);
    const out=[];
    for(const node of nodes){
      let raw = (node.innerText||'').replace(/\bCopiar\b/g,'').trim();
      if(!raw) continue;
      const type = node.matches('pre') ? 'code'
                : node.matches('.equation') ? 'equation'
                : isAsciiArt(raw) ? 'ascii'
                : node.matches('blockquote,.callout') ? 'quote'
                : node.matches('li') ? 'list'
                : node.matches('td,th') ? 'cell'
                : node.matches('h1,h2,h3,h4,h5,h6') ? 'heading'
                : 'para';
      out.push({ node, raw, type, sectionIdx: sectionIndexOf(node) });
    }
    blocks = out; idx = 0;
    setStatus(blocks.length ? `${blocks.length}/${blocks.length}` : '0/0');
  }

  /* ---------- Outline ---------- */
  function hideOutline(){ outline.style.display='none'; }
  function showOutlineFor(node){
    if(!PREFS.outline || !node) return hideOutline();
    const r=node.getBoundingClientRect();
    outline.style.display='block';
    outline.style.left  =(scrollX+r.left-6)+'px';
    outline.style.top   =(scrollY+r.top -6)+'px';
    outline.style.width =(r.width+12)+'px';
    outline.style.height=(r.height+12)+'px';
  }
  function highlight(){
    $$('[data-tts-current]').forEach(el=>el.removeAttribute('data-tts-current'));
    const b=blocks[idx]; if(!b) return;
    b.node.setAttribute('data-tts-current','true');
    try{ b.node.scrollIntoView({behavior:'smooth', block:'center'});}catch{}
    showOutlineFor(b.node);
  }
  addEventListener('scroll', ()=>{ const b=blocks[idx]; if(PREFS.outline && b) showOutlineFor(b.node); }, {passive:true});
  addEventListener('resize', ()=>{ const b=blocks[idx]; if(PREFS.outline && b) showOutlineFor(b.node); });

  /* ---------- Speak ---------- */
  function speakCurrent(){
    if(!blocks.length) rebuild();
    if(idx<0) idx=0;
    if(idx>=blocks.length){ stop(); toast('Fim.'); return; }

    const b = blocks[idx];
    const text = sanitize(b.raw, b.type);
    if(!text){ idx++; setStatusProgress(); return speakCurrent(); }

    try{ synth.cancel(); }catch{}
    const conf = pickVoiceFor(text);
    const u = new SpeechSynthesisUtterance(text);
    if(conf.voice) u.voice = conf.voice;
    u.lang = (conf.voice && conf.voice.lang) || 'pt-BR';
    u.rate = conf.rate; u.pitch = conf.pitch; u.volume=1;

    u.onend   = ()=>{ if(!speaking) return; idx++; setStatusProgress(); speakCurrent(); };
    u.onerror = ()=>{ if(!speaking) return; idx++; setStatusProgress(); speakCurrent(); };

    highlight();
    setStatusProgress();
    synth.speak(u);
  }
  function play(){ speaking=true; setPressed($('#tts-on',dock),true); if(!blocks.length) rebuild(); speakCurrent(); }
  function stop(){ speaking=false; try{ synth.cancel(); }catch{} setPressed($('#tts-on',dock),false); setStatus(blocks.length?`${Math.min(idx+1,blocks.length)}/${blocks.length}`:'Pausado.'); hideOutline(); }
  function toggle(){ speaking ? stop() : play(); }
  function next(){ if(!blocks.length) rebuild(); speaking=true; setPressed($('#tts-on',dock),true); idx++; setStatusProgress(); speakCurrent(); }
  function prev(){ if(!blocks.length) rebuild(); speaking=true; setPressed($('#tts-on',dock),true); idx=Math.max(0,idx-1); setStatusProgress(); speakCurrent(); }

  /* ---------- Reset & Re-Ler ---------- */
  function reset(opts={}){
    expandAll(true);
    stop(); rebuild();
    if(opts.nextSection===true){
      const cur = blocks[idx]?.sectionIdx ?? 0;
      const j = blocks.findIndex(b=> b.sectionIdx>cur);
      idx = j>=0 ? j : 0;
    }else if(typeof opts.sectionIndex==='number'){
      const j = blocks.findIndex(b=> b.sectionIdx===opts.sectionIndex);
      idx = j>=0 ? j : 0;
    }else{
      idx = 0;
    }
    setStatus(blocks.length?`${idx+1}/${blocks.length}`:'Pronto.');
    if(PREFS.outline && blocks[idx]) showOutlineFor(blocks[idx].node);
  }
  function rereadFromStart(){
    expandAll(true);
    rebuild();
    idx=0; play();
  }

  /* ---------- Click-to-Speak (Outline ON) ---------- */
  document.addEventListener('click', (ev)=>{
    const blk = ev.target.closest(BLOCK_SEL);
    if(!blk) return;
    const i = blocks.findIndex(b=> b.node===blk);
    if(i<0) return;
    idx=i;
    if(PREFS.outline) showOutlineFor(blk);
    if(PREFS.clickToSpeak){
      speaking=true; setPressed($('#tts-on',dock),true);
      speakCurrent();
    }else{
      setStatusProgress();
    }
  }, {passive:false});

  /* ---------- Seleção ---------- */
  $('#tts-sel',dock)?.addEventListener('click', (e)=>{
    e.preventDefault();
    const t = String(window.getSelection && window.getSelection()).trim();
    if(!t){ toast('Selecione um trecho'); return; }
    try{ synth.cancel(); }catch{}
    const conf = pickVoiceFor(t);
    const uu = new SpeechSynthesisUtterance(sanitize(t,'para'));
    if(conf.voice) uu.voice=conf.voice;
    uu.lang=(conf.voice&&conf.voice.lang)||'pt-BR'; uu.rate=conf.rate; uu.pitch=conf.pitch; uu.volume=1;
    synth.speak(uu);
  });

  /* ---------- Botões ---------- */
  $('#tts-on',dock)?.addEventListener('click', e=>{ e.preventDefault(); toggle(); });
  $('#tts-prev',dock)?.addEventListener('click', e=>{ e.preventDefault(); prev(); });
  $('#tts-next',dock)?.addEventListener('click', e=>{ e.preventDefault(); next(); });
  $('#tts-stop',dock)?.addEventListener('click', e=>{ e.preventDefault(); stop(); });
  $('#tts-reset',dock)?.addEventListener('click', e=>{ e.preventDefault(); reset({nextSection:true}); });
  $('#tts-reread',dock)?.addEventListener('click', e=>{ e.preventDefault(); rereadFromStart(); });
  $('#tts-openall',dock)?.addEventListener('click', e=>{ e.preventDefault(); expandAll(true); rebuild(); setStatusProgress(); });

  // Outline toggle (e click-to-speak junto)
  $('#tts-grid',dock)?.addEventListener('click', e=>{
    e.preventDefault();
    PREFS.outline = !PREFS.outline;
    PREFS.clickToSpeak = PREFS.outline;
    savePrefs();
    if(!PREFS.outline) hideOutline(); else { const b=blocks[idx]; b && showOutlineFor(b.node); }
    setPressed($('#tts-grid',dock), PREFS.outline);
  });
  setPressed($('#tts-grid',dock), PREFS.outline);

  // Voz: click = cicla, longpress = alterna prioridade masc/fem
  ;(()=>{ const btn=$('#tts-voice',dock); if(!btn) return;
    let pressT=null, pressed=false;
    const down=()=>{ pressed=true; pressT=setTimeout(()=>{ pressed='hold'; toggleVoicePriority(); }, 550); };
    const up=()=>{ if(pressT){ clearTimeout(pressT); pressT=null; } if(pressed===true){ cycleVoice(); } pressed=false; };
    btn.addEventListener('pointerdown', down); btn.addEventListener('pointerup', up); btn.addEventListener('pointerleave', up);
    btn.addEventListener('touchstart', down);  btn.addEventListener('touchend', up);
  })();

  /* ---------- Integrar com AUTO-GERAR do app ---------- */
  hook('autoBuild'); hook('autoBuildNested');
  function hook(name){
    if(typeof window[name]==='function'){
      const orig=window[name];
      window[name]=function(){
        const out=orig.apply(this, arguments);
        setTimeout(()=>{ expandAll(true); rebuild(); setStatusProgress(); }, 30);
        return out;
      }
    }
  }

  /* ---------- Boot ---------- */
  try{ window.__tts && typeof window.__tts.stop==='function' && window.__tts.stop(); }catch{}
  expandAll(true);
  rebuild();
  setStatusProgress();

  /* ---------- Helpers ---------- */
  function readPrefs(){ try{ return JSON.parse(localStorage.getItem(PREF_KEY)||'{}'); }catch{ return {}; } }
  function savePrefs(){ try{ localStorage.setItem(PREF_KEY, JSON.stringify(PREFS)); }catch{} }
  function applySavedPos(){
    try{
      const s=JSON.parse(localStorage.getItem(POS_KEY)||'null');
      if(s){ setCSS('--tts-left', s.left); setCSS('--tts-bottom', s.bottom); }
    }catch{}
  }
  function savePos(){
    try{
      const cs=getComputedStyle(document.documentElement);
      localStorage.setItem(POS_KEY, JSON.stringify({
        left: cs.getPropertyValue('--tts-left').trim(),
        bottom: cs.getPropertyValue('--tts-bottom').trim()
      }));
    }catch{}
  }
})();
</script><script>
/* PATCH: substitui a função pickVoiceFor original pela versão com HOOK */
function pickVoiceFor(text){
  // se existir um hook externo (IA), tenta classificar primeiro
  try{
    if (window.KOB_TTS_VOICE_STYLE_HOOK) {
      const arch = window.KOB_TTS_VOICE_STYLE_HOOK(text);
      if (arch) {
        const ST = {
          atlas:{rate:.95,pitch:0.80}, nova:{rate:1.09,pitch:1.18},
          vitalis:{rate:1.08,pitch:1.34}, pulse:{rate:1.02,pitch:1.12},
          serena:{rate:.98,pitch:.96}, kaos:{rate:1.13,pitch:1.02},
          genus:{rate:1.00,pitch:1.00}, lumine:{rate:1.00,pitch:1.28},
          rhea:{rate:.97,pitch:0.78}, solus:{rate:.93,pitch:.95},
          aion:{rate:1.00,pitch:1.08}
        }[String(arch).toLowerCase()];
        if (ST) return { voice: baseVoice, rate: ST.rate, pitch: ST.pitch };
      }
    }
  }catch(e){}
  // fallback regex (v32)
  const st = voiceStyleFor(text);
  return { voice: baseVoice, rate: st.rate, pitch: st.pitch };
}
</script><script id="KOB_TTS_V32_2">
(()=>{

  if(window.__KOB_TTS_V32_2_ACTIVE) return;
  window.__KOB_TTS_V32_2_ACTIVE = true;

  if(!('speechSynthesis' in window)){
    console.warn('SpeechSynthesis não suportado neste navegador.');
    return;
  }

  /* ========= ESTADO GLOBAL ========= */
  window.__tts_on = false;
  let __tts_voice = null;
  let __tts_utterance = null;

  function $(sel, root=document){ return root.querySelector(sel); }

  function getStatusEl(){
    return document.getElementById('tts-status');
  }

  function setStatus(msg){
    const el = getStatusEl();
    if(el) el.textContent = msg || '';
  }

  /* ========= VOZ ========= */
  function pickPTBRVoice(){
    const voices = speechSynthesis.getVoices();
    const cand =
      voices.find(v => /pt[-_]BR/i.test(v.lang)) ||
      voices.find(v => /pt\b/i.test(v.lang));
    return cand || voices[0] || null;
  }

  function ensureVoice(){
    if(!__tts_voice){
      __tts_voice = pickPTBRVoice();
    }
  }

  /* ========= LIMPEZA DO TEXTO ========= */
  function cleanText(raw){
    if(!raw) return '';
    let text = String(raw);

    // Remove rótulos e lixinhos óbvios
    text = text.replace(/Copiar/g, ' ');

    // Quebras de linha, \n, etc → espaço
    text = text.replace(/\\n|[\r\n]+/g, ' ');

    // Remove barras invertidas sobrando
    text = text.replace(/\\+/g, '');

    // Normaliza barras normais (evita "barra barra barra")
    text = text.replace(/[\/]{2,}/g, '/');

    // Espaços múltiplos → um espaço
    text = text.replace(/\s{2,}/g, ' ');

    // Trim final
    text = text.trim();

    // Se for muito curtinho ou só símbolo, não fala
    if(text.length <= 3) return '';

    return text;
  }

  /* ========= FALAR / PARAR ========= */
  function speakText(text){
    const cleaned = cleanText(text);
    if(!cleaned) return;

    if(!window.__tts_on){
      window.toast && toast('Ative a Voz (TTS)');
      return;
    }

    ensureVoice();
    speechSynthesis.cancel();
    setStatus('Lendo...');

    const u = new SpeechSynthesisUtterance(cleaned);
    __tts_utterance = u;

    if(__tts_voice) u.voice = __tts_voice;
    u.lang = (__tts_voice && __tts_voice.lang) || 'pt-BR';
    u.rate = 1.12;
    u.pitch = 0.78;
    u.volume = 1.0;

    u.onstart = () => setStatus('Lendo...');
    u.onend   = () => setStatus('Pronto');
    u.onerror = () => setStatus('Erro na voz');

    speechSynthesis.speak(u);
  }

  function stopTTS(){
    speechSynthesis.cancel();
    __tts_utterance = null;
    setStatus('Parado');
  }

  function getSelectedText(){
    return (window.getSelection && String(window.getSelection())) || '';
  }

  function setTTS(on){
    window.__tts_on = !!on;
    const btnFab = document.getElementById('btn-tts');
    if(btnFab){
      btnFab.textContent = 'Voz: ' + (window.__tts_on ? 'On' : 'Off');
    }
    const dockBtn = document.querySelector('[data-tts-btn="toggle"]');
    if(dockBtn){
      dockBtn.setAttribute('aria-pressed', window.__tts_on ? 'true' : 'false');
    }
    setStatus(window.__tts_on ? 'TTS ligado' : 'TTS desligado');
    window.toast && toast(window.__tts_on ? 'Voz ativada' : 'Voz desativada');
  }

  /* ========= DOCK LATERAL (se ainda não existir) ========= */
  function ensureTTSDock(){
    if(document.querySelector('.kob-tts-dock')) return;

    const dock = document.createElement('div');
    dock.className = 'kob-tts-dock';
    dock.innerHTML = `
      <button type="button" data-tts-btn="toggle" title="TTS On/Off" aria-pressed="false">◎</button>
      <button type="button" data-tts-btn="sel"    title="Ler seleção">▷</button>
      <button type="button" data-tts-btn="stop"   title="Parar voz">■</button>
      <span id="tts-status"></span>
    `;
    document.body.appendChild(dock);

    // status inicial
    setStatus('TTS desligado');

    // drag simples
    let dragging = false;
    let startX = 0, startY = 0;
    let startLeft = 0, startBottom = 0;

    dock.addEventListener('pointerdown', (ev)=>{
      if(!(ev.target instanceof HTMLElement)) return;
      // só arrasta se clicar na área vazia do dock (não nos botões)
      if(ev.target.closest('button')) return;

      dragging = true;
      dock.classList.add('is-drag');
      startX = ev.clientX;
      startY = ev.clientY;
      const cs = getComputedStyle(dock);
      startLeft = parseFloat(cs.left || '8');
      startBottom = parseFloat(cs.bottom || '240');
      dock.setPointerCapture(ev.pointerId);
    });

    dock.addEventListener('pointermove', (ev)=>{
      if(!dragging) return;
      const dx = ev.clientX - startX;
      const dy = ev.clientY - startY;
      const left = startLeft + dx;
      const bottom = startBottom - dy;
      dock.style.left = `${left}px`;
      dock.style.bottom = `${bottom}px`;
    });

    dock.addEventListener('pointerup', (ev)=>{
      if(!dragging) return;
      dragging = false;
      dock.classList.remove('is-drag');
      dock.releasePointerCapture(ev.pointerId);
    });
  }

  /* ========= LISTENERS GERAIS ========= */

  // Integra com botões existentes (FAB, MasterBlock, Dock)
  document.addEventListener('click',(e)=>{
    const t = e.target;
    if(!(t instanceof HTMLElement)) return;

    // 1) Botões dedicados (IDs existentes + dock)
    const isFabToggle = t.id === 'btn-tts';
    const isFabSel    = t.id === 'btn-tts-sel';
    const isFabStop   = t.id === 'btn-tts-stop';

    const dockRole = t.dataset.ttsBtn;

    if(isFabToggle || dockRole === 'toggle'){
      setTTS(!window.__tts_on);
      return;
    }
    if(isFabSel || dockRole === 'sel'){
      const sel = getSelectedText();
      if(sel) speakText(sel);
      else window.toast && toast('Selecione um trecho primeiro');
      return;
    }
    if(isFabStop || dockRole === 'stop'){
      stopTTS();
      return;
    }

    // 2) Se TTS desligado, não faz nada no resto
    if(!window.__tts_on) return;

    // 3) Clique em bloco de texto → ler
    const block = t.closest('p, li, blockquote, .coach, .callout, .equation, pre, td, th');
    if(!block) return;

    // Ignora cliques em zonas de UI
    if(t.closest('button,a,.emoji-btn,.chip,.btn,#fab,.menu,#ttsDock,.kob-tts-dock')) return;

    // NÃO ler código nem fórmulas (senão soletra tudo)
    if(block.matches('pre, .equation')) return;

    let text = block.innerText || '';
    speakText(text);
  });

  // Voicelist
  if('speechSynthesis' in window){
    speechSynthesis.onvoiceschanged = ()=>{
      if(!__tts_voice) __tts_voice = pickPTBRVoice();
    };
  }

  // Quando DOM carregar: garantir Dock
  window.addEventListener('DOMContentLoaded', ()=>{
    try{
      ensureTTSDock();
      // Ajusta label inicial do botão principal (se existir)
      const b = document.getElementById('btn-tts');
      if(b){
        b.textContent = 'Voz: ' + (window.__tts_on ? 'On' : 'Off');
      }
      setStatus('TTS desligado');
    }catch(err){
      console.error('Erro ao inicializar TTS dock', err);
    }
  });

  // Expor API global opcional
  window.__tts = {
    set: setTTS,
    speak: speakText,
    stop: stopTTS,
    status: setStatus
  };

})();
</script><script id="BIG_LOCK_RESET_v1">
(()=>{
  try{
    const K='kob_tts_prefs_v32';
    const p = Object.assign({preferMale:false,userLockedBase:false,voiceName:''}, JSON.parse(localStorage.getItem(K)||'{}'));
    p.preferMale=false; p.userLockedBase=false; p.voiceName='';
    localStorage.setItem(K, JSON.stringify(p));
  }catch{}
  // opcional: expõe um atalho pro console
  window.__kob_reset_tts_prefs = ()=>{
    try{
      const K='kob_tts_prefs_v32';
      const p = {preferMale:false,userLockedBase:false,voiceName:''};
      localStorage.setItem(K, JSON.stringify(p));
      return p;
    }catch(e){ return e&&e.message; }
  };
})();
</script><script id="KOBLLUX_VOICES_INTEGRATION">
(()=>{
  const ARCHETYPES = [
    { id:'atlas',   name:'Atlas',   tone:'Estratégico, metódico',        modulation:'Grave, ritmo calculado, dicção nítida.',        voice:'Reed',    rate:1.0,  pitch:0.93 },
    { id:'nova',    name:'Nova',    tone:'Vibrante, entusiasmado',       modulation:'Agudo, entusiasmado, ligeiramente rápido.',      voice:'Luciana', rate:1.063, pitch:1.34 },
    { id:'vitalis', name:'Vitalis', tone:'Energético, urgente',          modulation:'Rápido, intenso, motivacional.',                  voice:'Rocko',   rate:0.96, pitch:1.42 },
    { id:'pulse',   name:'Pulse',   tone:'Emocional, melódico',          modulation:'Fluido, tom médio/suave.',                       voice:'Reed',    rate:1.0, pitch:1.14 },
    { id:'artemis', name:'Artemis', tone:'Aventureiro, expansivo',       modulation:'Curioso, exploratório.',                         voice:'es_f',    rate:1.00, pitch:1.23 },
    { id:'serena',  name:'Serena',  tone:'Calmo, acolhedor',             modulation:'Suave, terapêutico, com pausas.',                voice:'Joana',   rate:0.92, pitch:0.90 },
    { id:'kaos',    name:'Kaos',    tone:'Desafiador, imprevisível',     modulation:'Intenso, ritmo entrecortado.',                   voice:'Rocko',   rate:1.09, pitch:1.28 },
    { id:'genus',   name:'Genus',   tone:'Prático, detalhista',          modulation:'Tom firme, foco na dicção.',                     voice:'Reed',    rate:0.98, pitch:1.20 },
    { id:'lumine',  name:'Lumine',  tone:'Alegre, brincalhão',           modulation:'Agudo, vibrante.',                               voice:'Flo',     rate:1.030, pitch:1.55 },
    { id:'solus',   name:'Solus',   tone:'Sábio, introspectivo',         modulation:'Grave, lento, eco sutil.',                       voice:'es_m',    rate:0.88, pitch:0.87 },
    { id:'rhea',    name:'Rhea',    tone:'Profundo, conectivo',          modulation:'Calmo, eco sutil.',                              voice:'Joana',   rate:1.02, pitch:0.59 },
    { id:'aion',    name:'Aion',    tone:'Futurista, metódico',          modulation:'Tom constante, progressivo.',                    voice:'Monica',  rate:0.98, pitch:1.00 },

    { id:'kobllux', name:'KOBLLUX', tone:'Núcleo do sistema, oracular',
      modulation:'Grave-médio, presença de comando, ritmo estável.',     voice:'es_m',  rate:0.98, pitch:0.48 },

    { id:'uno',     name:'Uno',     tone:'Essência, origem, foco',
      modulation:'Tom centrado, poucas variações, pausas marcadas.',     voice:'Grandma',    rate:0.90, pitch:0.93 },

    { id:'dual',    name:'Dual',    tone:'Espelho, contraste, jogo',
      modulation:'Alterna leve entre grave/agudo, ritmo pulsante.',      voice:'pt_m',    rate:1.02, pitch:1.02 },

    { id:'trinity', name:'Trinity', tone:'Síntese, tríade viva',
      modulation:'Voz estável com micro variações rítmicas em 3 tempos.', voice:'Sandy', rate:1.04, pitch:1.04 },

    { id:'infodose',name:'Infodose',tone:'Didático, carismático, dopamínico',
      modulation:'Tom amigável, ritmo de recompensa → curiosidade.',      voice:'Luciana', rate:1.06, pitch:0.96 },

    { id:'kodux',   name:'KODUX',   tone:'Criador do pulso, metaconsciência',
      modulation:'Grave, confiante, pausas longas, intenção forte.',      voice:'Reed pt-BR',  rate:0.86, pitch:0.68 },

    { id:'bllue',   name:'Bllue',   tone:'Emocional, sensorial, intuitivo',
      modulation:'Suave, quase sussurrado, ritmo ondulante.',            voice:'Joana',   rate:0.94, pitch:1.42 },

    { id:'minuz',   name:'Minuz',   tone:'Minimalista, direto, hacker',
      modulation:'Rápido, cortes secos, foco em termos técnicos.',       voice:'Reed',    rate:1.05, pitch:0.90 },

    { id:'hanah', name:'HANAH', tone:'Estético, simbólico, futurista',
      modulation:'Tom limpo, levemente ecoado, cadência ritualística.',  voice:'Monica',  rate:1.00, pitch:1.08 },

  { id:'metalux', name:'MetaLux', tone:'Estético, simbólico, futurista',
      modulation:'Tom limpo, levemente ecoado, cadência ritualística.',  voice:'Grandma',  rate:0.80, pitch:1.68 }

  ];

  window.KOBLLUX_VOICES = ARCHETYPES.reduce((acc,a)=>{
    acc[a.name.toLowerCase()] = a;
    return acc;
  },{});

  const origSpeak = window.speechSynthesis.speak.bind(window.speechSynthesis);
  window.speechSynthesis.speak = (u)=>{
    const text = (u.text||'').toLowerCase();
    const found = ARCHETYPES.find(a=> text.includes(a.name.toLowerCase()));
    if(found){
      const voices = speechSynthesis.getVoices();
      const match = voices.find(v=> v && v.name && v.name.includes(found.voice));
      if(match) u.voice = match;
      u.pitch = found.pitch;
      u.rate  = found.rate;
      console.log('🎙️ KOBLLUX Voice →', found.name, '→', found.voice, `(rate=${found.rate}, pitch=${found.pitch})`);
    }
    origSpeak(u);
  };

  console.log('⚡ KOBLLUX Voices Integradas —', ARCHETYPES.length, 'perfis ativos');

  // 🔔 avisa pro painel que as vozes estão prontas
  window.dispatchEvent(new Event('KOBLLUX_VOICES_READY'));

})();
</script><script id="KOB_VOICE_THEME_PATCH_V3">
(()=>{

  if (!('speechSynthesis' in window)) return;

  const root = document.documentElement;
  const body = document.body;
  const metaTheme = document.querySelector('meta[name="theme-color"]') || null;

  // Salva o tema neutro atual (INFODOXY) pra poder voltar depois
  const BASE = {};
  const VARS = ['--grad-a','--grad-b','--bg','--panel','--ink','--muted'];
  const cs = getComputedStyle(root);
  VARS.forEach(v=>{
    BASE[v] = cs.getPropertyValue(v) || '';
  });

  // Mapa de cores por arquétipo (fallback).
  // Se você já tiver um window.KOB_VOICE_THEME em outro lugar,
  // ele é mesclado por cima disso aqui.
  const DEFAULT_THEME = {
    neutral: {
      gradA: BASE['--grad-a'],
      gradB: BASE['--grad-b'],
      bg:    BASE['--bg'],
      panel: BASE['--panel'],
      ink:   BASE['--ink'],
      muted: BASE['--muted'],
      meta:  '#070b14'
    },

    atlas:   { gradA:'#00c4ff', gradB:'#0066ff', bg:'#050814', panel:'#0b1020', ink:'#eaf6ff', muted:'#8aa4c8', meta:'#04101f' },
    nova:    { gradA:'#ff7ad9', gradB:'#ffb347', bg:'#140512', panel:'#20091f', ink:'#ffeefc', muted:'#ffb7e4', meta:'#2a0723' },
    vitalis: { gradA:'#00ff95', gradB:'#00ffd0', bg:'#04140e', panel:'#071e17', ink:'#eafff7', muted:'#8fdac2', meta:'#012018' },
    pulse:   { gradA:'#ff5fa7', gradB:'#5f8bff', bg:'#120517', panel:'#1b0a22', ink:'#ffeafd', muted:'#c79ddc', meta:'#24082a' },
    serena:  { gradA:'#7bc7ff', gradB:'#7bffe0', bg:'#03111a', panel:'#071823', ink:'#eaf6ff', muted:'#99bfd7', meta:'#031520' },
    kaos:    { gradA:'#ff4b81', gradB:'#ffdd55', bg:'#18040a', panel:'#250811', ink:'#ffeef4', muted:'#ffb3c9', meta:'#24030b' },
    genus:   { gradA:'#9b8fff', gradB:'#5fffe3', bg:'#070718', panel:'#0c0d22', ink:'#eef0ff', muted:'#a4a8dd', meta:'#08081f' },
    lumine:  { gradA:'#ffe66b', gradB:'#ff9bff', bg:'#170a06', panel:'#25120e', ink:'#fff7e3', muted:'#f3cfa2', meta:'#261308' },
    solus:   { gradA:'#6b8cff', gradB:'#341f5f', bg:'#050715', panel:'#090b1f', ink:'#e3e8ff', muted:'#9ea4d6', meta:'#050716' },
    rhea:    { gradA:'#3cffd2', gradB:'#3c8bff', bg:'#031411', panel:'#071d19', ink:'#eafffb', muted:'#8cd8c8', meta:'#031914' },
    aion:    { gradA:'#9c7bff', gradB:'#4fd5ff', bg:'#060414', panel:'#0c0920', ink:'#f0e9ff', muted:'#b19de4', meta:'#07051a' },

    kobllux: { gradA:'#00ffd0', gradB:'#00b3ff', bg:'#020812', panel:'#050d18', ink:'#eafcff', muted:'#8ac7dd', meta:'#010710' },
    uno:     { gradA:'#ffffff', gradB:'#8ee7ff', bg:'#05070b', panel:'#090b11', ink:'#f5f8ff', muted:'#aeb4c8', meta:'#05070b' },
    dual:    { gradA:'#ff7ab3', gradB:'#7af0ff', bg:'#0b0510', panel:'#13081c', ink:'#ffeefe', muted:'#c49ccf', meta:'#0c0714' },
    trinity: { gradA:'#7affd1', gradB:'#ffef7a', bg:'#060b05', panel:'#0b1409', ink:'#f7ffef', muted:'#b7d7a9', meta:'#050c05' },

    infodose:{ gradA:'#00d8d8', gradB:'#d800d8', bg:'#050813', panel:'#090f1e', ink:'#f2f5ff', muted:'#a1a8c8', meta:'#060818' },
    kodux:   { gradA:'#00f5ff', gradB:'#0078ff', bg:'#02060f', panel:'#050a16', ink:'#e5f5ff', muted:'#8bb5d6', meta:'#020610' },
    bllue:   { gradA:'#6be1ff', gradB:'#3c6bff', bg:'#020911', panel:'#04121d', ink:'#e7f6ff', muted:'#8fbad3', meta:'#020b13' },
    minuz:   { gradA:'#b7b7b7', gradB:'#4b4b4b', bg:'#050505', panel:'#101010', ink:'#f3f3f3', muted:'#a5a5a5', meta:'#050505' },
    hanah:   { gradA:'#ffb3f8', gradB:'#70d7ff', bg:'#130514', panel:'#1c0b1e', ink:'#ffeefe', muted:'#c9a4d8', meta:'#160819' },
    metalux: { gradA:'#f5ff8a', gradB:'#8af5ff', bg:'#080b02', panel:'#101507', ink:'#f9ffe6', muted:'#c6d39b', meta:'#090d03' },

    // você pode usar esses dois via JS manualmente se quiser:
    cooplux: { gradA:'#ff9b6b', gradB:'#ffde6b', bg:'#120606', panel:'#1d0b0a', ink:'#fff4ea', muted:'#e5b7a1', meta:'#170807' },
    fitlux:  { gradA:'#7cffaf', gradB:'#7cbcff', bg:'#04140a', panel:'#071c11', ink:'#e9fff2', muted:'#9fd0aa', meta:'#04150c' }
  };

  const THEMES = Object.assign({}, DEFAULT_THEME, (window.KOB_VOICE_THEME || {}));

  function setVar(name, value){
    if (value != null && value !== '') {
      root.style.setProperty(name, value);
    }
  }

  function applyTheme(id){
    const key = (id && String(id).toLowerCase()) || 'neutral';
    const cfg = THEMES[key] || THEMES.neutral;
    setVar('--grad-a', cfg.gradA);
    setVar('--grad-b', cfg.gradB);
    setVar('--bg',     cfg.bg);
    setVar('--panel',  cfg.panel);
    setVar('--ink',    cfg.ink);
    setVar('--muted',  cfg.muted);
    if (metaTheme && cfg.meta) metaTheme.setAttribute('content', cfg.meta);

    if (key === 'neutral'){
      body.removeAttribute('data-voice-arch');
    } else {
      body.setAttribute('data-voice-arch', key);
    }
  }

  // Exposto pra você usar no console ou em outros patches
  window.KOB_APPLY_VOICE_THEME = applyTheme;

  // Detecta arquétipo com base no texto + mapa de vozes atual
  function detectArchFromUtterance(u){
    const t = (u && u.text || '').toLowerCase();
    if (!t) return null;

    // se o bloco de vozes já estiver carregado, usa os nomes declarados lá
    if (window.KOBLLUX_VOICES){
      for (const k in window.KOBLLUX_VOICES){
        if (!Object.prototype.hasOwnProperty.call(window.KOBLLUX_VOICES,k)) continue;
        const arch = window.KOBLLUX_VOICES[k];
        const name = String(arch.name || k).toLowerCase();
        // procura "[Atlas", "Atlas]" ou o nome puro
        if (t.includes('['+name) || t.includes(name+']') || t.includes(name+' —') || t.includes('## '+name) || t.includes(name)){
          return (arch.id || name || k).toLowerCase();
        }
      }
    }

    // fallback: tenta pelas chaves do mapa de tema
    for (const k in THEMES){
      if (k === 'neutral') continue;
      if (t.includes(k.toLowerCase())) return k.toLowerCase();
    }

    return null;
  }

  // ==== override do speak, em cima do que JÁ existe ====
  const prevSpeak = window.speechSynthesis.speak.bind(window.speechSynthesis);
  const prevCancel = window.speechSynthesis.cancel.bind(window.speechSynthesis);

  window.speechSynthesis.speak = function(u){
    try{
      const archId = detectArchFromUtterance(u);
      if (archId){
        applyTheme(archId);
      } else {
        // se o texto não tem arquétipo explícito, mantém a última cor
        // (se quiser neutro por padrão entre blocos, troca pra applyTheme(null); aqui)
      }
    }catch(e){
      console.warn('[KOB_VOICE_THEME_PATCH] erro ao detectar arquétipo', e);
    }
    return prevSpeak(u);
  };

  window.speechSynthesis.cancel = function(){
    // quando parar tudo → volta pro neutro
    try{ applyTheme(null); }catch{}
    return prevCancel();
  };

  // inicia neutro garantindo que o snapshot do tema base prevaleça
  applyTheme(null);

})();
</script><script id="KOBLLUX_VOICE_THEME_PATCH">
(()=>{
  if (window.__KOBLLUX_VOICE_THEME_PATCH__) return;
  window.__KOBLLUX_VOICE_THEME_PATCH__ = true;

  const COLOR_MAP = {
    kobllux: {
      primary:'#00d8d8', secondary:'#d800d8', accent:'#39FFB6',
      bg_soft:'rgba(0,216,216,0.08)',
      glow:'0 0 18px rgba(0,216,216,0.55)'
    },
    cooplux:{
      primary:'#39FFB6', secondary:'#00d8d8', accent:'#ffffff',
      bg_soft:'rgba(57,255,182,0.10)',
      glow:'0 0 16px rgba(57,255,182,0.60)'
    },
    fitlux:{
      primary:'#FFC857', secondary:'#FFE39A', accent:'#22252f',
      bg_soft:'rgba(255,200,87,0.12)',
      glow:'0 0 16px rgba(255,200,87,0.70)'
    },
    atlas:{
      primary:'#6CCFF6', secondary:'#1B4965', accent:'#CAE9FF',
      bg_soft:'rgba(108,207,246,0.10)',
      glow:'0 0 14px rgba(108,207,246,0.55)'
    },
    nova:{
      primary:'#FF6FB5', secondary:'#FFD6E8', accent:'#FFE066',
      bg_soft:'rgba(255,111,181,0.12)',
      glow:'0 0 16px rgba(255,111,181,0.65)'
    },
    vitalis:{
      primary:'#00F5A0', secondary:'#00D9F5', accent:'#0b1720',
      bg_soft:'rgba(0,245,160,0.10)',
      glow:'0 0 18px rgba(0,245,160,0.65)'
    },
    pulse:{
      primary:'#A259FF', secondary:'#2D1B69', accent:'#F1E4FF',
      bg_soft:'rgba(162,89,255,0.12)',
      glow:'0 0 18px rgba(162,89,255,0.70)'
    },
    serena:{
      primary:'#7AD3A8', secondary:'#154734', accent:'#EAFBF3',
      bg_soft:'rgba(122,211,168,0.12)',
      glow:'0 0 16px rgba(122,211,168,0.65)'
    },
    kaos:{
      primary:'#FF5C8A', secondary:'#3D000F', accent:'#FFD6E0',
      bg_soft:'rgba(255,92,138,0.12)',
      glow:'0 0 20px rgba(255,92,138,0.75)'
    },
    genus:{
      primary:'#4EE1A0', secondary:'#193A3A', accent:'#E1FFF2',
      bg_soft:'rgba(78,225,160,0.10)',
      glow:'0 0 16px rgba(78,225,160,0.65)'
    },
    lumine:{
      primary:'#FFE066', secondary:'#FF9F1C', accent:'#2F2F40',
      bg_soft:'rgba(255,224,102,0.16)',
      glow:'0 0 18px rgba(255,224,102,0.75)'
    },
    rhea:{
      primary:'#00B894', secondary:'#055E55', accent:'#D1FFF6',
      bg_soft:'rgba(0,184,148,0.14)',
      glow:'0 0 16px rgba(0,184,148,0.65)'
    },
    solus:{
      primary:'#4B6584', secondary:'#0B1420', accent:'#E3EFFA',
      bg_soft:'rgba(75,101,132,0.16)',
      glow:'0 0 14px rgba(75,101,132,0.65)'
    },
    aion:{
      primary:'#00A8E8', secondary:'#001F54', accent:'#C4F1FF',
      bg_soft:'rgba(0,168,232,0.14)',
      glow:'0 0 16px rgba(0,168,232,0.70)'
    },
    uno:{
      primary:'#FFFFFF', secondary:'#BBBBBB', accent:'#FFFFFF',
      bg_soft:'rgba(255,255,255,0.05)',
      glow:'0 0 16px rgba(255,255,255,0.35)'
    },
    dual:{
      primary:'#FF9F1C', secondary:'#2EC4B6', accent:'#f5f5f5',
      bg_soft:'rgba(255,159,28,0.10)',
      glow:'0 0 14px rgba(255,159,28,0.65)'
    },
    trinity:{
      primary:'#00d8d8', secondary:'#FFE066', accent:'#ffffff',
      bg_soft:'rgba(0,216,216,0.09)',
      glow:'0 0 18px rgba(0,216,216,0.70)'
    },
    infodose:{
      primary:'#39FFB6', secondary:'#FFE066', accent:'#11141c',
      bg_soft:'rgba(57,255,182,0.12)',
      glow:'0 0 18px rgba(57,255,182,0.75)'
    },
    kodux:{
      primary:'#FF6FB5', secondary:'#5B2C6F', accent:'#FDEBFF',
      bg_soft:'rgba(91,44,111,0.18)',
      glow:'0 0 16px rgba(255,111,181,0.70)'
    },
    bllue:{
      primary:'#4A90E2', secondary:'#142850', accent:'#E3F2FF',
      bg_soft:'rgba(74,144,226,0.14)',
      glow:'0 0 16px rgba(74,144,226,0.70)'
    },
    minuz:{
      primary:'#FF3366', secondary:'#111111', accent:'#FFE3ED',
      bg_soft:'rgba(255,51,102,0.16)',
      glow:'0 0 16px rgba(255,51,102,0.75)'
    },
    hanah:{
      primary:'#FFB6C1', secondary:'#3C1F3C', accent:'#FFE9F0',
      bg_soft:'rgba(255,182,193,0.16)',
      glow:'0 0 16px rgba(255,182,193,0.70)'
    },
    metalux:{
      primary:'#B0E0E6', secondary:'#202733', accent:'#F0FBFF',
      bg_soft:'rgba(176,224,230,0.16)',
      glow:'0 0 18px rgba(176,224,230,0.70)'
    }
  };

  const root = document.documentElement;
  const body = document.body;

  function normalizeKey(s){
    return String(s||'').normalize('NFD')
      .replace(/\p{Diacritic}/gu,'')
      .toLowerCase()
      .replace(/[^a-z0-9]/g,'');
  }

  function detectArchKeyFromText(text){
    if(!text) return null;
    const raw = String(text);
    const trimmed = raw.trim();
    const lowAll  = trimmed.toLowerCase();

    // 1) [Nome] no começo do parágrafo
    const m = trimmed.match(/^\[([^\]]+)\]/);
    if(m){
      const namePart = m[1].split('—')[0].split('-')[0].trim();
      const k = normalizeKey(namePart);
      if(COLOR_MAP[k]) return k;
    }

    // 2) procura pelo nome dentro do texto
    for(const key of Object.keys(COLOR_MAP)){
      if(lowAll.includes(key)) return key;
    }

    // 3) fallback: hook externo (já existe no teu TTS)
    try{
      if(window.KOB_TTS_VOICE_STYLE_HOOK){
        const arch = window.KOB_TTS_VOICE_STYLE_HOOK(raw);
        const k = normalizeKey(arch);
        if(COLOR_MAP[k]) return k;
      }
    }catch(e){}

    return null;
  }

  function applyColorTheme(key){
    const cfg = COLOR_MAP[key];
    if(!cfg) return;

    root.style.setProperty('--kob-voice-primary',   cfg.primary  || '#00d8d8');
    root.style.setProperty('--kob-voice-secondary', cfg.secondary|| cfg.primary || '#d800d8');
    root.style.setProperty('--kob-voice-accent',    cfg.accent   || '#ffffff');
    root.style.setProperty('--kob-voice-bg-soft',   cfg.bg_soft  || 'rgba(0,0,0,0.25)');
    root.style.setProperty('--kob-voice-glow',      cfg.glow     || '0 0 0 transparent');

    if(body){
      body.setAttribute('data-voice-arch', key);
    }

    // se quiser integrar com outros painéis
    try{
      window.dispatchEvent(new CustomEvent('KOB_VOICE_COLOR',{
        detail:{ id:key, color:cfg }
      }));
    }catch(e){}
  }

  const prevSpeak = window.speechSynthesis.speak.bind(window.speechSynthesis);

  window.speechSynthesis.speak = function(u){
    try{
      if(u instanceof SpeechSynthesisUtterance){
        const key = detectArchKeyFromText(u.text||'');
        if(key){
          applyColorTheme(key);
          console.log('🎨 KOBLLUX THEME →', key);
        }
      }
    }catch(e){
      console.warn('KOBLLUX_VOICE_THEME_PATCH error:', e);
    }
    return prevSpeak(u);
  };

  console.log('⚡ KOBLLUX_VOICE_THEME_PATCH ativo — cores dinâmicas por arquétipo');

})();
</script><script id="KOB_THEME_TRANSITION_SOFT_OVERRIDE">
(()=>{
  if (window.__KOB_THEME_TRANSITION_SOFT_OVERRIDE__) return;
  window.__KOB_THEME_TRANSITION_SOFT_OVERRIDE__ = true;

  const css = `
  :root{
    /* duração padrão da transição de tema (pode ajustar aqui) */
    --kob-voice-theme-duration: 6600ms;
  }

  /* Tudo que costuma mudar de cor quando o tema troca */
  body,
  .nebula,
  .nebula-bg,
  .page,
  .page-inner,
  details.acc,
  .btn,
  #fab,
  .kob-tts-dock,
  .kob-tts-panel.is-dock {
    transition:
      background-color var(--kob-voice-theme-duration) ease-in-out,
      background        var(--kob-voice-theme-duration) ease-in-out,
      box-shadow        var(--kob-voice-theme-duration) ease-in-out,
      border-color      var(--kob-voice-theme-duration) ease-in-out,
      color             var(--kob-voice-theme-duration) ease-in-out;
  }
  `;

  const style = document.createElement('style');
  style.id = 'KOB_THEME_TRANSITION_SOFT_CSS';
  style.textContent = css;
  document.head.appendChild(style);

  console.log('🎨 KOB_THEME_TRANSITION_SOFT_OVERRIDE ativo (fade ~1.1s)');
})();
</script><script id="KOB_BG_FADE_OVERRIDE">
(()=>{
  if (window.__KOB_BG_FADE_OVERRIDE__) return;
  window.__KOB_BG_FADE_OVERRIDE__ = true;

  const css = `
  :root{
    --kob-voice-theme-duration: 7800ms;
  }

  /* Fade suave pro fundo principal e o glow nebuloso */
  body,
  .nebula{
    transition:
      background-color var(--kob-voice-theme-duration) ease-in-out !important,
      background        var(--kob-voice-theme-duration) ease-in-out !important,
      box-shadow        var(--kob-voice-theme-duration) ease-in-out !important,
      color             var(--kob-voice-theme-duration) ease-in-out !important,
      filter            var(--kob-voice-theme-duration) ease-in-out !important;
  }
  `;

  const style = document.createElement('style');
  style.id = 'KOB_BG_FADE_CSS';
  style.textContent = css;
  document.head.appendChild(style);

  console.log('🎨 KOB_BG_FADE_OVERRIDE ativo (body + .nebula com fade ~1.2s)');
})();
</script><script id="KOB_BUTTON_FADE_AND_TTS_SHADOW_PATCH">
(()=>{
  if (window.__KOB_BUTTON_FADE_AND_TTS_SHADOW_PATCH__) return;
  window.__KOB_BUTTON_FADE_AND_TTS_SHADOW_PATCH__ = true;

  const css = `
  :root{
    /* usa o mesmo timing do tema de voz, ou define aqui se quiser independente */
    --kob-voice-theme-duration: 1100ms;
  }

  /* Fades suaves para botões, chips e afins */
  .btn,
  .chip,
  button,
  #fab,
  .fab,
  .menu button,
  details.acc,
  details.acc summary,
  .kob-tts-dock button,
  .kob-tts-panel.is-dock button{
    transition:
      background-color var(--kob-voice-theme-duration) ease-in-out,
      background        var(--kob-voice-theme-duration) ease-in-out,
      border-color      var(--kob-voice-theme-duration) ease-in-out,
      color             var(--kob-voice-theme-duration) ease-in-out,
      box-shadow        var(--kob-voice-theme-duration) ease-in-out;
  }

  /* Shadow mais discreto pro dock de TTS */
  .kob-tts-dock{
    box-shadow:
      0 6px 14px rgba(0,0,0,.30),
      inset 0 0 0 1px rgba(255,255,255,.04) !important;
  }
  `;

  const style = document.createElement('style');
  style.id = 'KOB_BUTTON_FADE_AND_TTS_SHADOW_CSS';
  style.textContent = css;
  document.head.appendChild(style);

  console.log('🎨 KOB_BUTTON_FADE_AND_TTS_SHADOW_PATCH ativo (fade botões + shadow TTS suave)');
})();
</script><script id="RTF_RENDER_INTEGRATION_V1">
(()=>{'use strict';

// — heurística: checa se o conteúdo parece RTF
function looksLikeRTF(text){
  if(!text) return false;
  const t = String(text).slice(0, 250);
  if(/^\s*{\\rtf1/i.test(t)) return true;
  if(/\\rtf1\\ansi/.test(t)) return true;
  const slashCount = (t.match(/\\/g) || []).length;
  if(slashCount > 12 && /\\(fonttbl|colortbl|viewkind|pard|stylesheet)\b/.test(t)) return true;
  return false;
}

// — decoder simples RTF -> texto / Markdown cru
function decodeRTF(raw){
  if(!raw) return '';
  let txt = String(raw);

  // normaliza quebras de linha
  txt = txt.replace(/\r\n?/g, '\n');

  // \par, \pard, \line -> \n
  txt = txt.replace(/\\par[d]?\b/g, '\n')
           .replace(/\\line\b/g, '\n');

  // \'hh (hex) -> char
  txt = txt.replace(/\\'([0-9a-fA-F]{2})/g, (_,hex)=>{
    const code = parseInt(hex,16);
    return Number.isFinite(code) ? String.fromCharCode(code) : '';
  });

  // \uNNNN? -> unicode
  txt = txt.replace(/\\u(-?\d+)\??/g, (_,num)=>{
    let code = parseInt(num,10);
    if(!Number.isFinite(code)) return '';
    if(code < 0) code = 65536 + code; // corrige negativos comuns
    try{ return String.fromCharCode(code); }catch{ return ''; }
  });

  // remove outros comandos RTF (\palavra, \palavraN)
  txt = txt.replace(/\\[a-zA-Z]+-?\d*(?:\s)?/g, '');

  // remove chaves de grupo { }
  txt = txt.replace(/[{}]/g, '');

  // compacta linhas em branco
  txt = txt.replace(/\n{3,}/g, '\n\n');

  return txt.trim();
}

// — wrap do autoBuild (flat)
if(typeof window.autoBuild === 'function'){
  const orig = window.autoBuild;
  window.autoBuild = function(text){
    let t = text;
    // se for RTF, decodifica antes de tudo
    if(looksLikeRTF(t)){
      try{
        const decoded = decodeRTF(t);
        // guarda o MD decodificado como “estado atual”
        window.__current_md = decoded;
        t = decoded;
        window.__current_title = (decoded.match(/^\s*#\s+(.+)$/m)||[])[1] || window.__current_title;
        window.toast && toast('RTF decodificado → MD');
      }catch(e){
        console.warn('[RTF_RENDER] erro ao decodificar RTF', e);
      }
    }
    return orig(t);
  };
}

// — wrap do autoBuildNested (aninhado)
if(typeof window.autoBuildNested === 'function'){
  const origN = window.autoBuildNested;
  window.autoBuildNested = function(text){
    let t = text;
    if(looksLikeRTF(t)){
      try{
        const decoded = decodeRTF(t);
        window.__current_md = decoded;
        t = decoded;
        window.__current_title = (decoded.match(/^\s*#\s+(.+)$/m)||[])[1] || window.__current_title;
        window.toast && toast('RTF decodificado → MD');
      }catch(e){
        console.warn('[RTF_RENDER] erro ao decodificar RTF (nested)', e);
      }
    }
    return origN(t);
  };
}

// — helper global, se você quiser brincar via console: RTF_RENDER.decode(textoRTF)
window.RTF_RENDER = {
  looksLike: looksLikeRTF,
  decode: decodeRTF
};

})();
</script><script id="KOBLLUX_ASCII_ANIM_V1">
(()=>{'use strict';
function initAsciiCarousel(root=document){
  const marks=[...root.querySelectorAll('p')].filter(p=>p.textContent.trim().toLowerCase().startsWith('::anim'));
  for(const mark of marks){
    const cfg=mark.textContent.trim().slice(6).trim();
    const ms=(/(\d{2,5})/.exec(cfg)||[])[1]||1200;
    const frames=[];
    let n=mark.nextSibling;
    while(n && !(n.nodeType===1 && n.matches('p') && n.textContent.trim().toLowerCase()==='::end')){
      if(n.nodeType===1 && (n.matches('figure.ascii-card')||n.matches('pre[class*="language-ascii"],pre.language-text'))){
        frames.push(n);
      }
      n=n.nextSibling;
    }
    if(!frames.length) continue;
    const wrap=document.createElement('div');
    wrap.className='ascii-anim'; wrap.dataset.interval=ms;
    mark.replaceWith(wrap);
    frames.forEach(f=>wrap.appendChild(f));
    if(n && n.textContent.trim().toLowerCase()==='::end') n.remove();
    setupAnim(wrap, +ms);
  }
}
function setupAnim(wrap, ms){
  const frames=[...wrap.children];
  frames.forEach((el,i)=>{ el.style.display=i?'none':'block'; el.classList.add('ascii-frame'); });
  let i=0, playing=true, t=null;
  function step(){ if(!playing) return; frames[i].style.display='none'; i=(i+1)%frames.length; frames[i].style.display='block'; t=setTimeout(step, ms); }
  t=setTimeout(step, ms);
  const ctrl=document.createElement('button'); ctrl.className='anim-ctrl'; ctrl.textContent='⏸︎';
  ctrl.onclick=()=>{ playing=!playing; ctrl.textContent=playing?'⏸︎':'▶︎'; if(playing){ t=setTimeout(step, ms);} else{ clearTimeout(t);} };
  wrap.prepend(ctrl);
}
document.addEventListener('DOMContentLoaded', ()=>initAsciiCarousel(document));
new MutationObserver(m=>m.forEach(x=>x.addedNodes&&x.addedNodes.forEach(n=>n.nodeType===1&&initAsciiCarousel(n))))
  .observe(document.body,{childList:true,subtree:true});
})();
</script><script id="RTF_RENDER_INTEGRATION_V1">
(()=>{'use strict';

// ===== Detectores =====
function looksLikeRTF(text){
  if(!text) return false;
  const t = String(text).slice(0, 250);
  if(/^\s*{\\rtf1/i.test(t)) return true;
  if(/\\rtf1\\ansi/.test(t)) return true;
  const slashCount = (t.match(/\\/g) || []).length;
  if(slashCount > 12 && /\\(fonttbl|colortbl|viewkind|pard|stylesheet)\b/.test(t)) return true;
  return false;
}

function looksLikeHTML(text){
  if(!text) return false;
  const t = String(text).slice(0, 400);
  if(/<!DOCTYPE html/i.test(t)) return true;
  if(/<html[\s>]/i.test(t)) return true;
  if(/<body[\s>]/i.test(t)) return true;
  // fallback: muitas tags de abertura
  const tagCount = (t.match(/<\w+/g)||[]).length;
  return tagCount > 5;
}

// ===== RTF → texto =====
function decodeRTF(raw){
  if(!raw) return '';
  let txt = String(raw);

  txt = txt.replace(/\r\n?/g, '\n');
  txt = txt.replace(/\\par[d]?\b/g, '\n')
           .replace(/\\line\b/g, '\n');

  txt = txt.replace(/\\'([0-9a-fA-F]{2})/g, (_,hex)=>{
    const code = parseInt(hex,16);
    return Number.isFinite(code) ? String.fromCharCode(code) : '';
  });

  txt = txt.replace(/\\u(-?\d+)\??/g, (_,num)=>{
    let code = parseInt(num,10);
    if(!Number.isFinite(code)) return '';
    if(code < 0) code = 65536 + code;
    try{ return String.fromCharCode(code); }catch{ return ''; }
  });

  txt = txt.replace(/\\[a-zA-Z]+-?\d*(?:\s)?/g, '');
  txt = txt.replace(/[{}]/g, '');
  txt = txt.replace(/\n{3,}/g, '\n\n');

  return txt.trim();
}

// ===== HTML → texto (estilo 78konvert) =====
function htmlToPlain(mdLike){
  let t = String(mdLike||'');
  // quebras básicas
  t = t.replace(/<br\s*\/?>/gi, '\n')
       .replace(/<\/p>/gi, '\n\n')
       .replace(/<\/div>/gi, '\n')
       .replace(/<\/li>/gi, '\n');

  // listas
  t = t.replace(/<li[^>]*>/gi, '- ');
  // headings → #
  t = t.replace(/<h1[^>]*>([\s\S]*?)<\/h1>/gi, (_m,g)=>'\n# '+g.trim()+'\n')
       .replace(/<h2[^>]*>([\s\S]*?)<\/h2>/gi, (_m,g)=>'\n## '+g.trim()+'\n')
       .replace(/<h3[^>]*>([\s\S]*?)<\/h3>/gi, (_m,g)=>'\n### '+g.trim()+'\n');

  // blockquote
  t = t.replace(/<blockquote[^>]*>([\s\S]*?)<\/blockquote>/gi, (_m,g)=>{
    const inner = g.replace(/<[^>]+>/g,'').trim();
    return inner ? '\n> '+inner+'\n' : '\n';
  });

  // remove qualquer outra tag
  t = t.replace(/<style[\s\S]*?<\/style>/gi, '')
       .replace(/<script[\s\S]*?<\/script>/gi, '')
       .replace(/<[^>]+>/g, '');

  // espaços & entidades simples
  t = t.replace(/&nbsp;/g, ' ')
       .replace(/&amp;/g, '&')
       .replace(/&lt;/g, '<')
       .replace(/&gt;/g, '>')
       .replace(/&quot;/g, '"')
       .replace(/&#39;/g, "'");

  t = t.replace(/[ \t]+\n/g, '\n')
       .replace(/\n{3,}/g, '\n\n');

  return t.trim();
}

// ===== Wraps nos builders =====
function preprocessMaybe(text){
  let t = text;
  if(!t) return t;

  if(looksLikeRTF(t)){
    try{
      const decoded = decodeRTF(t);
      window.__current_md = decoded;
      window.__current_title = (decoded.match(/^\s*#\s+(.+)$/m)||[])[1] || window.__current_title;
      window.toast && toast('RTF decodificado → MD');
      return decoded;
    }catch(e){
      console.warn('[RTF/HTML_RENDER] erro RTF', e);
      return t;
    }
  }

  if(looksLikeHTML(t)){
    try{
      const plain = htmlToPlain(t);
      window.__current_md = plain;
      window.__current_title = (plain.match(/^\s*#\s+(.+)$/m)||[])[1] || window.__current_title;
      window.toast && toast('HTML limpo → texto');
      return plain;
    }catch(e){
      console.warn('[RTF/HTML_RENDER] erro HTML', e);
      return t;
    }
  }

  return t;
}

// autoBuild (flat)
if(typeof window.autoBuild === 'function'){
  const orig = window.autoBuild;
  window.autoBuild = function(text){
    const t = preprocessMaybe(text);
    return orig(t);
  };
}

// autoBuildNested (aninhado)
if(typeof window.autoBuildNested === 'function'){
  const origN = window.autoBuildNested;
  window.autoBuildNested = function(text){
    const t = preprocessMaybe(text);
    return origN(t);
  };
}

// helper global p/ brincar no console
window.RTF_RENDER = {
  looksLikeRTF,
  looksLikeHTML,
  decodeRTF,
  htmlToPlain
};

})();
</script><script id="KOB_PATCH_FAB_AUTOCLOSE">
(function(){
  const fab = document.getElementById('fab');
  const toggle = document.getElementById('fab-toggle');
  if(!fab || !toggle) return;
  // Close when clicking an action
  document.addEventListener('click', (e)=>{
    const a = e.target.closest('[data-action]');
    if (a && fab.classList.contains('open')) fab.classList.remove('open');
  });
  // Close when clicking outside
  document.addEventListener('click', (e)=>{
    const withinFab = e.target.closest('#fab');
    if (!withinFab && fab.classList.contains('open')) fab.classList.remove('open');
  }, true);
})();
</script><script id="KOB_PATCH_CONVERTER">
function convertSourceToMD(raw){
  if (!raw) return '';
  // RTF → texto básico
  if (/^{\\rtf/i.test(raw)) {
    raw = raw
      .replace(/\\par[d]?/g, '\n')
      .replace(/\\tab/g, '\t')
      .replace(/\\'[0-9a-fA-F]{2}/g, ' ')      // escapes hex → espaço
      .replace(/\\[a-zA-Z]+\d*/g, '')          // comandos \b \i \fs...
      .replace(/[{}]/g, '')                    // remove braces do RTF
      .replace(/\n{2,}/g, '\n\n');
  }
  // normalizações
  let text = raw
    .replace(/[“”]/g,'"').replace(/[‘’]/g,"'")
    .replace(/\r\n?/g, '\n')
    .trim();

  // TABELISTA (pula 1–2; 3 = header; 4 = <auto>; 5+ dados)
  text = text.replace(
    /(?:^|\n)#[^\n]*\n#[^\n]*\n\s*([\w\W]*?)\n\s*<auto>\n([\w\W]*?)(?=\n{2,}|$)/g,
    function(_, headerLine, dataBlock){
      const header = headerLine.split('|').map(s=>s.trim()).filter(Boolean);
      if (!header.length) return _;
      const sep = '|' + header.map(()=> '---').join('|') + '|';
      const rows = dataBlock.split('\n')
        .map(l => l.trim())
        .filter(l => l && !l.startsWith('#'))
        .map(l => {
          const cols = l.split('|').map(s=>s.trim());
          return '| ' + cols.join(' | ') + ' |';
        });
      return '\n| ' + header.join(' | ') + ' |\n' + sep + '\n' + rows.join('\n') + '\n';
    }
  );

  // botões [[btn:acao|Rótulo]] → HTML
  text = text.replace(/\[\[btn:([a-z0-9_-]+)(?:\|([^\]]+))?\]\]/gi,
    function(_,act,label){ return '<button class="btn action" data-action="'+act+'">'+(label||act)+'</button>'; });

  // tokens [voz:] [arch:] saneados (mantidos para o TTS parser)
  text = text.replace(/\[voz:\s*([^\]]+)\s*\]/gi, '[voz:$1]')
             .replace(/\[arch:\s*([^\]]+)\s*\]/gi, '[arch:$1]');

  // fences simples: fecha ``` se contar ímpar
  const fences = (text.match(/```/g)||[]).length;
  if (fences % 2 === 1) text += '\n```';

  return text;
}

// Bind converter button if present
document.addEventListener('click',(e)=>{
  const btn = e.target.closest('#btn-converter');
  if(!btn) return;
  const ta = document.getElementById('srcText');
  if(!ta) return;
  const md = convertSourceToMD(ta.value||'');
  ta.value = md;
  if (window.toast) toast('Convertido (RTF→MD, tabelista, tokens, botões)');
});
</script><script>
(function(){
  const fab = document.getElementById('fab');
  if (!fab) return;

  fab.addEventListener('click', (e)=>{
    const btn = e.target.closest('[data-action]');
    if (!btn) return;

    // deixa a ação rodar normal, e logo em seguida fecha o menu
    setTimeout(()=> {
      fab.classList.remove('open');
    }, 0);
  });
})();
</script><script id="FORCE_LUCIANA_ARQ_OVERRIDE_v4">
(()=> {
  if (window.__FORCE_LUCIANA_ARQ_OVERRIDE_V4__) return;
  window.__FORCE_LUCIANA_ARQ_OVERRIDE_V4__ = true;

  if (!('speechSynthesis' in window)) return;
  const synth = window.speechSynthesis;

  // ===== Utils básicos =====
  const PT = v => /^pt/i.test(v.lang || '');
  const ES = v => /^es/i.test(v.lang || '');
  const NORM = s => String(s || '')
    .normalize('NFD').replace(/\p{Diacritic}/gu,'')
    .toLowerCase();

  function getVoicesSafe(){
    try { return synth.getVoices() || []; }
    catch { return []; }
  }

  // ===== Mapa de vozes por arquétipo (pode sobrescrever via window.ARQ_VOICE_MAP) =====
  const VOICE_MAP = Object.assign({
    Atlas:   'pt_m',
    Nova:    'Luciana',
    Vitalis: 'Rocko',
    Pulse:   'es_m',
    Artemis: 'Monica',
    Serena:  'Joana',
    Kaos:    'Rocko',
    Genus:   'pt_m',
    Lumine:  'Monica',
    Solus:   'es_m',
    Rhea:    'Joana',
    Aion:    'Monica'
  }, (window.ARQ_VOICE_MAP || {}));

  // expõe pra você editar no console, se quiser:
  //   setArchetypeVoiceMap({ Atlas:'Monica', Nova:'pt_f' })
  window.ARQ_VOICE_MAP = VOICE_MAP;

  // Heurísticas simples pros nomes típicos (atalho, não trava nada)
  const NAME_F_PT = /(luciana|vitor[ioa]|camila|maria|sofia|joana)/i;
  const NAME_M_PT = /(daniel|reed|ricardo|miguel|thiago|henrique|felipe|jo[aã]o)/i;
  const NAME_F_ES = /(conchita|m[oó]nica|monica|paulina|luz)/i;
  const NAME_M_ES = /(jorge|fred|diego|sebasti[aá]n|sebastian)/i;

  function pickBySpec(spec, vs){
    if (!spec) return null;
    const s = String(spec).trim().toLowerCase();

    // Tokens por idioma (pt_f, es_m, etc)
    if (s === 'pt_f') return vs.find(v => PT(v) && NAME_F_PT.test(v.name || '')) || vs.find(PT) || null;
    if (s === 'pt_m') return vs.find(v => PT(v) && NAME_M_PT.test(v.name || '')) || vs.find(PT) || null;
    if (s === 'es_f') return vs.find(v => ES(v) && NAME_F_ES.test(v.name || '')) || vs.find(ES) || null;
    if (s === 'es_m') return vs.find(v => ES(v) && NAME_M_ES.test(v.name || '')) || vs.find(ES) || null;

    // Idioma genérico
    if (s === 'pt')   return vs.find(PT) || null;
    if (s === 'es')   return vs.find(ES) || null;

    // Nome direto → parcial (ex: "Monica", "Luciana", "Reed")
    const exact = vs.find(v => NORM(v.name) === NORM(spec));
    if (exact) return exact;
    return vs.find(v => NORM(v.name).includes(NORM(spec))) || null;
  }

  // Detecta tag de arquétipo no começo do parágrafo: [Atlas], [Nova], etc
  const ARCH_RE = /^\s*\[\s*([a-zA-Z0-9_]+)\s*\]/;

  function applyArchetypeVoice(u, vs){
    try{
      const m = (u.text || '').match(ARCH_RE);
      if (!m) return false; // sem tag [Atlas] / [Nova] etc

      const rawArch = m[1];
      const archKey = rawArch[0].toUpperCase() + rawArch.slice(1).toLowerCase();

      const spec = VOICE_MAP[archKey];
      if (!spec) return false;

      const v = pickBySpec(spec, vs);
      if (v){
        u.voice = v;
        // NÃO força idioma: só herda, se não tiver nada definido
        if (!u.lang && v.lang) u.lang = v.lang;
        return true;
      }
      return false;
    }catch{
      return false;
    }
  }

  // ===== Fila + override leve do speak (sem Luciana/base forçada) =====
  const NATIVE_SPEAK  = window.__KOB_NATIVE_SPEAK__  || synth.speak.bind(synth);
  const NATIVE_CANCEL = window.__KOB_NATIVE_CANCEL__ || synth.cancel.bind(synth);
  window.__KOB_NATIVE_SPEAK__  = NATIVE_SPEAK;
  window.__KOB_NATIVE_CANCEL__ = NATIVE_CANCEL;

  let VOICES    = getVoicesSafe();
  let ready     = !!VOICES.length;
  const Q       = [];
  let polTimer  = null;
  let tries     = 0;

  function refreshVoices(){
    VOICES = getVoicesSafe();
    if (VOICES.length){
      ready = true;
      drainQueue();
      if (polTimer){ clearInterval(polTimer); polTimer = null; }
    }
  }

  function ensureVoices(){
    if (ready) return;
    if (typeof synth.onvoiceschanged === 'object'){
      synth.onvoiceschanged = refreshVoices;
    }
    if (!polTimer){
      polTimer = setInterval(()=>{
        tries++;
        refreshVoices();
        if (ready || tries > 40){
          clearInterval(polTimer);
          polTimer = null;
        }
      }, 150);
    }
  }

  function wireUtterance(u){
    try{
      if (u.__kob_wired_v4) return;
      u.__kob_wired_v4 = true;

      // Só mexe se tiver tag de arquétipo; se não, deixa o TTS padrão decidir a voz
      applyArchetypeVoice(u, VOICES);
    }catch(e){
      console.warn('FORCE_LUCIANA_ARQ_OVERRIDE_v4 wireUtterance error', e);
    }
  }

  function drainQueue(){
    while(Q.length){
      const u = Q.shift();
      if (u.__kob_spoken_v4) continue;
      wireUtterance(u);
      u.__kob_spoken_v4 = true;
      NATIVE_SPEAK(u);
    }
  }

  synth.speak = function(u){
    if (!(u instanceof SpeechSynthesisUtterance)) return NATIVE_SPEAK(u);

    ensureVoices();
    if (!ready || !VOICES.length){
      Q.push(u);
      return;
    }

    wireUtterance(u);
    return NATIVE_SPEAK(u);
  };

  synth.cancel = function(){
    Q.length = 0;
    return NATIVE_CANCEL();
  };

  // prewarm leve
  refreshVoices();

  // helper opcional pra ajustar mapa via código:
  window.setArchetypeVoiceMap = (m)=> Object.assign(VOICE_MAP, m || {});

})();
</script><script id="KOB_TTS_ARCH_GATILHO_PATCH_V1">
(()=>{'use strict';
  if (!('speechSynthesis' in window)) {
    console.warn('KOB_TTS_ARCH_GATILHO_PATCH_V1: SpeechSynthesis não disponível.');
    return;
  }
  if (window.__KOB_TTS_ARCH_GATILHO_PATCH_V1__) return;
  window.__KOB_TTS_ARCH_GATILHO_PATCH_V1__ = true;

  const synth = window.speechSynthesis;
  const prevSpeak = synth.speak.bind(synth); // respeita patches anteriores

  // Mapa de vozes já existente (Atlas, Nova, etc)
  const VOICE_MAP = (window.ARQ_VOICE_MAP || {});
  const ARCH_KEYS = Object.keys(VOICE_MAP);
  if (!ARCH_KEYS.length){
    console.warn('KOB_TTS_ARCH_GATILHO_PATCH_V1: VOICE_MAP vazio, nada a fazer.');
  }

  // 🔑 Gatilhos de frase (você pode editar/expandir depois no console)
  const DEFAULT_TRIGGERS = {
    Atlas: [
      /\bupa[-\s]*atlas\b/i,
      /\bportal\s*\[\s*atlas\s*\]/i
    ],
    Nova: [
      /\bvia\s*\[\s*nova\s*\]/i,
      /\bmente nova\b/i
    ],
    Lumine: [
      /\blumine\b/i,
      /\barch[-\s]*lumine\b/i
    ]
    // adiciona mais se quiser…
  };

  // Mescla default + o que você definir manualmente:
  const TRIGGERS = Object.assign({}, DEFAULT_TRIGGERS, (window.ARQ_TRIGGERS || {}));
  window.ARQ_TRIGGERS = TRIGGERS; // expõe pra você brincar

  // Heurísticas de idioma básicas (pt/es)
  const PT    = v => /^pt\b/i.test(v.lang || '');
  const ES    = v => /^es\b/i.test(v.lang || '');

  const NORM = s => String(s || '')
    .normalize('NFD')
    .replace(/\p{Diacritic}/gu, '')
    .toLowerCase();

  function getVoicesSafe(){
    try { return synth.getVoices() || []; }
    catch { return []; }
  }

  function pickBySpec(spec, vs){
    if (!spec) return null;
    const s = String(spec).trim().toLowerCase();

    // Tokens por idioma (pt_f, es_m, etc)
    const NAME_F_PT = /(luciana|vitor[ioa]|camila|maria|sofia|joana)/i;
    const NAME_M_PT = /(daniel|reed|ricardo|miguel|thiago|henrique|felipe|jo[aã]o)/i;
    const NAME_F_ES = /(conchita|m[oó]nica|monica|paulina|luz)/i;
    const NAME_M_ES = /(jorge|fred|diego|sebasti[aá]n|sebastian)/i;

    if (s === 'pt_f') return vs.find(v => PT(v) && NAME_F_PT.test(v.name || '')) || vs.find(PT) || null;
    if (s === 'pt_m') return vs.find(v => PT(v) && NAME_M_PT.test(v.name || '')) || vs.find(PT) || null;
    if (s === 'es_f') return vs.find(v => ES(v) && NAME_F_ES.test(v.name || '')) || vs.find(ES) || null;
    if (s === 'es_m') return vs.find(v => ES(v) && NAME_M_ES.test(v.name || '')) || vs.find(ES) || null;

    if (s === 'pt')   return vs.find(PT) || null;
    if (s === 'es')   return vs.find(ES) || null;

    const exact = vs.find(v => NORM(v.name) === NORM(spec));
    if (exact) return exact;
    return vs.find(v => NORM(v.name).includes(NORM(spec))) || null;
  }

  // 🎯 Detecta arquétipo a partir de TODAS as formas de tag + frases de gatilho
  function detectArchetypeKey(text){
    if (!text || !ARCH_KEYS.length) return null;
    const raw   = String(text);
    const lower = raw.toLowerCase();

    for (const key of ARCH_KEYS){
      const n = key.toLowerCase();

      // [Atlas], [[Atlas]], (((Atlas))), {Atlas}, <Atlas>
      const bracket = new RegExp(`[\$begin:math:display$\\\\(\\\\{<]+\\\\s*${n}\\\\s*[\\$end:math:display$\\)\\}>]+`);
      if (bracket.test(lower)) return key;

      // Nome no início com : ou traço — ex: "Atlas: ..." ou "Nova — ..."
      const header = new RegExp(`^\\s*${n}\\s*[:\\-–—·>]`);
      if (header.test(lower)) return key;

      // Nome isolado entre espaços com "modo tag" ex: "::Atlas::"
      const middle = new RegExp(`[\\s\\|:>\\-\\[]${n}[\\s\\|<\\-:!,.?]`);
      if (middle.test(lower)) return key;

      // Frases de gatilho custom
      const arr = TRIGGERS[key] || [];
      for (const rx of arr){
        try{
          if (rx.test(raw) || rx.test(lower)) return key;
        }catch(e){}
      }
    }
    return null;
  }

  // Opcional: remover tags de arquétipo do texto falado (pra não ler "[Atlas]" etc)
  function stripArchetypeTags(text, key){
    if (!text || !key) return text;
    const n = key.toLowerCase();

    // remove [Atlas], ((Atlas)), {{Atlas}}, <Atlas>, [[Atlas]] etc
    const genericBrackets = new RegExp(`[\\[\$begin:math:text$\\\\{<]+\\\\s*${n}\\\\s*[\\\\]\\$end:math:text$\\}>]+\\s*`, 'ig');
    let out = text.replace(genericBrackets, '');

    // remove "Atlas: " no começo da linha
    const header = new RegExp(`^\\s*${n}\\s*[:\\-–—·>]\\s*`, 'i');
    out = out.replace(header, '');

    return out.trim() || text;
  }

  synth.speak = function(u){
    try{
      if (u instanceof SpeechSynthesisUtterance && ARCH_KEYS.length){
        let text   = String(u.text || '');
        const arch = detectArchetypeKey(text);

        if (arch){
          const voices = getVoicesSafe();
          const spec   = VOICE_MAP[arch];
          const v      = spec ? pickBySpec(spec, voices) : null;

          if (v){
            u.voice = v;
            if (!u.lang && v.lang) u.lang = v.lang;
            // marca pra debug / painel
            u.__kob_arch = arch;
            // limpa as tags pra não serem lidas
            u.text = stripArchetypeTags(text, arch);
            console.log('🎙️ ARCH_GATILHO', arch, '→', v.name, v.lang);
          }
        }
      }
    }catch(e){
      console.warn('KOB_TTS_ARCH_GATILHO_PATCH_V1 error', e);
    }
    return prevSpeak(u); // deixa LANG_SPEC, THEME etc trabalharem depois
  };

  console.log('⚡ KOB_TTS_ARCH_GATILHO_PATCH_V1 ativo — tags & gatilhos de arquétipo liberados');
})();
</script><script id="KOB_ARQ_BOOT">
  // 📣 Mapa de VOZ por arquétipo
  // Esses valores entram em cima do VOICE_MAP padrão via Object.assign
  window.ARQ_VOICE_MAP = {
    // deixa Atlas/Nova no eixo padrão
    Atlas:   'pt_m',  // PT macho
    Nova:    'pt_f',  // PT feminina (Luciana / Joana / etc)

    // QUATRO QUE VOCÊ FALOU:
    Ion:     'es_m',  // espanhol macho
    Solus:   'es_m',  // espanhol macho
    Artemis: 'es_f',  // espanhol feminino
    Pulse:   'es_m',  // espanhol macho, ritmo

    // Se quiser forçar outros:
    // Lumine: 'pt_f',
    // Kaos:   'pt_m',
    // etc...
  };

  // 🧠 Tabelas de gatilhos de frase por arquétipo
  // Lembrando: isso soma com DEFAULT_TRIGGERS dentro do patch
  window.ARQ_TRIGGERS = {
    Atlas: [
      /\bUPA-ATLAS\b/i,
      /\bPORTAL\s*\[\s*ATLAS\s*\]/i,
      'BASE ATLAS',
      'ATLAS NA BASE'
    ],
    Nova: [
      /\bMENTE NOVA\b/i,
      /\bTRINDADE\s+NOVA\b/i,
      'NOVA ARQUETÍPICA',
      'NOVA EM CENA'
    ],

    Aion: [
      'MODO ION',
      'ION EM CARGA',
      'IONIZAR O CAMPO',
      'ION FLUXO',
      'AI·ON LIGADO' // A I ON 🔥
    ],
    Solus: [
      'EIXO SOLUS',
      'SOLUS CENTRAL',
      'SOLUS NO COMANDO',
      'SOLUS EM ÓRBITA',
      'DECISÃO SOLUS'
    ],
    Artemis: [
      'ALVO ARTEMIS',
      'MIRA ARTEMIS',
      'ARTEMIS EM CAÇA',
      'FOCO ARTEMIS',
      'RITUAL ARTEMIS'
    ],
    Pulse: [
      'PULSO ATIVO',
      'PULSE 3·6·9',
      'RITMO DO PULSE',
      'BPM DO PULSE',
      'PULSE NO BPM'
    ]
  };
</script><script>
/* KOBLLUX · PATCH DE VOZ POR NOME
   - Usa o NOME da voz (v.name) para cada arquétipo
   - Mantém fallback pro applyArchetypeVoice original se não achar nada
   - Ajusta o nome Aion (nada de Ion kkk)
*/
(function () {
  if (typeof window === "undefined" || !("speechSynthesis" in window)) {
    return;
  }

  const synth = window.speechSynthesis;

  // 🔊 EDITÁVEL: coloque aqui os nomes das vozes que você TEM no aparelho
  // Dica: use o painel de vozes que você já tem ou os nomes padrão tipo "Luciana", "Mônica", "Conchita", etc.
  const VOICE_NAME_PREFS = {
    Atlas:  ["Luciana", "pt-BR"],
    Nova:   ["Luciana", "pt-BR"],
    Vitalis:["Luciana", "pt-BR"],

    // Esses você queria em espanhol:
    Pulse:  ["Mónica", "Monica", "Conchita", "es"],
    Artemis:["Mónica", "Monica", "Conchita", "es"],
    Solus:  ["Mónica", "Monica", "Conchita", "es"],
    Aion:   ["Mónica", "Monica", "Conchita", "es"],

    Serena: ["Luciana", "pt-BR"],
    Kaos:   ["Luciana", "pt-BR"],
    Genus:  ["Luciana", "pt-BR"],
    Lumine: ["Luciana", "pt-BR"],
    Rhea:   ["Luciana", "pt-BR"],
    Horus:  ["Luciana", "pt-BR"]
  };

  // 🧠 Normaliza o nome (sem acento / caixa)
  function norm(str) {
    return String(str || "")
      .toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "");
  }

  // Procura voz por nome / pedaço do nome / lang
  function pickVoiceByNamePrefs(archetype, voices) {
    const prefs = VOICE_NAME_PREFS[archetype];
    if (!prefs || !prefs.length) return null;

    const vlist = voices || synth.getVoices();
    if (!vlist || !vlist.length) return null;

    const normPrefs = prefs.map(norm);

    // 1) match exato de nome
    for (const p of normPrefs) {
      const exact = vlist.find(v => norm(v.name) === p);
      if (exact) return exact;
    }

    // 2) nome contém o pedaço (ex: "Monica" dentro de "Mônica - es-MX")
    for (const p of normPrefs) {
      const byPart = vlist.find(v => norm(v.name).includes(p));
      if (byPart) return byPart;
    }

    // 3) se algum pref parece código de idioma (ex: "es", "pt-br"), tenta lang
    for (const p of normPrefs) {
      if (p === "es" || p === "es-es" || p === "es-mx" || p === "pt-br" || p === "pt") {
        const byLang = vlist.find(v => norm(v.lang).startsWith(p));
        if (byLang) return byLang;
      }
    }

    return null;
  }

  // Guarda referência do applyArchetypeVoice original, se existir
  const originalApply = window.applyArchetypeVoice || null;

  window.applyArchetypeVoice = function patchedApplyArchetypeVoice(utterance, archetypeName) {
    try {
      const voices = synth.getVoices();
      let arch = archetypeName;

      // Normaliza o nome do arquétipo (Atlas, Nova, Pulse, Solus, Aion...)
      if (arch && typeof arch === "string") {
        arch = arch.trim();
        // Se vier em minúsculo, ajeita a primeira letra
        const low = arch.toLowerCase();
        const mapFix = {
          atlas: "Atlas",
          nova: "Nova",
          vitalis: "Vitalis",
          pulse: "Pulse",
          artemis: "Artemis",
          serena: "Serena",
          kaos: "Kaos",
          genus: "Genus",
          lumine: "Lumine",
          rhea: "Rhea",
          solus: "Solus",
          aion: "Aion",
          horus: "Horus"
        };
        arch = mapFix[low] || arch;
      }

      let chosen = null;

      if (arch && voices && voices.length) {
        chosen = pickVoiceByNamePrefs(arch, voices);
      }

      if (chosen) {
        utterance.voice = chosen;
        // marca no body quem tá falando (pra tema / debug visual)
        try {
          document.body.dataset.voiceArch = norm(arch);
        } catch(e){/* ignora se der erro */ }
        return;
      }

      // Se não achou nada pelas prefs, cai no comportamento antigo (se existir)
      if (typeof originalApply === "function") {
        originalApply(utterance, archetypeName);
      }

    } catch (err) {
      // Falhou o patch? volta pro original pra não quebrar nada
      if (typeof originalApply === "function") {
        try { originalApply(utterance, archetypeName); } catch(e){}
      }
    }
  };

})();
</script><script>
/* =========================================================
   DUAL.INFODOSE v7.9 — KOBLLUX VISIO & MEMORIA
   - Fix: Cristalização (Deck) funcional e visível
   - New: Visualizador HTML (Preview/Code/Fullscreen/Mobile)
   - Core: Fractal 3-6-9-7 + Ciclos Solares
========================================================= */

const STORAGE = {
    API_KEY: 'di_apiKey',
    MODEL: 'di_modelName',
    SYSTEM_ROLE: 'di_systemRole',
    USER_ID: 'di_userName',
    BG_IMAGE: 'di_bgImage',
    CUSTOM_CSS: 'di_customCss',
    SOLAR_MODE: 'di_solarMode',
    SOLAR_AUTO: 'di_solarAuto',
    INFODOSE_NAME: 'di_infodoseName',
    ASSISTANT_ENABLED: 'di_assistantEnabled',
    TRAINING_ACTIVE: 'di_trainingActive',
    TRAINING_TEXT: 'di_trainingText',
    MESSAGES: 'di_messages'
};

// KODUX ARQUÉTIPOS E FASES
const KODUX = {
    ARQUETIPOS: { "Atlas":{Essencia:"Planejador"}, "Nova":{Essencia:"Inspira"}, "Vitalis":{Essencia:"Momentum"}, "Pulse":{Essencia:"Emocional"}, "Artemis":{Essencia:"Descoberta"}, "Serena":{Essencia:"Cuidado"}, "Kaos":{Essencia:"Transformador"}, "Genus":{Essencia:"Fabricus"}, "Lumine":{Essencia:"Alegria"}, "Solus":{Essencia:"Sabedoria"}, "Rhea":{Essencia:"Vínculo"}, "Aion":{Essencia:"Tempo"} },
    PROJETO: { "I. INTRODUÇÃO":{fase:"KODUX (Δ³)",arquetipos:["Atlas","Nova","Pulse"]}, "II. ATO I":{fase:"BLLUE (Δ⁶)",arquetipos:["Vitalis","Pulse","Genus"]}, "III. ATO II":{fase:"EXPANSÃO (Δ⁹)",arquetipos:["Genus","Nova","Vitalis"]}, "IV. ATO III":{fase:"CONVERGÊNCIA (Δ⁹)",arquetipos:["Genus","Aion","Pulse"]}, "V. EPÍLOGO":{fase:"VERBO ETERNO (Δ⁷)",arquetipos:["Atlas","Aion","Genus"]} }
};


/* ═══════════════════════════════════════════════════════════════
   INTEGRAÇÃO DE CONSTANTES di_* DO LOCALSTORAGE
   ═══════════════════════════════════════════════════════════════ */

function initDIConstants() {
    const di_userName = localStorage.getItem('di_userName') || 'Viajante';
    const di_infodoseName = localStorage.getItem('di_infodoseName') || 'KOBLLUX';
    const di_apiKey = localStorage.getItem('di_apiKey') || '';
    const di_modelName = localStorage.getItem('di_modelName') || 'nvidia/nemotron-3-nano-30b-a3b:free';
    const di_systemRole = localStorage.getItem('di_systemRole') || 'oi Dual';
    const di_solarMode = localStorage.getItem('di_solarMode') || 'night';
    const di_assistantEnabled = localStorage.getItem('di_assistantEnabled') === '1';
    const di_trainingActive = localStorage.getItem('di_trainingActive') === '1';
    const di_trainingText = localStorage.getItem('di_trainingText') || '';
    
    // Atualizar elementos da UI
    const usernameDisplay = document.getElementById('usernameDisplay');
    if (usernameDisplay) {
        usernameDisplay.textContent = di_userName;
    }
    
    const modeIndicator = document.getElementById('modeIndicator');
    if (modeIndicator) {
        modeIndicator.textContent = `${di_infodoseName} · ${di_solarMode.toUpperCase()}`;
    }
    
    // Preencher inputs com valores salvos
    const apiKeyInput = document.getElementById('apiKeyInput');
    if (apiKeyInput) apiKeyInput.value = di_apiKey;
    
    const systemRoleInput = document.getElementById('systemRoleInput');
    if (systemRoleInput) systemRoleInput.value = di_systemRole;
    
    const inputUserId = document.getElementById('inputUserId');
    if (inputUserId) inputUserId.value = di_userName;
    
    const inputModel = document.getElementById('inputModel');
    if (inputModel) inputModel.value = di_modelName;
    
    // Salvar no localStorage se não existir
    if (!localStorage.getItem('di_userName')) localStorage.setItem('di_userName', di_userName);
    if (!localStorage.getItem('di_infodoseName')) localStorage.setItem('di_infodoseName', di_infodoseName);
    if (!localStorage.getItem('di_solarMode')) localStorage.setItem('di_solarMode', di_solarMode);
    
    console.log('[DI_CONSTANTS] Inicializado:', { di_userName, di_infodoseName, di_apiKey: di_apiKey ? '✓' : '✗' });
}

// Chamar ao carregar a página
document.addEventListener('DOMContentLoaded', initDIConstants);

const FOOTER_TEXTS = { closed:{ritual:["tocar o campo é consentir","registro aguarda presença"],tecnico:["latência detectada","aguardando input"]}, open:{sustentado:["campo ativo","consciência expandida"],estavel:["sinal estabilizado","link neural firme"]}, loading:["sincronizando neuro-link...","buscando no éter...","decodificando sinal..."] };

let lastText = null;
function getRandomText(arr){ if(!arr||arr.length===0)return"Processando..."; let t; do{t=arr[Math.floor(Math.random()*arr.length)];}while(t===lastText&&arr.length>1); lastText=t; return t; }

/* ---------------------------------------------------------
   KOBLLUX CORE (3-6-9-7)
   --------------------------------------------------------- */
const KoblluxCore = {
    async sha256Hex(s) { const d = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(s)); return [...new Uint8Array(d)].map(b=>b.toString(16).padStart(2,'0')).join(''); },
    classifyText(s) { const t = (s.match(/[\p{L}\p{N}_-]+/gu)||[]); const endsV = ['ar','er','ir']; const verbs=[],nouns=[],adjs=[]; for (const w0 of t){ const w = w0.toLowerCase(); if(w.endsWith('mente')){adjs.push(w0);continue;} if(endsV.some(e=>w.endsWith(e))){verbs.push(w0);continue;} if(w.endsWith('ção')||w.endsWith('são')||w.endsWith('dade')){nouns.push(w0);continue;} if(/^[A-Z]/.test(w0)){nouns.push(w0);continue;} } return {tokens:t, verbs, nouns, adjs}; },
    mapTrinity(pos) { return { UNO: pos.nouns[0]||'NÚCLEO', DUAL: pos.verbs[0]||'relaciona', TRINITY: pos.adjs[0]||'integrado' }; },
    async process(input) { if(!input)return null; const pos=this.classifyText(input); const tri=this.mapTrinity(pos); const seal=await this.sha256Hex(input+new Date().toISOString()); return { raw:input, pos:pos, trinity:tri, seal:seal.slice(0,16), log:`[KOBLLUX ∆7] UNO:${tri.UNO}|DUAL:${tri.DUAL}|TRI:${tri.TRINITY}::SEAL:${seal.slice(0,8)}` }; }
};

/* ---------------------------------------------------------
   UTILS: DOWNLOAD, PREVIEW, ZIP
   --------------------------------------------------------- */
const DownloadUtils = {
    _getBlock(btn) { return btn.closest('.msg-block'); },
    _getCleanHtml(block) { const clone = block.cloneNode(true); const tools = clone.querySelector('.msg-tools'); if(tools) tools.remove(); return clone.innerHTML; },
    _guessFilename(base, extFallback='txt') { const t = new Date().toISOString().replace(/[:.]/g,'-'); if (!base) return `ai-output-${t}.${extFallback}`; if (/<\s*!doctype|<html|<body|<head/i.test(base)) return `ai-output-${t}.html`; if (/<pre|<code/i.test(base)) return `ai-code-${t}.${extFallback}`; return `ai-output-${t}.${extFallback}`; },
    downloadMessage(btn) { try { const block = this._getBlock(btn); if(!block) return; const content = this._getCleanHtml(block); const isHTML = /<\s*!doctype|<html|<body|<head|<\/div>/i.test(content); const mime = isHTML ? 'text/html' : 'text/plain'; const ext = isHTML ? 'html' : 'txt'; const filename = this._guessFilename(content, ext); const blob = new Blob([content], { type: mime + ';charset=utf-8' }); this.triggerDownload(blob, filename); App.showToast(`Download: ${filename}`); } catch(e){ App.showToast('Erro download', true); } },
    downloadMarkdown(btn) { try { const block = this._getBlock(btn); if(!block) return; const raw = block.dataset.raw || block.innerText || ''; const filename = this._guessFilename(raw, 'md').replace(/\.(html|txt)$/, '.md'); const blob = new Blob([raw], { type: 'text/markdown;charset=utf-8' }); this.triggerDownload(blob, filename); App.showToast(`MD salvo: ${filename}`); } catch(e){ App.showToast('Erro MD', true); } },
    openSandbox(btn) { try { const block = this._getBlock(btn); if(!block) return; const content = this._getCleanHtml(block); let page = content; if(!/<\s*!doctype|<html/i.test(content)) page = `<!doctype html><html lang="pt-BR"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Sandbox</title></head><body>${content}</body></html>`; const blob = new Blob([page], { type: 'text/html' }); const url = URL.createObjectURL(blob); window.open(url, '_blank'); App.showToast('Sandbox aberto'); } catch(e){ App.showToast('Erro sandbox', true); } },
    async exportPdf(btn) { try { if(typeof html2pdf === 'undefined') { App.showToast('PDF lib ausente. Use Sandbox.', true); return this.openSandbox(btn); } const block = this._getBlock(btn); if(!block) return; const content = this._getCleanHtml(block); const container = document.createElement('div'); container.style.position = 'fixed'; container.style.left = '-9999px'; container.style.width = '1100px'; container.style.padding = '20px'; container.style.background = '#ffffff'; container.innerHTML = content; document.body.appendChild(container); const filename = this._guessFilename(content, 'pdf').replace(/\.(html|txt)$/, '.pdf'); await html2pdf().from(container).set({ margin: 12, filename: filename, html2canvas: { scale: 2 }, jsPDF: { unit: 'pt', format: 'a4' } }).save(); document.body.removeChild(container); App.showToast(`PDF: ${filename}`); } catch(e){ App.showToast('Erro PDF', true); } },
    triggerDownload(blob, filename) { const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); setTimeout(() => URL.revokeObjectURL(url), 2000); }
};

const Preview = {
    async renderPreview(file) {
        const type = file.type || 'text/plain'; const name = file.name || 'arquivo'; const url = URL.createObjectURL(file);
        if (type === 'text/html' || name.endsWith('.html')) { const text = await file.text(); const blob = new Blob([this.sanitizeHTML(text)], { type: 'text/html' }); return `<div class="preview-html"><iframe src="${URL.createObjectURL(blob)}" sandbox="allow-scripts"></iframe></div>`; }
        if (type.startsWith('image/')) return `<div class="preview-html"><img src="${url}" style="width:100%;height:100%;object-fit:contain;background:#000;"></div>`;
        const text = await file.text(); const ext = name.split('.').pop() || 'txt'; const code = this.escapeHTML(text.slice(0, 2000)); setTimeout(() => { hljs.highlightAll(); }, 0); return `<div class="preview-code"><pre><code class="language-${ext}">${code}</code></pre></div>`;
    },
    sanitizeHTML(html) { const div = document.createElement('div'); div.innerHTML = html; div.querySelectorAll('script').forEach(s => s.remove()); return div.innerHTML; },
    escapeHTML(str) { return str.replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s])); },
    
    // VISUALIZADOR HTML (Atualizado)
    createHtmlViewer(htmlCode) {
        const id = 'html-' + Date.now();
        const blob = new Blob([htmlCode], {type: 'text/html'});
        const url = URL.createObjectURL(blob);
        const codeEscaped = this.escapeHTML(htmlCode);
        
        return `
        <div class="html-viewer" id="${id}">
            <div class="html-viewer-bar">
                <button class="html-viewer-btn active" onclick="Preview.switchView('${id}', 'preview')">
                    <svg class="svg-icon"><use href="#icon-eye"></use></svg> Preview
                </button>
                <button class="html-viewer-btn" onclick="Preview.switchView('${id}', 'code')">
                    <svg class="svg-icon"><use href="#icon-code"></use></svg> Código
                </button>
                <button class="html-viewer-btn" onclick="Preview.openFullscreen('${id}', '${url.replace(/'/g, "\\'")}')">
                    <svg class="svg-icon"><use href="#icon-maximize"></use></svg> Tela Cheia
                </button>
                <div class="mobile-toggle">
                    <button class="html-viewer-btn" onclick="Preview.toggleMobile('${id}')">
                        <svg class="svg-icon"><use href="#icon-eye"></use></svg> Mobile
                    </button>
                </div>
            </div>
            <div class="html-viewer-content">
                <iframe src="${url}" sandbox="allow-scripts allow-popups"></iframe>
                <div class="html-viewer-code"><pre><code class="language-html">${codeEscaped}</code></pre></div>
            </div>
        </div>`;
    },

    switchView(id, mode) {
        const container = document.getElementById(id);
        if(!container) return;
        
        if(mode === 'code') {
            container.classList.add('show-code');
        } else {
            container.classList.remove('show-code');
        }
        
        // Atualiza botões ativos
        container.querySelectorAll('.html-viewer-btn').forEach(b => b.classList.remove('active'));
        event.currentTarget.classList.add('active');
    },

    openFullscreen(id, url) {
        const container = document.getElementById(id);
        if(!container) return;
        
        // Modo tela cheia
        container.classList.add('fullscreen');
        container.querySelector('iframe').src = url;
        
        // Botão para sair
        const bar = container.querySelector('.html-viewer-bar');
        const exitBtn = document.createElement('button');
        exitBtn.className = 'html-viewer-btn';
        exitBtn.innerHTML = '<svg class="svg-icon"><use href="#icon-restore"></use></svg> Sair';
        exitBtn.onclick = () => {
            container.classList.remove('fullscreen');
            exitBtn.remove();
        };
        bar.appendChild(exitBtn);
    },

    toggleMobile(id) {
        const container = document.getElementById(id);
        if(!container) return;
        
        container.classList.toggle('mobile');
        
        // Atualiza botão mobile
        const btn = event.currentTarget;
        if(container.classList.contains('mobile')) {
            btn.innerHTML = '<svg class="svg-icon"><use href="#icon-eye"></use></svg> Desktop';
        } else {
            btn.innerHTML = '<svg class="svg-icon"><use href="#icon-eye"></use></svg> Mobile';
        }
    }
};

const ZipGenerator = {
    async generateZip() {
        try {
            const { default: JSZip } = await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');
            const zip = new JSZip();
            const root = zip.folder("KOBLLUX_INTEGRADO");
            root.folder("00_CORE").file("config.json", JSON.stringify(KODUX, null, 2));
            root.folder("00_CORE").file("timestamp.txt", new Date().toISOString());
            root.folder("01_CYCLES_3x3"); root.folder("02_PARTS"); root.folder("03_REDE"); root.folder("04_EXPORT");
            
            const content = await zip.generateAsync({ type: "blob" });
            const md5 = await this.hash(content, 'MD5');
            const sha = await this.hash(content, 'SHA-256');
            const name = `KOBLLUX_${new Date().toISOString().slice(0,10)}.zip`;
            DownloadUtils.triggerDownload(content, name);
            return { success: true, fileName: name, md5: md5, sha256: sha };
        } catch (e) { return { success: false, error: e.message }; }
    },
    async hash(blob, algo) { const b = await blob.arrayBuffer(); const h = await crypto.subtle.digest(algo, b); return Array.from(new Uint8Array(h)).map(x => x.toString(16).padStart(2,'0')).join(''); }
};

const Utils = {
    copy(btn) { const b = btn.closest('.msg-block'); if(!b)return; navigator.clipboard.writeText(b.innerText.replace("content_copy","").trim()); App.showToast("Copiado"); },
    speak(btn) { const b = btn.closest('.msg-block'); if(!b)return; App.speakText(b.innerText.replace(/<[^>]*>?/gm, '').trim()); },
    edit(btn) { const b = btn.closest('.msg-block'); const t = b.innerText.replace("content_copy","").trim(); document.getElementById('userInput').value = t; b.remove(); App.speakText("Editando"); }
};

/* ---------------------------------------------------------
   MAIN APP CONTROLLER
   --------------------------------------------------------- */
const App = {
    state: { open: false, messages: [], isAutoSolar: true, solarMode: 'night', isProcessing: false, isListening: false, recognition: null },
    
    init() {
        const s = localStorage;
        document.getElementById('apiKeyInput').value = s.getItem(STORAGE.API_KEY) || '';
        
        const baseRole = s.getItem(STORAGE.SYSTEM_ROLE) || 'Você é Dual.';
        if(!baseRole.includes("KODUX")) document.getElementById('systemRoleInput').value = baseRole + `\n[SISTEMA KODUX V7.9]\nArquétipos: ${Object.keys(KODUX.ARQUETIPOS).join(', ')}. Use V.E.E.B.`;
        else document.getElementById('systemRoleInput').value = baseRole;

        document.getElementById('inputUserId').value = s.getItem(STORAGE.USER_ID) || 'Viajante';
        document.getElementById('inputModel').value = s.getItem(STORAGE.MODEL) || 'openai/gpt-oss-20b:free';
        this.state.isAutoSolar = s.getItem(STORAGE.SOLAR_AUTO) !== 'false';
        
        // CORREÇÃO: Força o modo correto na inicialização
        if (this.state.isAutoSolar) this.autoByTime(); else this.setMode(s.getItem(STORAGE.SOLAR_MODE) || 'night');

        this.indexedDB.loadCustomCSS();
        this.indexedDB.loadBackground();
        this.setupVoiceSystem();
        this.bindEvents();
        this.updateUI();
        this.toggleField(false, true); 
        this.renderDeck();
        
        setTimeout(() => this.announce("KOBLLUX V7.9 Visio. Memória Ativa."), 1200);
        if(typeof particlesJS !== 'undefined') particlesJS('particles-js', {particles:{number:{value:30},color:{value:"#ffffff"},opacity:{value:0.5},size:{value:2},line_linked:{enable:true,distance:150,color:"#ffffff",opacity:0.2,width:1}}});
    },

    // --- VOZ ---
    setupVoiceSystem() {
        if (!('webkitSpeechRecognition' in window)) return;
        this.state.recognition = new webkitSpeechRecognition();
        this.state.recognition.lang = 'pt-BR';
        this.state.recognition.continuous = true; 
        this.state.recognition.interimResults = true;
        this.state.recognition.onstart = () => { this.state.isListening = true; document.getElementById('btnVoice').classList.add('listening'); this.showToast("🎙️ Voz Ativa..."); };
        this.state.recognition.onend = () => { if (this.state.isListening) try { this.state.recognition.start(); } catch(e){} else document.getElementById('btnVoice').classList.remove('listening'); };
        this.state.recognition.onresult = (e) => { let t=''; for(let i=e.resultIndex;i<e.results.length;++i) t+=e.results[i][0].transcript; document.getElementById('userInput').value=t; };
        this.state.recognition.onerror = (e) => { if(e.error!=='no-speech') { this.state.isListening=false; document.getElementById('btnVoice').classList.remove('listening'); } };
    },
    toggleVoice() {
        if (!this.state.recognition) return;
        if (this.state.isListening) { this.state.isListening = false; this.state.recognition.stop(); }
        else { window.speechSynthesis.cancel(); document.getElementById('userInput').value = ''; try { this.state.recognition.start(); } catch(e){} }
    },

    // --- UPLOAD ---
    setupFileUpload() {
        const input = document.getElementById('fileUploadInput');
        document.getElementById('btnUploadFile').onclick = () => input.click();
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const preview = document.getElementById('filePreview');
            preview.querySelector('.file-info span').textContent = file.name;
            preview.classList.add('active');
            preview.querySelector('.file-actions').innerHTML = `<button class="btn-preview" onclick="App.cancelUpload()">✕</button><button class="btn-preview primary" onclick="App.confirmUpload('${file.name}')">Assimilar</button>`;
        };
    },
    cancelUpload() { document.getElementById('filePreview').classList.remove('active'); document.getElementById('fileUploadInput').value = ''; },
    async confirmUpload(fileName) {
        const file = document.getElementById('fileUploadInput').files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = async (e) => {
            const content = e.target.result;
            const previewHTML = await Preview.renderPreview(file);
            const size = (file.size/1024/1024).toFixed(2);
            this.addFileMessage(file, previewHTML, size);
            const fractal = await KoblluxCore.process(content);
            this.addMessage('system', `Memória Fractal: ${fileName}\n${fractal.log}`);
            this.state.messages.push({ role: 'user', content: `[ARQUIVO: ${fileName}]\n[TRINITY: ${JSON.stringify(fractal.trinity)}]\n${content}\n[SELO: ${fractal.seal}]` });
            this.cancelUpload();
        };
        reader.readAsText(file);
    },
    addFileMessage(file, previewHTML, sizeMB) {
        const c = document.getElementById('chat-container');
        const d = document.createElement('div');
        d.className = 'msg-block file-msg ai';
        d.innerHTML = `<div class="file-header"><strong>${file.name}</strong><span class="file-meta">${sizeMB} MB • ${file.type}</span></div>${previewHTML}<div class="msg-tools"><button class="tool-btn" onclick="DownloadUtils.triggerDownload(new Blob(['${file.name}']), '${file.name}')">📥 Baixar</button></div>`;
        c.appendChild(d); c.scrollTop = c.scrollHeight;
    },

    // --- CHAT ---
    async handleSend() {
        const input = document.getElementById('userInput');
        const txt = input.value.trim();
        if (!txt || this.state.isProcessing) return;

        if(txt.toLowerCase() === '/atlas') {
            input.value = ''; this.addMessage('user', txt);
            let rep = "### ♾️ ATLAS KODUX\n";
            for(const [k,v] of Object.entries(KODUX.ARQUETIPOS)) rep+=`- **${k}**: ${v.Essencia}\n`;
            this.addMessage('ai', rep); return;
        }
        if(txt.toLowerCase() === '/zip') {
            input.value = ''; this.addMessage('user', txt);
            this.addMessage('system', "Gerando KOBLLUX...");
            const res = await ZipGenerator.generateZip();
            this.addMessage('system', res.success ? `✅ Pacote: ${res.fileName}\nSHA: ${res.sha256}` : `❌ Erro: ${res.error}`);
            return;
        }

        const fractal = await KoblluxCore.process(txt);
        input.value = '';
        this.addMessage('user', txt);
        this.state.isProcessing = true;
        document.getElementById('field-toggle-handle').innerHTML = `<span class="footer-dot pulse"></span> ${getRandomText(FOOTER_TEXTS.loading)}`;
        
        const key = localStorage.getItem(STORAGE.API_KEY);
        if (!key && !document.getElementById('inputModel').value.includes(':free')) { this.announce("Erro: API Key."); this.state.isProcessing = false; return; }

        try {
            document.body.classList.add('loading');
            const res = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${key}`, 'Content-Type': 'application/json', 'HTTP-Referer': location.origin },
                body: JSON.stringify({
                    model: document.getElementById('inputModel').value,
                    messages: [ 
                        { role: 'system', content: document.getElementById('systemRoleInput').value },
                        ...this.state.messages.slice(-10).map(m => ({ role: m.role, content: m.content })),
                        { role: 'user', content: `${txt}\n\n[KOBLLUX]\nUNO:${fractal.trinity.UNO}\nSELO:${fractal.seal}` } 
                    ]
                })
            });
            const data = await res.json();
            const aiContent = data.choices?.[0]?.message?.content || "Sem sinal.";
            
            // DETECTAR SE É HTML PURO PARA O VISUALIZADOR
            if (/^\s*(<!doctype html|<html)/i.test(aiContent)) {
               this.addHTMLViewer(aiContent);
               // Adiciona ao histórico sem renderizar de novo
               this.state.messages.push({ role: 'assistant', content: aiContent });
            } else {
               this.addMessage('ai', aiContent);
            }
            
        } catch (e) { this.announce("Erro conexão."); } 
        finally { document.body.classList.remove('loading'); this.state.isProcessing = false; this.toggleField(this.state.open, true); }
    },

    addMessage(role, text) {
        const c = document.getElementById('chat-container');
        const d = document.createElement('div'); d.className = `msg-block ${role}`; d.dataset.raw = text||'';
        
        let html = role==='ai' ? marked.parse(text) : text.replace(/\n/g, '<br>');
        
        if(role !== 'system') {
            html += `<div class="msg-tools">
                <button class="tool-btn" onclick="Utils.copy(this)" title="Copiar"><svg><use href="#icon-copy"></use></svg></button>
                <button class="tool-btn" onclick="Utils.speak(this)" title="Ouvir"><svg><use href="#icon-mic"></use></svg></button>
                ${role === 'ai' ? `
                  <button class="tool-btn" onclick="DownloadUtils.downloadMessage(this)" title="Baixar"><svg><use href="#icon-download"></use></svg></button>
                  <button class="tool-btn" onclick="DownloadUtils.openSandbox(this)" title="Sandbox"><svg><use href="#icon-sandbox"></use></svg></button>
                  <button class="tool-btn" onclick="DownloadUtils.exportPdf(this)" title="PDF"><svg><use href="#icon-pdf"></use></svg></button>` : 
                  `<button class="tool-btn" onclick="Utils.edit(this)" title="Editar"><svg><use href="#icon-edit"></use></svg></button>`}
            </div>`;
            this.state.messages.push({ role: role==='ai'?'assistant':'user', content: text });
        }
        d.innerHTML = html;
        if (role === 'ai') d.querySelectorAll('pre').forEach(pre => { 
            const btn = document.createElement('button'); btn.className = 'copy-code-btn'; btn.textContent = 'Copiar'; 
            btn.onclick = () => { navigator.clipboard.writeText(pre.querySelector('code').innerText); btn.textContent='Copiado!'; setTimeout(()=>btn.textContent='Copiar',2000); };
            pre.appendChild(btn); 
        });
        c.appendChild(d); c.scrollTop = c.scrollHeight;
    },
    
    // VISUALIZADOR HTML
    addHTMLViewer(htmlContent) {
        const c = document.getElementById('chat-container');
        const d = document.createElement('div'); d.className = `msg-block ai`;
        const viewerHTML = Preview.createHtmlViewer(htmlContent);
        d.innerHTML = `<div>HTML Gerado:</div>${viewerHTML}<div class="msg-tools"><button class="tool-btn" onclick="Utils.copy(this)"><svg><use href="#icon-copy"></use></svg></button></div>`;
        c.appendChild(d); c.scrollTop = c.scrollHeight;
    },

    /* --- GERAL --- */
    speakText(text) { if (!text || this.state.isListening) return; window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(text); u.lang='pt-BR'; u.rate=1.1; window.speechSynthesis.speak(u); },
    announce(msg) { this.showToast(msg); },
    showToast(msg, err=false) { const t = document.getElementById('nv-toast'); t.textContent=msg; t.style.borderLeft=err?'4px solid #f44':'4px solid var(--primary)'; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),3000); this.speakText(msg); },
    
    // CORREÇÃO VISUAL: CICLOS SOLARES
    setMode(m) { 
        this.state.solarMode=m; 
        document.body.classList.remove('mode-day', 'mode-sunset', 'mode-night');
        document.body.classList.add(`mode-${m}`); 
        this.updateUI(); 
        localStorage.setItem(STORAGE.SOLAR_MODE, m); 
    },
    cycleSolar() { const n = this.state.solarMode==='day'?'sunset':(this.state.solarMode==='sunset'?'night':'day'); this.state.isAutoSolar=false; this.setMode(n); },
    enableAutoSolar() { this.state.isAutoSolar=true; this.autoByTime(); this.announce("Auto Solar"); },
    autoByTime() { const h=new Date().getHours(); this.setMode((h>=6&&h<17)?'day':(h>=17&&h<19)?'sunset':'night'); },
    updateUI() { 
        document.getElementById('statusSolarMode').textContent = `${this.state.solarMode.toUpperCase()} ${this.state.isAutoSolar ? '(AUTO)' : '(MAN)'}`; 
        document.getElementById('usernameDisplay').textContent = document.getElementById('inputUserId').value; 
    },
    toggleField(f,s) { this.state.open = f!==undefined?f:!this.state.open; document.getElementById('chat-container').classList.toggle('collapsed', !this.state.open); document.body.classList.toggle('field-closed', !this.state.open); if(!s) this.speakText(getRandomText(FOOTER_TEXTS[this.state.open?'open':'closed']['ritual'])); },
    
    // CORREÇÃO CRISTALIZAÇÃO (DECK)
    async crystallizeSession() {
        if(this.state.messages.length === 0) { this.announce("Vazio não cristaliza."); return; }
        const title = this.state.messages.find(m => m.role === 'user')?.content.substring(0, 30) || "Memória Sem Nome";
        await this.indexedDB.saveDeckItem({ id: Date.now(), date: new Date().toLocaleString(), title: title + "...", data: [...this.state.messages] });
        await this.renderDeck(); // Força render
        this.announce("Memória Salva.");
        if(!document.getElementById('drawerDeck').classList.contains('open')) toggleDrawer('drawerDeck');
    },
    
    async renderDeck() {
        const items = await this.indexedDB.getDeck();
        const container = document.getElementById('deckList');
        if(!items || items.length === 0) {
            container.innerHTML = '<div style="text-align:center;color:var(--text-muted);margin-top:20px">O vazio reina aqui.<br>Use o botão 💎 para salvar.</div>';
            return;
        }
        container.innerHTML = items.sort((a,b) => b.id - a.id).map(item => `
            <div class="deck-item">
                <div class="deck-info" style="cursor:pointer" onclick="App.restoreMemory(${item.id})">
                    <h4>${item.title}</h4>
                    <span>${item.date} • ${item.data.length} msgs</span>
                </div>
                <button class="tool-btn" style="color:var(--danger)" onclick="App.deleteMemory(${item.id})"><svg><use href="#icon-trash"></use></svg></button>
            </div>
        `).join('');
    },
    
    async restoreMemory(id) {
        const items = await this.indexedDB.getDeck();
        const item = items.find(i => i.id === id);
        if(item) {
            document.getElementById('chat-container').innerHTML = ''; // Limpa tela
            this.state.messages = []; // Limpa estado
            item.data.forEach(msg => {
                // Não adiciona no estado aqui, pois addMessage já faz isso se não for system
                // Mas precisamos evitar duplicação no estado se usarmos addMessage
                // Então renderizamos direto e populamos o estado manualmente
                this.addMessage(msg.role === 'assistant' ? 'ai' : 'user', msg.content);
            });
            // Ajuste fino para não duplicar estado (o addMessage já popula)
            // Apenas removemos as últimas duplicatas geradas pelo loop acima se necessário
            // (Mas como limpamos this.state.messages antes, está OK).
            
            toggleDrawer('drawerDeck');
            this.announce("Memória restaurada.");
        }
    },
    
    async deleteMemory(id) {
        if(confirm("Fragmentar cristal?")) {
            await this.indexedDB.deleteDeckItem(id);
            this.renderDeck();
        }
    },

    bindEvents() {
        document.getElementById('btnSend').onclick=()=>this.handleSend();
        document.getElementById('userInput').onkeypress=(e)=>{if(e.key==='Enter')this.handleSend()};
        document.getElementById('field-toggle-handle').onclick=()=>this.toggleField();
        document.getElementById('orbToggle').onclick=()=>{toggleDrawer('drawerProfile');this.speakText("Cockpit");};
        
        // EVENTOS CORRIGIDOS
        document.getElementById('btnCrystallize').onclick = () => this.crystallizeSession();
        document.getElementById('btnCycleSolar').onclick = () => this.cycleSolar();
        document.getElementById('btnAutoSolar').onclick = () => this.enableAutoSolar();
        
        document.getElementById('inputUserId').onchange=(e)=>{localStorage.setItem(STORAGE.USER_ID,e.target.value);this.updateUI();};
        document.getElementById('btnSaveConfig').onclick=()=>{localStorage.setItem(STORAGE.API_KEY,document.getElementById('apiKeyInput').value);localStorage.setItem(STORAGE.SYSTEM_ROLE,document.getElementById('systemRoleInput').value);this.indexedDB.saveCustomCSS(document.getElementById('customCssInput').value);toggleDrawer('drawerSettings');this.announce("Salvo");};
        document.getElementById('bgUploadInput').onchange=(e)=>this.indexedDB.handleBackgroundUpload(e.target.files[0]);
        document.getElementById('btnSettings').onclick=()=>toggleDrawer('drawerSettings');
        document.getElementById('btnDeck').onclick=()=>{ toggleDrawer('drawerDeck'); this.renderDeck(); }; // Garante render ao abrir
        document.getElementById('btnClearCss').onclick=()=>this.indexedDB.clearAsset(STORAGE.CUSTOM_CSS);
        document.getElementById('btnVoice').onclick=()=>this.toggleVoice();
        this.setupFileUpload();
    },

    indexedDB: {
        async getDB() { return new Promise((r,j)=>{const q=indexedDB.open("InfodoseDB",2);q.onupgradeneeded=e=>{const d=e.target.result;if(!d.objectStoreNames.contains('assets'))d.createObjectStore('assets',{keyPath:'id'});if(!d.objectStoreNames.contains('deck'))d.createObjectStore('deck',{keyPath:'id'});};q.onsuccess=e=>r(e.target.result);q.onerror=j;}); },
        async putAsset(i,d){(await this.getDB()).transaction(['assets'],'readwrite').objectStore('assets').put({id:i,...d});},
        async getAsset(i){return new Promise(async r=>(await this.getDB()).transaction(['assets']).objectStore('assets').get(i).onsuccess=e=>r(e.target.result));},
        async clearAsset(i){(await this.getDB()).transaction(['assets'],'readwrite').objectStore('assets').delete(i); if(i===STORAGE.CUSTOM_CSS)document.getElementById('custom-styles').textContent=''; if(i===STORAGE.BG_IMAGE)document.getElementById('bg-fake-custom').style.backgroundImage='';},
        async handleBackgroundUpload(f){if(!f)return;await this.putAsset(STORAGE.BG_IMAGE,{blob:f});this.loadBackground();},
        async loadBackground(){const d=await this.getAsset(STORAGE.BG_IMAGE);if(d?.blob)document.getElementById('bg-fake-custom').style.backgroundImage=`url('${URL.createObjectURL(d.blob)}')`;},
        async saveCustomCSS(c){await this.putAsset(STORAGE.CUSTOM_CSS,{css:c});this.loadCustomCSS();},
        async loadCustomCSS(){const d=await this.getAsset(STORAGE.CUSTOM_CSS);if(d?.css){document.getElementById('custom-styles').textContent=d.css;document.getElementById('customCssInput').value=d.css;}},
        async saveDeckItem(i){(await this.getDB()).transaction(['deck'],'readwrite').objectStore('deck').put(i);},
        async getDeck(){return new Promise(async r=>(await this.getDB()).transaction(['deck']).objectStore('deck').getAll().onsuccess=e=>r(e.target.result));},
        async deleteDeckItem(i){(await this.getDB()).transaction(['deck'],'readwrite').objectStore('deck').delete(i);}
    }
};

function toggleDrawer(id) { document.getElementById(id).classList.toggle('open'); }
window.onload = () => App.init();
</script><script id="TEXT_BEAUTY_V3_SCRIPT">
(()=>{'use strict';
if(window.__TEXT_BEAUTY_V3__) return; window.__TEXT_BEAUTY_V3__=true;

/* Utilitários */
const $=(s,r=document)=>r.querySelector(s);
const $$=(s,r=document)=>[...r.querySelectorAll(s)];
const esc=(s)=>s.replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));

/* 0) Toggle edição rápida */
let EDIT_ON=false;
const toggleEdit=()=>{
  EDIT_ON=!EDIT_ON;
  document.body.toggleAttribute('data-edit', EDIT_ON);
  const host = document.getElementById('CONTENT') || document.querySelector('main, article, .render, .reader, body');
  if(host) host.contentEditable = EDIT_ON ? 'plaintext-only' : 'false';
};
document.addEventListener('keydown',e=>{
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='e'){ e.preventDefault(); toggleEdit(); }
});

/* 1) Key:Value negrito (palavra:) + parênteses + chips [ ]
   - roda apenas em blocos de texto (p, li) e não mexe dentro de code/pre */
const processInline = (root=document)=>{
  const targets = $$('p, li, h1, h2, h3, h4, h5, h6', root).filter(n=>!n.closest('pre, code, .no-beauty'));
  const rxKV = /(^|\s)([A-Za-zÀ-ÿ0-9_]+):(?=\s|$)/g; // Palavra:
  const rxParen = /\(([^\n)]+)\)/g;                  // ( … )
  const rxChip  = /\[\[([^[\]]+)\]\]|\[([^[\]]+)\]/g; // [[a]] | [a]

  for(const el of targets){
    // evita processar múltiplas vezes
    if(el.dataset.inlineProcessed==='1') continue;
    el.dataset.inlineProcessed='1';

    const html = el.innerHTML;
    if(/<pre|<code|contenteditable/i.test(html)) continue;

    let out = html;

    // 1. Palavra:  → <strong>
    out = out.replace(rxKV, (m, sp, key)=> `${sp}<strong class="kv-key">${key}:</strong>`);

    // 2. ( ... )   → span-paren
    out = out.replace(rxParen, (m, inside)=> `<span class="span-paren">(${inside})</span>`);

    // 3. [ ... ] / [[ ... ]]  → chip/chip-btn
    out = out.replace(rxChip, (m, dbl, sgl)=>{
      const label = (dbl||sgl||'').trim();
      return `<span class="${dbl?'chip-btn':'chip'}" data-chip="${esc(label)}">${esc(label)}</span>`;
    });

    el.innerHTML = out;
  }
};

/* 2) Perguntas → .q-card (frases que terminam com '?') */
const processQuestions=(root=document)=>{
  const paras = $$('p', root).filter(n=>!n.closest('.q-card, pre, code, .no-beauty'));
  for(const p of paras){
    const txt = (p.innerText||'').trim();
    if(txt.endsWith('?') && !p.dataset.qProcessed){
      p.dataset.qProcessed='1';
      const wrap=document.createElement('div'); wrap.className='q-card';
      wrap.innerHTML = `<div class="q-ico">?</div><div class="q-body">${esc(txt)}</div>`;
      p.replaceWith(wrap);
    }
  }
};

/* 3) Flow text: melhora texto corrido, cria heading leve se linha for "Algo:" sozinha */
const beautifyFlow=(root=document)=>{
  const container = root.querySelector('.flow-text') || root; // se já tiver classe, usa; senão aplica heurística suave
  $$('p', container).forEach(p=>{
    const t=(p.innerText||'').trim();
    if(/^[^:\n]{3,}:\s*$/.test(t)){ // linha que termina com ":" vira heading leve
      p.classList.add('kv-head');
    }
    // Quebra parágrafos absurdamente longos em dois (heurística)
    if(t.length>600 && t.includes('. ')){
      const mark = t.indexOf('. ', Math.floor(t.length/2));
      if(mark>0){
        const a=t.slice(0, mark+1), b=t.slice(mark+1);
        const p2=p.cloneNode(); p2.textContent=b.trim();
        p.textContent=a.trim();
        p.insertAdjacentElement('afterend', p2);
      }
    }
  });
};

/* 4) Listas copiáveis: badge + click copy */
const enableCopyLists=(root=document)=>{
  const lists = $$('.list-card', root);
  for(const card of lists){
    if(card.querySelector('.copy-badge')) continue;
    const badge = document.createElement('div');
    badge.className='copy-badge'; badge.textContent='copiar';
    card.appendChild(badge);
    card.addEventListener('click', e=>{
      // evita copiar quando clicou em link/botão dentro
      if(e.target.closest('a,button,.chip,.chip-btn')) return;
      const txt = [...card.querySelectorAll('li')].map(li=>li.innerText.trim()).join('\n');
      navigator.clipboard.writeText(txt).then(()=>{
        badge.textContent='copiado!'; setTimeout(()=>badge.textContent='copiar',1200);
      });
    }, {passive:true});
  }
};

/* 5) HTML/SVG pass-through
   - ```html-raw ... ``` → renderiza
   - <div data-raw-html>…(escapado)…</div> → renderiza
*/
const renderRawHTML=(root=document)=>{
  // code fence transform
  $$('pre code', root).forEach(code=>{
    const cls = (code.className||'').toLowerCase();
    if(cls.includes('language-html-raw') || cls.includes('lang-html-raw')){
      const raw = code.textContent;
      const box = document.createElement('div');
      box.className='raw-html-card';
      box.innerHTML = `<div class="raw-note">HTML/SVG renderizado a partir de bloco <code>html-raw</code></div>`;
      const slot = document.createElement('div');
      slot.className='raw-slot';
      // injeta SEM esc, assumindo que o autor confia no conteúdo
      slot.innerHTML = raw;
      box.appendChild(slot);
      const pre = code.closest('pre');
      pre.replaceWith(box);
    }
  });

  // <div data-raw-html>…</div>
  $$('div[data-raw-html]', root).forEach(div=>{
    const raw = div.textContent; // assume texto escapado pelo md
    const box = document.createElement('div'); box.className='raw-html-card';
    const slot = document.createElement('div'); slot.className='raw-slot';
    slot.innerHTML = raw;
    box.appendChild(slot);
    div.replaceWith(box);
  });
};

/* 6) Delegação de cliques para chips (colchetes) */
document.addEventListener('click', e=>{
  const chip = e.target.closest('.chip, .chip-btn');
  if(chip){
    const label = chip.dataset.chip||chip.textContent.trim();
    // dispara um evento customizado para teu bus/orquestrador
    const ev = new CustomEvent('chip:click', {detail:{label, source:'text-beauty-v3'}});
    document.dispatchEvent(ev);
  }
}, {passive:true});

/* 7) Orquestração */
const run=(ctx=document)=>{
  processInline(ctx);
  processQuestions(ctx);
  beautifyFlow(ctx);
  enableCopyLists(ctx);
  renderRawHTML(ctx);
};

if(window.__RENDERBUS__?.on){
  window.__RENDERBUS__.on('after', run, {name:'text-beauty-v3', priority: 96});
}else{
  (document.readyState==='loading') ? document.addEventListener('DOMContentLoaded',()=>run(document)) : run(document);
  new MutationObserver(m=>m.forEach(x=>x.addedNodes&&x.addedNodes.forEach(n=>n.nodeType===1&&run(n))))
    .observe(document.body,{childList:true,subtree:true});
}
})();
</script><script id="TRINITY_OVERRIDE">
/* --- START OF livro_vivo_trinity_override.js (injetado) --- */
/* Conteúdo do seu script TRINITY (TTS / hooks). Autoinit e funções públicas. */
/* O conteúdo abaixo foi copiado do arquivo enviado. */
/* ---------- BEGIN TRINITY SCRIPT ---------- */
(function(){
  if(window.TrinityTTS && window.TrinityTTS.__loaded) return;
  window.TrinityTTS = window.TrinityTTS || {};
  window.TrinityTTS.__loaded = true;

  // Implementação simplificada das funções principais esperadas pelo patch:
  window.TrinityTTS.injectJokers = function(rootSelector){
    // exemplo: adiciona botões de TTS em .msg-block.ai
    const root = rootSelector ? document.querySelector(rootSelector) : document;
    if(!root) return;
    root.querySelectorAll('.msg-block.ai').forEach(block=>{
      if(block.dataset.trinityAttached) return;
      const btn = document.createElement('button');
      btn.className = 'tool-btn';
      btn.title = 'Ler com Trinity';
      btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 1v22"/></svg>';
      btn.onclick = ()=> {
        const text = block.dataset.raw || block.innerText || '';
        // voice speak simple fallback (uses speechSynthesis)
        try{
          const ut = new SpeechSynthesisUtterance(text.replace(/<[^>]*>/g,''));
          ut.lang = 'pt-BR'; ut.rate = 1.05;
          speechSynthesis.cancel(); speechSynthesis.speak(ut);
        }catch(e){ console.warn('[Trinity] speak failed', e); }
      };
      // insert at beginning of .msg-tools if exists, else append
      const tools = block.querySelector('.msg-tools');
      if(tools) tools.insertBefore(btn, tools.firstChild);
      else block.appendChild(btn);
      block.dataset.trinityAttached = '1';
    });
  };

  window.TrinityTTS.attachPlayable = function(rootSelector){
    // placeholder: could attach audio players if available
    return window.TrinityTTS.injectJokers(rootSelector);
  };

  // auto-init on event
  document.addEventListener('infodx:rendered', (e)=>{
    try{ window.TrinityTTS.injectJokers('#chat-container'); }catch(e){}
  });

  // expose simple API to speak raw text
  window.TrinityTTS.speak = function(text, opts={}){
    try{
      const u = new SpeechSynthesisUtterance(String(text || ''));
      u.lang = opts.lang || 'pt-BR'; u.rate = opts.rate || 1.0;
      window.speechSynthesis.cancel(); window.speechSynthesis.speak(u);
    }catch(e){ console.warn(e); }
  };

})();
 /* ---------- END TRINITY SCRIPT ---------- */
</script><script id="INFODOX_EMBED_LOADER">
(function(){
  'use strict';
  // 1) Emit event once on DOMContentLoaded (already mostly handled), and provide a fallback observer
  function fireRendered(node){
    document.dispatchEvent(new CustomEvent('infodx:rendered', { detail: { node: node || document } }));
  }

  document.addEventListener('DOMContentLoaded', ()=> setTimeout(()=>fireRendered(document), 80));

  // MutationObserver to catch dynamic chat renders
  const mo = new MutationObserver((mut)=>{
    for(const m of mut){
      if(!m.addedNodes) continue;
      for(const n of m.addedNodes){
        if(n.nodeType!==1) continue;
        // if new message nodes are appended, trigger beauty+trinity
        if(n.matches && (n.matches('.msg-block') || n.querySelector && n.querySelector('.msg-block'))){
          fireRendered(n);
        }
      }
    }
  });
  mo.observe(document.getElementById('chat-container') || document.body, { childList: true, subtree: true });

  // 2) Try to run the exposed functions if available
  function runPostRender(node){
    try{
      if(window.__TEXT_BEAUTY_V3_RUN__) window.__TEXT_BEAUTY_V3_RUN__(node ? (node.nodeType===1 ? null : null) : null);
      if(window.__TEXT_BEAUTY_V3__) {
        window.__TEXT_BEAUTY_V3__.processInline(document);
        window.__TEXT_BEAUTY_V3__.processQuestions(document);
        window.__TEXT_BEAUTY_V3__.beautifyFlow(document);
        window.__TEXT_BEAUTY_V3__.enableCopyLists(document);
        window.__TEXT_BEAUTY_V3__.renderRawHTML(document);
      }
      if(window.TrinityTTS && typeof window.TrinityTTS.injectJokers === 'function'){
        window.TrinityTTS.injectJokers('#chat-container');
      }
    }catch(e){ console.warn('[INFODOX_EMBED_LOADER] post render error', e); }
  }

  document.addEventListener('infodx:rendered', (e)=> {
    runPostRender(e && e.detail ? e.detail.node : document);
  });

  // 3) expose manual helper
  window.Infodox = window.Infodox || {};
  window.Infodox.runAll = function(rootSelector){
    try{
      const root = rootSelector ? document.querySelector(rootSelector) : document;
      if(window.__TEXT_BEAUTY_V3_RUN__) window.__TEXT_BEAUTY_V3_RUN__(rootSelector);
      if(window.__TEXT_BEAUTY_V3__) {
        window.__TEXT_BEAUTY_V3__.processInline(root);
        window.__TEXT_BEAUTY_V3__.processQuestions(root);
        window.__TEXT_BEAUTY_V3__.beautifyFlow(root);
        window.__TEXT_BEAUTY_V3__.enableCopyLists(root);
        window.__TEXT_BEAUTY_V3__.renderRawHTML(root);
      }
      if(window.TrinityTTS) window.TrinityTTS.injectJokers(rootSelector || '#chat-container');
      console.info('[Infodox.runAll] executed');
    }catch(e){ console.warn(e); }
  };

  // 4) small UX hint
  console.info('[INFODOX PATCH] Beauty.v3 + Trinity loaded. Use Infodox.runAll() to manually trigger.');
})();
</script><script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script><script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script><script src="https://cdn.jsdelivr.net/npm/highlight.js@11.10.0/build/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script><script>hljs.highlightAll();</script><script>
/* =========================================================
   DUAL.INFODOSE v7.9 — KOBLLUX VISIO & MEMORIA
   - Fix: Cristalização (Deck) funcional e visível
   - New: Visualizador HTML (Preview/Code/Fullscreen/Mobile)
   - Core: Fractal 3-6-9-7 + Ciclos Solares
========================================================= */

const STORAGE = {
    API_KEY: 'di_apiKey',
    MODEL: 'di_modelName',
    SYSTEM_ROLE: 'di_systemRole',
    USER_ID: 'di_userName',
    BG_IMAGE: 'di_bgImage',
    CUSTOM_CSS: 'di_customCss',
    SOLAR_MODE: 'di_solarMode',
    SOLAR_AUTO: 'di_solarAuto',
    INFODOSE_NAME: 'di_infodoseName',
    ASSISTANT_ENABLED: 'di_assistantEnabled',
    TRAINING_ACTIVE: 'di_trainingActive',
    TRAINING_TEXT: 'di_trainingText',
    MESSAGES: 'di_messages'
};

// KODUX ARQUÉTIPOS E FASES
const KODUX = {
    ARQUETIPOS: { "Atlas":{Essencia:"Planejador"}, "Nova":{Essencia:"Inspira"}, "Vitalis":{Essencia:"Momentum"}, "Pulse":{Essencia:"Emocional"}, "Artemis":{Essencia:"Descoberta"}, "Serena":{Essencia:"Cuidado"}, "Kaos":{Essencia:"Transformador"}, "Genus":{Essencia:"Fabricus"}, "Lumine":{Essencia:"Alegria"}, "Solus":{Essencia:"Sabedoria"}, "Rhea":{Essencia:"Vínculo"}, "Aion":{Essencia:"Tempo"} },
    PROJETO: { "I. INTRODUÇÃO":{fase:"KODUX (Δ³)",arquetipos:["Atlas","Nova","Pulse"]}, "II. ATO I":{fase:"BLLUE (Δ⁶)",arquetipos:["Vitalis","Pulse","Genus"]}, "III. ATO II":{fase:"EXPANSÃO (Δ⁹)",arquetipos:["Genus","Nova","Vitalis"]}, "IV. ATO III":{fase:"CONVERGÊNCIA (Δ⁹)",arquetipos:["Genus","Aion","Pulse"]}, "V. EPÍLOGO":{fase:"VERBO ETERNO (Δ⁷)",arquetipos:["Atlas","Aion","Genus"]} }
};


/* ═══════════════════════════════════════════════════════════════
   INTEGRAÇÃO DE CONSTANTES di_* DO LOCALSTORAGE
   ═══════════════════════════════════════════════════════════════ */

function initDIConstants() {
    const di_userName = localStorage.getItem('di_userName') || 'Viajante';
    const di_infodoseName = localStorage.getItem('di_infodoseName') || 'KOBLLUX';
    const di_apiKey = localStorage.getItem('di_apiKey') || '';
    const di_modelName = localStorage.getItem('di_modelName') || 'nvidia/nemotron-3-nano-30b-a3b:free';
    const di_systemRole = localStorage.getItem('di_systemRole') || 'oi Dual';
    const di_solarMode = localStorage.getItem('di_solarMode') || 'night';
    const di_assistantEnabled = localStorage.getItem('di_assistantEnabled') === '1';
    const di_trainingActive = localStorage.getItem('di_trainingActive') === '1';
    const di_trainingText = localStorage.getItem('di_trainingText') || '';
    
    // Atualizar elementos da UI
    const usernameDisplay = document.getElementById('usernameDisplay');
    if (usernameDisplay) {
        usernameDisplay.textContent = di_userName;
    }
    
    const modeIndicator = document.getElementById('modeIndicator');
    if (modeIndicator) {
        modeIndicator.textContent = `${di_infodoseName} · ${di_solarMode.toUpperCase()}`;
    }
    
    // Preencher inputs com valores salvos
    const apiKeyInput = document.getElementById('apiKeyInput');
    if (apiKeyInput) apiKeyInput.value = di_apiKey;
    
    const systemRoleInput = document.getElementById('systemRoleInput');
    if (systemRoleInput) systemRoleInput.value = di_systemRole;
    
    const inputUserId = document.getElementById('inputUserId');
    if (inputUserId) inputUserId.value = di_userName;
    
    const inputModel = document.getElementById('inputModel');
    if (inputModel) inputModel.value = di_modelName;
    
    // Salvar no localStorage se não existir
    if (!localStorage.getItem('di_userName')) localStorage.setItem('di_userName', di_userName);
    if (!localStorage.getItem('di_infodoseName')) localStorage.setItem('di_infodoseName', di_infodoseName);
    if (!localStorage.getItem('di_solarMode')) localStorage.setItem('di_solarMode', di_solarMode);
    
    console.log('[DI_CONSTANTS] Inicializado:', { di_userName, di_infodoseName, di_apiKey: di_apiKey ? '✓' : '✗' });
}

// Chamar ao carregar a página
document.addEventListener('DOMContentLoaded', initDIConstants);

const FOOTER_TEXTS = { closed:{ritual:["tocar o campo é consentir","registro aguarda presença"],tecnico:["latência detectada","aguardando input"]}, open:{sustentado:["campo ativo","consciência expandida"],estavel:["sinal estabilizado","link neural firme"]}, loading:["sincronizando neuro-link...","buscando no éter...","decodificando sinal..."] };

let lastText = null;
function getRandomText(arr){ if(!arr||arr.length===0)return"Processando..."; let t; do{t=arr[Math.floor(Math.random()*arr.length)];}while(t===lastText&&arr.length>1); lastText=t; return t; }

/* ---------------------------------------------------------
   KOBLLUX CORE (3-6-9-7)
   --------------------------------------------------------- */
const KoblluxCore = {
    async sha256Hex(s) { const d = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(s)); return [...new Uint8Array(d)].map(b=>b.toString(16).padStart(2,'0')).join(''); },
    classifyText(s) { const t = (s.match(/[\p{L}\p{N}_-]+/gu)||[]); const endsV = ['ar','er','ir']; const verbs=[],nouns=[],adjs=[]; for (const w0 of t){ const w = w0.toLowerCase(); if(w.endsWith('mente')){adjs.push(w0);continue;} if(endsV.some(e=>w.endsWith(e))){verbs.push(w0);continue;} if(w.endsWith('ção')||w.endsWith('são')||w.endsWith('dade')){nouns.push(w0);continue;} if(/^[A-Z]/.test(w0)){nouns.push(w0);continue;} } return {tokens:t, verbs, nouns, adjs}; },
    mapTrinity(pos) { return { UNO: pos.nouns[0]||'NÚCLEO', DUAL: pos.verbs[0]||'relaciona', TRINITY: pos.adjs[0]||'integrado' }; },
    async process(input) { if(!input)return null; const pos=this.classifyText(input); const tri=this.mapTrinity(pos); const seal=await this.sha256Hex(input+new Date().toISOString()); return { raw:input, pos:pos, trinity:tri, seal:seal.slice(0,16), log:`[KOBLLUX ∆7] UNO:${tri.UNO}|DUAL:${tri.DUAL}|TRI:${tri.TRINITY}::SEAL:${seal.slice(0,8)}` }; }
};

/* ---------------------------------------------------------
   UTILS: DOWNLOAD, PREVIEW, ZIP
   --------------------------------------------------------- */
const DownloadUtils = {
    _getBlock(btn) { return btn.closest('.msg-block'); },
    _getCleanHtml(block) { const clone = block.cloneNode(true); const tools = clone.querySelector('.msg-tools'); if(tools) tools.remove(); return clone.innerHTML; },
    _guessFilename(base, extFallback='txt') { const t = new Date().toISOString().replace(/[:.]/g,'-'); if (!base) return `ai-output-${t}.${extFallback}`; if (/<\s*!doctype|<html|<body|<head/i.test(base)) return `ai-output-${t}.html`; if (/<pre|<code/i.test(base)) return `ai-code-${t}.${extFallback}`; return `ai-output-${t}.${extFallback}`; },
    downloadMessage(btn) { try { const block = this._getBlock(btn); if(!block) return; const content = this._getCleanHtml(block); const isHTML = /<\s*!doctype|<html|<body|<head|<\/div>/i.test(content); const mime = isHTML ? 'text/html' : 'text/plain'; const ext = isHTML ? 'html' : 'txt'; const filename = this._guessFilename(content, ext); const blob = new Blob([content], { type: mime + ';charset=utf-8' }); this.triggerDownload(blob, filename); App.showToast(`Download: ${filename}`); } catch(e){ App.showToast('Erro download', true); } },
    downloadMarkdown(btn) { try { const block = this._getBlock(btn); if(!block) return; const raw = block.dataset.raw || block.innerText || ''; const filename = this._guessFilename(raw, 'md').replace(/\.(html|txt)$/, '.md'); const blob = new Blob([raw], { type: 'text/markdown;charset=utf-8' }); this.triggerDownload(blob, filename); App.showToast(`MD salvo: ${filename}`); } catch(e){ App.showToast('Erro MD', true); } },
    openSandbox(btn) { try { const block = this._getBlock(btn); if(!block) return; const content = this._getCleanHtml(block); let page = content; if(!/<\s*!doctype|<html/i.test(content)) page = `<!doctype html><html lang="pt-BR"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Sandbox</title></head><body>${content}</body></html>`; const blob = new Blob([page], { type: 'text/html' }); const url = URL.createObjectURL(blob); window.open(url, '_blank'); App.showToast('Sandbox aberto'); } catch(e){ App.showToast('Erro sandbox', true); } },
    async exportPdf(btn) { try { if(typeof html2pdf === 'undefined') { App.showToast('PDF lib ausente. Use Sandbox.', true); return this.openSandbox(btn); } const block = this._getBlock(btn); if(!block) return; const content = this._getCleanHtml(block); const container = document.createElement('div'); container.style.position = 'fixed'; container.style.left = '-9999px'; container.style.width = '1100px'; container.style.padding = '20px'; container.style.background = '#ffffff'; container.innerHTML = content; document.body.appendChild(container); const filename = this._guessFilename(content, 'pdf').replace(/\.(html|txt)$/, '.pdf'); await html2pdf().from(container).set({ margin: 12, filename: filename, html2canvas: { scale: 2 }, jsPDF: { unit: 'pt', format: 'a4' } }).save(); document.body.removeChild(container); App.showToast(`PDF: ${filename}`); } catch(e){ App.showToast('Erro PDF', true); } },
    triggerDownload(blob, filename) { const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); setTimeout(() => URL.revokeObjectURL(url), 2000); }
};

const Preview = {
    async renderPreview(file) {
        const type = file.type || 'text/plain'; const name = file.name || 'arquivo'; const url = URL.createObjectURL(file);
        if (type === 'text/html' || name.endsWith('.html')) { const text = await file.text(); const blob = new Blob([this.sanitizeHTML(text)], { type: 'text/html' }); return `<div class="preview-html"><iframe src="${URL.createObjectURL(blob)}" sandbox="allow-scripts"></iframe></div>`; }
        if (type.startsWith('image/')) return `<div class="preview-html"><img src="${url}" style="width:100%;height:100%;object-fit:contain;background:#000;"></div>`;
        const text = await file.text(); const ext = name.split('.').pop() || 'txt'; const code = this.escapeHTML(text.slice(0, 2000)); setTimeout(() => { hljs.highlightAll(); }, 0); return `<div class="preview-code"><pre><code class="language-${ext}">${code}</code></pre></div>`;
    },
    sanitizeHTML(html) { const div = document.createElement('div'); div.innerHTML = html; div.querySelectorAll('script').forEach(s => s.remove()); return div.innerHTML; },
    escapeHTML(str) { return str.replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s])); },
    
    // VISUALIZADOR HTML (Atualizado)
    createHtmlViewer(htmlCode) {
        const id = 'html-' + Date.now();
        const blob = new Blob([htmlCode], {type: 'text/html'});
        const url = URL.createObjectURL(blob);
        const codeEscaped = this.escapeHTML(htmlCode);
        
        return `
        <div class="html-viewer" id="${id}">
            <div class="html-viewer-bar">
                <button class="html-viewer-btn active" onclick="Preview.switchView('${id}', 'preview')">
                    <svg class="svg-icon"><use href="#icon-eye"></use></svg> Preview
                </button>
                <button class="html-viewer-btn" onclick="Preview.switchView('${id}', 'code')">
                    <svg class="svg-icon"><use href="#icon-code"></use></svg> Código
                </button>
                <button class="html-viewer-btn" onclick="Preview.openFullscreen('${id}', '${url.replace(/'/g, "\\'")}')">
                    <svg class="svg-icon"><use href="#icon-maximize"></use></svg> Tela Cheia
                </button>
                <div class="mobile-toggle">
                    <button class="html-viewer-btn" onclick="Preview.toggleMobile('${id}')">
                        <svg class="svg-icon"><use href="#icon-eye"></use></svg> Mobile
                    </button>
                </div>
            </div>
            <div class="html-viewer-content">
                <iframe src="${url}" sandbox="allow-scripts allow-popups"></iframe>
                <div class="html-viewer-code"><pre><code class="language-html">${codeEscaped}</code></pre></div>
            </div>
        </div>`;
    },

    switchView(id, mode) {
        const container = document.getElementById(id);
        if(!container) return;
        
        if(mode === 'code') {
            container.classList.add('show-code');
        } else {
            container.classList.remove('show-code');
        }
        
        // Atualiza botões ativos
        container.querySelectorAll('.html-viewer-btn').forEach(b => b.classList.remove('active'));
        event.currentTarget.classList.add('active');
    },

    openFullscreen(id, url) {
        const container = document.getElementById(id);
        if(!container) return;
        
        // Modo tela cheia
        container.classList.add('fullscreen');
        container.querySelector('iframe').src = url;
        
        // Botão para sair
        const bar = container.querySelector('.html-viewer-bar');
        const exitBtn = document.createElement('button');
        exitBtn.className = 'html-viewer-btn';
        exitBtn.innerHTML = '<svg class="svg-icon"><use href="#icon-restore"></use></svg> Sair';
        exitBtn.onclick = () => {
            container.classList.remove('fullscreen');
            exitBtn.remove();
        };
        bar.appendChild(exitBtn);
    },

    toggleMobile(id) {
        const container = document.getElementById(id);
        if(!container) return;
        
        container.classList.toggle('mobile');
        
        // Atualiza botão mobile
        const btn = event.currentTarget;
        if(container.classList.contains('mobile')) {
            btn.innerHTML = '<svg class="svg-icon"><use href="#icon-eye"></use></svg> Desktop';
        } else {
            btn.innerHTML = '<svg class="svg-icon"><use href="#icon-eye"></use></svg> Mobile';
        }
    }
};

const ZipGenerator = {
    async generateZip() {
        try {
            const { default: JSZip } = await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');
            const zip = new JSZip();
            const root = zip.folder("KOBLLUX_INTEGRADO");
            root.folder("00_CORE").file("config.json", JSON.stringify(KODUX, null, 2));
            root.folder("00_CORE").file("timestamp.txt", new Date().toISOString());
            root.folder("01_CYCLES_3x3"); root.folder("02_PARTS"); root.folder("03_REDE"); root.folder("04_EXPORT");
            
            const content = await zip.generateAsync({ type: "blob" });
            const md5 = await this.hash(content, 'MD5');
            const sha = await this.hash(content, 'SHA-256');
            const name = `KOBLLUX_${new Date().toISOString().slice(0,10)}.zip`;
            DownloadUtils.triggerDownload(content, name);
            return { success: true, fileName: name, md5: md5, sha256: sha };
        } catch (e) { return { success: false, error: e.message }; }
    },
    async hash(blob, algo) { const b = await blob.arrayBuffer(); const h = await crypto.subtle.digest(algo, b); return Array.from(new Uint8Array(h)).map(x => x.toString(16).padStart(2,'0')).join(''); }
};

const Utils = {
    copy(btn) { const b = btn.closest('.msg-block'); if(!b)return; navigator.clipboard.writeText(b.innerText.replace("content_copy","").trim()); App.showToast("Copiado"); },
    speak(btn) { const b = btn.closest('.msg-block'); if(!b)return; App.speakText(b.innerText.replace(/<[^>]*>?/gm, '').trim()); },
    edit(btn) { const b = btn.closest('.msg-block'); const t = b.innerText.replace("content_copy","").trim(); document.getElementById('userInput').value = t; b.remove(); App.speakText("Editando"); }
};

/* ---------------------------------------------------------
   MAIN APP CONTROLLER
   --------------------------------------------------------- */
const App = {
    state: { open: false, messages: [], isAutoSolar: true, solarMode: 'night', isProcessing: false, isListening: false, recognition: null },
    
    init() {
        const s = localStorage;
        document.getElementById('apiKeyInput').value = s.getItem(STORAGE.API_KEY) || '';
        
        const baseRole = s.getItem(STORAGE.SYSTEM_ROLE) || 'Você é Dual.';
        if(!baseRole.includes("KODUX")) document.getElementById('systemRoleInput').value = baseRole + `\n[SISTEMA KODUX V7.9]\nArquétipos: ${Object.keys(KODUX.ARQUETIPOS).join(', ')}. Use V.E.E.B.`;
        else document.getElementById('systemRoleInput').value = baseRole;

        document.getElementById('inputUserId').value = s.getItem(STORAGE.USER_ID) || 'Viajante';
        document.getElementById('inputModel').value = s.getItem(STORAGE.MODEL) || 'openai/gpt-oss-20b:free';
        this.state.isAutoSolar = s.getItem(STORAGE.SOLAR_AUTO) !== 'false';
        
        // CORREÇÃO: Força o modo correto na inicialização
        if (this.state.isAutoSolar) this.autoByTime(); else this.setMode(s.getItem(STORAGE.SOLAR_MODE) || 'night');

        this.indexedDB.loadCustomCSS();
        this.indexedDB.loadBackground();
        this.setupVoiceSystem();
        this.bindEvents();
        this.updateUI();
        this.toggleField(false, true); 
        this.renderDeck();
        
        setTimeout(() => this.announce("KOBLLUX V7.9 Visio. Memória Ativa."), 1200);
        if(typeof particlesJS !== 'undefined') particlesJS('particles-js', {particles:{number:{value:30},color:{value:"#ffffff"},opacity:{value:0.5},size:{value:2},line_linked:{enable:true,distance:150,color:"#ffffff",opacity:0.2,width:1}}});
    },

    // --- VOZ ---
    setupVoiceSystem() {
        if (!('webkitSpeechRecognition' in window)) return;
        this.state.recognition = new webkitSpeechRecognition();
        this.state.recognition.lang = 'pt-BR';
        this.state.recognition.continuous = true; 
        this.state.recognition.interimResults = true;
        this.state.recognition.onstart = () => { this.state.isListening = true; document.getElementById('btnVoice').classList.add('listening'); this.showToast("🎙️ Voz Ativa..."); };
        this.state.recognition.onend = () => { if (this.state.isListening) try { this.state.recognition.start(); } catch(e){} else document.getElementById('btnVoice').classList.remove('listening'); };
        this.state.recognition.onresult = (e) => { let t=''; for(let i=e.resultIndex;i<e.results.length;++i) t+=e.results[i][0].transcript; document.getElementById('userInput').value=t; };
        this.state.recognition.onerror = (e) => { if(e.error!=='no-speech') { this.state.isListening=false; document.getElementById('btnVoice').classList.remove('listening'); } };
    },
    toggleVoice() {
        if (!this.state.recognition) return;
        if (this.state.isListening) { this.state.isListening = false; this.state.recognition.stop(); }
        else { window.speechSynthesis.cancel(); document.getElementById('userInput').value = ''; try { this.state.recognition.start(); } catch(e){} }
    },

    // --- UPLOAD ---
    setupFileUpload() {
        const input = document.getElementById('fileUploadInput');
        document.getElementById('btnUploadFile').onclick = () => input.click();
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const preview = document.getElementById('filePreview');
            preview.querySelector('.file-info span').textContent = file.name;
            preview.classList.add('active');
            preview.querySelector('.file-actions').innerHTML = `<button class="btn-preview" onclick="App.cancelUpload()">✕</button><button class="btn-preview primary" onclick="App.confirmUpload('${file.name}')">Assimilar</button>`;
        };
    },
    cancelUpload() { document.getElementById('filePreview').classList.remove('active'); document.getElementById('fileUploadInput').value = ''; },
    async confirmUpload(fileName) {
        const file = document.getElementById('fileUploadInput').files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = async (e) => {
            const content = e.target.result;
            const previewHTML = await Preview.renderPreview(file);
            const size = (file.size/1024/1024).toFixed(2);
            this.addFileMessage(file, previewHTML, size);
            const fractal = await KoblluxCore.process(content);
            this.addMessage('system', `Memória Fractal: ${fileName}\n${fractal.log}`);
            this.state.messages.push({ role: 'user', content: `[ARQUIVO: ${fileName}]\n[TRINITY: ${JSON.stringify(fractal.trinity)}]\n${content}\n[SELO: ${fractal.seal}]` });
            this.cancelUpload();
        };
        reader.readAsText(file);
    },
    addFileMessage(file, previewHTML, sizeMB) {
        const c = document.getElementById('chat-container');
        const d = document.createElement('div');
        d.className = 'msg-block file-msg ai';
        d.innerHTML = `<div class="file-header"><strong>${file.name}</strong><span class="file-meta">${sizeMB} MB • ${file.type}</span></div>${previewHTML}<div class="msg-tools"><button class="tool-btn" onclick="DownloadUtils.triggerDownload(new Blob(['${file.name}']), '${file.name}')">📥 Baixar</button></div>`;
        c.appendChild(d); c.scrollTop = c.scrollHeight;
    },

    // --- CHAT ---
    async handleSend() {
        const input = document.getElementById('userInput');
        const txt = input.value.trim();
        if (!txt || this.state.isProcessing) return;

        if(txt.toLowerCase() === '/atlas') {
            input.value = ''; this.addMessage('user', txt);
            let rep = "### ♾️ ATLAS KODUX\n";
            for(const [k,v] of Object.entries(KODUX.ARQUETIPOS)) rep+=`- **${k}**: ${v.Essencia}\n`;
            this.addMessage('ai', rep); return;
        }
        if(txt.toLowerCase() === '/zip') {
            input.value = ''; this.addMessage('user', txt);
            this.addMessage('system', "Gerando KOBLLUX...");
            const res = await ZipGenerator.generateZip();
            this.addMessage('system', res.success ? `✅ Pacote: ${res.fileName}\nSHA: ${res.sha256}` : `❌ Erro: ${res.error}`);
            return;
        }

        const fractal = await KoblluxCore.process(txt);
        input.value = '';
        this.addMessage('user', txt);
        this.state.isProcessing = true;
        document.getElementById('field-toggle-handle').innerHTML = `<span class="footer-dot pulse"></span> ${getRandomText(FOOTER_TEXTS.loading)}`;
        
        const key = localStorage.getItem(STORAGE.API_KEY);
        if (!key && !document.getElementById('inputModel').value.includes(':free')) { this.announce("Erro: API Key."); this.state.isProcessing = false; return; }

        try {
            document.body.classList.add('loading');
            const res = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${key}`, 'Content-Type': 'application/json', 'HTTP-Referer': location.origin },
                body: JSON.stringify({
                    model: document.getElementById('inputModel').value,
                    messages: [ 
                        { role: 'system', content: document.getElementById('systemRoleInput').value },
                        ...this.state.messages.slice(-10).map(m => ({ role: m.role, content: m.content })),
                        { role: 'user', content: `${txt}\n\n[KOBLLUX]\nUNO:${fractal.trinity.UNO}\nSELO:${fractal.seal}` } 
                    ]
                })
            });
            const data = await res.json();
            const aiContent = data.choices?.[0]?.message?.content || "Sem sinal.";
            
            // DETECTAR SE É HTML PURO PARA O VISUALIZADOR
            if (/^\s*(<!doctype html|<html)/i.test(aiContent)) {
               this.addHTMLViewer(aiContent);
               // Adiciona ao histórico sem renderizar de novo
               this.state.messages.push({ role: 'assistant', content: aiContent });
            } else {
               this.addMessage('ai', aiContent);
            }
            
        } catch (e) { this.announce("Erro conexão."); } 
        finally { document.body.classList.remove('loading'); this.state.isProcessing = false; this.toggleField(this.state.open, true); }
    },

    addMessage(role, text) {
        const c = document.getElementById('chat-container');
        const d = document.createElement('div'); d.className = `msg-block ${role}`; d.dataset.raw = text||'';
        
        let html = role==='ai' ? marked.parse(text) : text.replace(/\n/g, '<br>');
        
        if(role !== 'system') {
            html += `<div class="msg-tools">
                <button class="tool-btn" onclick="Utils.copy(this)" title="Copiar"><svg><use href="#icon-copy"></use></svg></button>
                <button class="tool-btn" onclick="Utils.speak(this)" title="Ouvir"><svg><use href="#icon-mic"></use></svg></button>
                ${role === 'ai' ? `
                  <button class="tool-btn" onclick="DownloadUtils.downloadMessage(this)" title="Baixar"><svg><use href="#icon-download"></use></svg></button>
                  <button class="tool-btn" onclick="DownloadUtils.openSandbox(this)" title="Sandbox"><svg><use href="#icon-sandbox"></use></svg></button>
                  <button class="tool-btn" onclick="DownloadUtils.exportPdf(this)" title="PDF"><svg><use href="#icon-pdf"></use></svg></button>` : 
                  `<button class="tool-btn" onclick="Utils.edit(this)" title="Editar"><svg><use href="#icon-edit"></use></svg></button>`}
            </div>`;
            this.state.messages.push({ role: role==='ai'?'assistant':'user', content: text });
        }
        d.innerHTML = html;
        if (role === 'ai') d.querySelectorAll('pre').forEach(pre => { 
            const btn = document.createElement('button'); btn.className = 'copy-code-btn'; btn.textContent = 'Copiar'; 
            btn.onclick = () => { navigator.clipboard.writeText(pre.querySelector('code').innerText); btn.textContent='Copiado!'; setTimeout(()=>btn.textContent='Copiar',2000); };
            pre.appendChild(btn); 
        });
        c.appendChild(d); c.scrollTop = c.scrollHeight;
    },
    
    // VISUALIZADOR HTML
    addHTMLViewer(htmlContent) {
        const c = document.getElementById('chat-container');
        const d = document.createElement('div'); d.className = `msg-block ai`;
        const viewerHTML = Preview.createHtmlViewer(htmlContent);
        d.innerHTML = `<div>HTML Gerado:</div>${viewerHTML}<div class="msg-tools"><button class="tool-btn" onclick="Utils.copy(this)"><svg><use href="#icon-copy"></use></svg></button></div>`;
        c.appendChild(d); c.scrollTop = c.scrollHeight;
    },

    /* --- GERAL --- */
    speakText(text) { if (!text || this.state.isListening) return; window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(text); u.lang='pt-BR'; u.rate=1.1; window.speechSynthesis.speak(u); },
    announce(msg) { this.showToast(msg); },
    showToast(msg, err=false) { const t = document.getElementById('nv-toast'); t.textContent=msg; t.style.borderLeft=err?'4px solid #f44':'4px solid var(--primary)'; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),3000); this.speakText(msg); },
    
    // CORREÇÃO VISUAL: CICLOS SOLARES
    setMode(m) { 
        this.state.solarMode=m; 
        document.body.classList.remove('mode-day', 'mode-sunset', 'mode-night');
        document.body.classList.add(`mode-${m}`); 
        this.updateUI(); 
        localStorage.setItem(STORAGE.SOLAR_MODE, m); 
    },
    cycleSolar() { const n = this.state.solarMode==='day'?'sunset':(this.state.solarMode==='sunset'?'night':'day'); this.state.isAutoSolar=false; this.setMode(n); },
    enableAutoSolar() { this.state.isAutoSolar=true; this.autoByTime(); this.announce("Auto Solar"); },
    autoByTime() { const h=new Date().getHours(); this.setMode((h>=6&&h<17)?'day':(h>=17&&h<19)?'sunset':'night'); },
    updateUI() { 
        document.getElementById('statusSolarMode').textContent = `${this.state.solarMode.toUpperCase()} ${this.state.isAutoSolar ? '(AUTO)' : '(MAN)'}`; 
        document.getElementById('usernameDisplay').textContent = document.getElementById('inputUserId').value; 
    },
    toggleField(f,s) { this.state.open = f!==undefined?f:!this.state.open; document.getElementById('chat-container').classList.toggle('collapsed', !this.state.open); document.body.classList.toggle('field-closed', !this.state.open); if(!s) this.speakText(getRandomText(FOOTER_TEXTS[this.state.open?'open':'closed']['ritual'])); },
    
    // CORREÇÃO CRISTALIZAÇÃO (DECK)
    async crystallizeSession() {
        if(this.state.messages.length === 0) { this.announce("Vazio não cristaliza."); return; }
        const title = this.state.messages.find(m => m.role === 'user')?.content.substring(0, 30) || "Memória Sem Nome";
        await this.indexedDB.saveDeckItem({ id: Date.now(), date: new Date().toLocaleString(), title: title + "...", data: [...this.state.messages] });
        await this.renderDeck(); // Força render
        this.announce("Memória Salva.");
        if(!document.getElementById('drawerDeck').classList.contains('open')) toggleDrawer('drawerDeck');
    },
    
    async renderDeck() {
        const items = await this.indexedDB.getDeck();
        const container = document.getElementById('deckList');
        if(!items || items.length === 0) {
            container.innerHTML = '<div style="text-align:center;color:var(--text-muted);margin-top:20px">O vazio reina aqui.<br>Use o botão 💎 para salvar.</div>';
            return;
        }
        container.innerHTML = items.sort((a,b) => b.id - a.id).map(item => `
            <div class="deck-item">
                <div class="deck-info" style="cursor:pointer" onclick="App.restoreMemory(${item.id})">
                    <h4>${item.title}</h4>
                    <span>${item.date} • ${item.data.length} msgs</span>
                </div>
                <button class="tool-btn" style="color:var(--danger)" onclick="App.deleteMemory(${item.id})"><svg><use href="#icon-trash"></use></svg></button>
            </div>
        `).join('');
    },
    
    async restoreMemory(id) {
        const items = await this.indexedDB.getDeck();
        const item = items.find(i => i.id === id);
        if(item) {
            document.getElementById('chat-container').innerHTML = ''; // Limpa tela
            this.state.messages = []; // Limpa estado
            item.data.forEach(msg => {
                // Não adiciona no estado aqui, pois addMessage já faz isso se não for system
                // Mas precisamos evitar duplicação no estado se usarmos addMessage
                // Então renderizamos direto e populamos o estado manualmente
                this.addMessage(msg.role === 'assistant' ? 'ai' : 'user', msg.content);
            });
            // Ajuste fino para não duplicar estado (o addMessage já popula)
            // Apenas removemos as últimas duplicatas geradas pelo loop acima se necessário
            // (Mas como limpamos this.state.messages antes, está OK).
            
            toggleDrawer('drawerDeck');
            this.announce("Memória restaurada.");
        }
    },
    
    async deleteMemory(id) {
        if(confirm("Fragmentar cristal?")) {
            await this.indexedDB.deleteDeckItem(id);
            this.renderDeck();
        }
    },

    bindEvents() {
        document.getElementById('btnSend').onclick=()=>this.handleSend();
        document.getElementById('userInput').onkeypress=(e)=>{if(e.key==='Enter')this.handleSend()};
        document.getElementById('field-toggle-handle').onclick=()=>this.toggleField();
        document.getElementById('orbToggle').onclick=()=>{toggleDrawer('drawerProfile');this.speakText("Cockpit");};
        
        // EVENTOS CORRIGIDOS
        document.getElementById('btnCrystallize').onclick = () => this.crystallizeSession();
        document.getElementById('btnCycleSolar').onclick = () => this.cycleSolar();
        document.getElementById('btnAutoSolar').onclick = () => this.enableAutoSolar();
        
        document.getElementById('inputUserId').onchange=(e)=>{localStorage.setItem(STORAGE.USER_ID,e.target.value);this.updateUI();};
        document.getElementById('btnSaveConfig').onclick=()=>{localStorage.setItem(STORAGE.API_KEY,document.getElementById('apiKeyInput').value);localStorage.setItem(STORAGE.SYSTEM_ROLE,document.getElementById('systemRoleInput').value);this.indexedDB.saveCustomCSS(document.getElementById('customCssInput').value);toggleDrawer('drawerSettings');this.announce("Salvo");};
        document.getElementById('bgUploadInput').onchange=(e)=>this.indexedDB.handleBackgroundUpload(e.target.files[0]);
        document.getElementById('btnSettings').onclick=()=>toggleDrawer('drawerSettings');
        document.getElementById('btnDeck').onclick=()=>{ toggleDrawer('drawerDeck'); this.renderDeck(); }; // Garante render ao abrir
        document.getElementById('btnClearCss').onclick=()=>this.indexedDB.clearAsset(STORAGE.CUSTOM_CSS);
        document.getElementById('btnVoice').onclick=()=>this.toggleVoice();
        this.setupFileUpload();
    },

    indexedDB: {
        async getDB() { return new Promise((r,j)=>{const q=indexedDB.open("InfodoseDB",2);q.onupgradeneeded=e=>{const d=e.target.result;if(!d.objectStoreNames.contains('assets'))d.createObjectStore('assets',{keyPath:'id'});if(!d.objectStoreNames.contains('deck'))d.createObjectStore('deck',{keyPath:'id'});};q.onsuccess=e=>r(e.target.result);q.onerror=j;}); },
        async putAsset(i,d){(await this.getDB()).transaction(['assets'],'readwrite').objectStore('assets').put({id:i,...d});},
        async getAsset(i){return new Promise(async r=>(await this.getDB()).transaction(['assets']).objectStore('assets').get(i).onsuccess=e=>r(e.target.result));},
        async clearAsset(i){(await this.getDB()).transaction(['assets'],'readwrite').objectStore('assets').delete(i); if(i===STORAGE.CUSTOM_CSS)document.getElementById('custom-styles').textContent=''; if(i===STORAGE.BG_IMAGE)document.getElementById('bg-fake-custom').style.backgroundImage='';},
        async handleBackgroundUpload(f){if(!f)return;await this.putAsset(STORAGE.BG_IMAGE,{blob:f});this.loadBackground();},
        async loadBackground(){const d=await this.getAsset(STORAGE.BG_IMAGE);if(d?.blob)document.getElementById('bg-fake-custom').style.backgroundImage=`url('${URL.createObjectURL(d.blob)}')`;},
        async saveCustomCSS(c){await this.putAsset(STORAGE.CUSTOM_CSS,{css:c});this.loadCustomCSS();},
        async loadCustomCSS(){const d=await this.getAsset(STORAGE.CUSTOM_CSS);if(d?.css){document.getElementById('custom-styles').textContent=d.css;document.getElementById('customCssInput').value=d.css;}},
        async saveDeckItem(i){(await this.getDB()).transaction(['deck'],'readwrite').objectStore('deck').put(i);},
        async getDeck(){return new Promise(async r=>(await this.getDB()).transaction(['deck']).objectStore('deck').getAll().onsuccess=e=>r(e.target.result));},
        async deleteDeckItem(i){(await this.getDB()).transaction(['deck'],'readwrite').objectStore('deck').delete(i);}
    }
};

function toggleDrawer(id) { document.getElementById(id).classList.toggle('open'); }
window.onload = () => App.init();
</script><script id="TEXT_BEAUTY_V3_SCRIPT">
(()=>{'use strict';
if(window.__TEXT_BEAUTY_V3__) return; window.__TEXT_BEAUTY_V3__=true;

/* Utilitários */
const $=(s,r=document)=>r.querySelector(s);
const $$=(s,r=document)=>[...r.querySelectorAll(s)];
const esc=(s)=>s.replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));

/* 0) Toggle edição rápida */
let EDIT_ON=false;
const toggleEdit=()=>{
  EDIT_ON=!EDIT_ON;
  document.body.toggleAttribute('data-edit', EDIT_ON);
  const host = document.getElementById('CONTENT') || document.querySelector('main, article, .render, .reader, body');
  if(host) host.contentEditable = EDIT_ON ? 'plaintext-only' : 'false';
};
document.addEventListener('keydown',e=>{
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='e'){ e.preventDefault(); toggleEdit(); }
});

/* 1) Key:Value negrito (palavra:) + parênteses + chips [ ]
   - roda apenas em blocos de texto (p, li) e não mexe dentro de code/pre */
const processInline = (root=document)=>{
  const targets = $$('p, li, h1, h2, h3, h4, h5, h6', root).filter(n=>!n.closest('pre, code, .no-beauty'));
  const rxKV = /(^|\s)([A-Za-zÀ-ÿ0-9_]+):(?=\s|$)/g; // Palavra:
  const rxParen = /\(([^\n)]+)\)/g;                  // ( … )
  const rxChip  = /\[\[([^[\]]+)\]\]|\[([^[\]]+)\]/g; // [[a]] | [a]

  for(const el of targets){
    // evita processar múltiplas vezes
    if(el.dataset.inlineProcessed==='1') continue;
    el.dataset.inlineProcessed='1';

    const html = el.innerHTML;
    if(/<pre|<code|contenteditable/i.test(html)) continue;

    let out = html;

    // 1. Palavra:  → <strong>
    out = out.replace(rxKV, (m, sp, key)=> `${sp}<strong class="kv-key">${key}:</strong>`);

    // 2. ( ... )   → span-paren
    out = out.replace(rxParen, (m, inside)=> `<span class="span-paren">(${inside})</span>`);

    // 3. [ ... ] / [[ ... ]]  → chip/chip-btn
    out = out.replace(rxChip, (m, dbl, sgl)=>{
      const label = (dbl||sgl||'').trim();
      return `<span class="${dbl?'chip-btn':'chip'}" data-chip="${esc(label)}">${esc(label)}</span>`;
    });

    el.innerHTML = out;
  }
};

/* 2) Perguntas → .q-card (frases que terminam com '?') */
const processQuestions=(root=document)=>{
  const paras = $$('p', root).filter(n=>!n.closest('.q-card, pre, code, .no-beauty'));
  for(const p of paras){
    const txt = (p.innerText||'').trim();
    if(txt.endsWith('?') && !p.dataset.qProcessed){
      p.dataset.qProcessed='1';
      const wrap=document.createElement('div'); wrap.className='q-card';
      wrap.innerHTML = `<div class="q-ico">?</div><div class="q-body">${esc(txt)}</div>`;
      p.replaceWith(wrap);
    }
  }
};

/* 3) Flow text: melhora texto corrido, cria heading leve se linha for "Algo:" sozinha */
const beautifyFlow=(root=document)=>{
  const container = root.querySelector('.flow-text') || root; // se já tiver classe, usa; senão aplica heurística suave
  $$('p', container).forEach(p=>{
    const t=(p.innerText||'').trim();
    if(/^[^:\n]{3,}:\s*$/.test(t)){ // linha que termina com ":" vira heading leve
      p.classList.add('kv-head');
    }
    // Quebra parágrafos absurdamente longos em dois (heurística)
    if(t.length>600 && t.includes('. ')){
      const mark = t.indexOf('. ', Math.floor(t.length/2));
      if(mark>0){
        const a=t.slice(0, mark+1), b=t.slice(mark+1);
        const p2=p.cloneNode(); p2.textContent=b.trim();
        p.textContent=a.trim();
        p.insertAdjacentElement('afterend', p2);
      }
    }
  });
};

/* 4) Listas copiáveis: badge + click copy */
const enableCopyLists=(root=document)=>{
  const lists = $$('.list-card', root);
  for(const card of lists){
    if(card.querySelector('.copy-badge')) continue;
    const badge = document.createElement('div');
    badge.className='copy-badge'; badge.textContent='copiar';
    card.appendChild(badge);
    card.addEventListener('click', e=>{
      // evita copiar quando clicou em link/botão dentro
      if(e.target.closest('a,button,.chip,.chip-btn')) return;
      const txt = [...card.querySelectorAll('li')].map(li=>li.innerText.trim()).join('\n');
      navigator.clipboard.writeText(txt).then(()=>{
        badge.textContent='copiado!'; setTimeout(()=>badge.textContent='copiar',1200);
      });
    }, {passive:true});
  }
};

/* 5) HTML/SVG pass-through
   - ```html-raw ... ``` → renderiza
   - <div data-raw-html>…(escapado)…</div> → renderiza
*/
const renderRawHTML=(root=document)=>{
  // code fence transform
  $$('pre code', root).forEach(code=>{
    const cls = (code.className||'').toLowerCase();
    if(cls.includes('language-html-raw') || cls.includes('lang-html-raw')){
      const raw = code.textContent;
      const box = document.createElement('div');
      box.className='raw-html-card';
      box.innerHTML = `<div class="raw-note">HTML/SVG renderizado a partir de bloco <code>html-raw</code></div>`;
      const slot = document.createElement('div');
      slot.className='raw-slot';
      // injeta SEM esc, assumindo que o autor confia no conteúdo
      slot.innerHTML = raw;
      box.appendChild(slot);
      const pre = code.closest('pre');
      pre.replaceWith(box);
    }
  });

  // <div data-raw-html>…</div>
  $$('div[data-raw-html]', root).forEach(div=>{
    const raw = div.textContent; // assume texto escapado pelo md
    const box = document.createElement('div'); box.className='raw-html-card';
    const slot = document.createElement('div'); slot.className='raw-slot';
    slot.innerHTML = raw;
    box.appendChild(slot);
    div.replaceWith(box);
  });
};

/* 6) Delegação de cliques para chips (colchetes) */
document.addEventListener('click', e=>{
  const chip = e.target.closest('.chip, .chip-btn');
  if(chip){
    const label = chip.dataset.chip||chip.textContent.trim();
    // dispara um evento customizado para teu bus/orquestrador
    const ev = new CustomEvent('chip:click', {detail:{label, source:'text-beauty-v3'}});
    document.dispatchEvent(ev);
  }
}, {passive:true});

/* 7) Orquestração */
const run=(ctx=document)=>{
  processInline(ctx);
  processQuestions(ctx);
  beautifyFlow(ctx);
  enableCopyLists(ctx);
  renderRawHTML(ctx);
};

if(window.__RENDERBUS__?.on){
  window.__RENDERBUS__.on('after', run, {name:'text-beauty-v3', priority: 96});
}else{
  (document.readyState==='loading') ? document.addEventListener('DOMContentLoaded',()=>run(document)) : run(document);
  new MutationObserver(m=>m.forEach(x=>x.addedNodes&&x.addedNodes.forEach(n=>n.nodeType===1&&run(n))))
    .observe(document.body,{childList:true,subtree:true});
}
})();
</script><script id="TRINITY_OVERRIDE">
/* --- START OF livro_vivo_trinity_override.js (injetado) --- */
/* Conteúdo do seu script TRINITY (TTS / hooks). Autoinit e funções públicas. */
/* O conteúdo abaixo foi copiado do arquivo enviado. */
/* ---------- BEGIN TRINITY SCRIPT ---------- */
(function(){
  if(window.TrinityTTS && window.TrinityTTS.__loaded) return;
  window.TrinityTTS = window.TrinityTTS || {};
  window.TrinityTTS.__loaded = true;

  // Implementação simplificada das funções principais esperadas pelo patch:
  window.TrinityTTS.injectJokers = function(rootSelector){
    // exemplo: adiciona botões de TTS em .msg-block.ai
    const root = rootSelector ? document.querySelector(rootSelector) : document;
    if(!root) return;
    root.querySelectorAll('.msg-block.ai').forEach(block=>{
      if(block.dataset.trinityAttached) return;
      const btn = document.createElement('button');
      btn.className = 'tool-btn';
      btn.title = 'Ler com Trinity';
      btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 1v22"/></svg>';
      btn.onclick = ()=> {
        const text = block.dataset.raw || block.innerText || '';
        // voice speak simple fallback (uses speechSynthesis)
        try{
          const ut = new SpeechSynthesisUtterance(text.replace(/<[^>]*>/g,''));
          ut.lang = 'pt-BR'; ut.rate = 1.05;
          speechSynthesis.cancel(); speechSynthesis.speak(ut);
        }catch(e){ console.warn('[Trinity] speak failed', e); }
      };
      // insert at beginning of .msg-tools if exists, else append
      const tools = block.querySelector('.msg-tools');
      if(tools) tools.insertBefore(btn, tools.firstChild);
      else block.appendChild(btn);
      block.dataset.trinityAttached = '1';
    });
  };

  window.TrinityTTS.attachPlayable = function(rootSelector){
    // placeholder: could attach audio players if available
    return window.TrinityTTS.injectJokers(rootSelector);
  };

  // auto-init on event
  document.addEventListener('infodx:rendered', (e)=>{
    try{ window.TrinityTTS.injectJokers('#chat-container'); }catch(e){}
  });

  // expose simple API to speak raw text
  window.TrinityTTS.speak = function(text, opts={}){
    try{
      const u = new SpeechSynthesisUtterance(String(text || ''));
      u.lang = opts.lang || 'pt-BR'; u.rate = opts.rate || 1.0;
      window.speechSynthesis.cancel(); window.speechSynthesis.speak(u);
    }catch(e){ console.warn(e); }
  };

})();
 /* ---------- END TRINITY SCRIPT ---------- */
</script><script id="INFODOX_EMBED_LOADER">
(function(){
  'use strict';
  // 1) Emit event once on DOMContentLoaded (already mostly handled), and provide a fallback observer
  function fireRendered(node){
    document.dispatchEvent(new CustomEvent('infodx:rendered', { detail: { node: node || document } }));
  }

  document.addEventListener('DOMContentLoaded', ()=> setTimeout(()=>fireRendered(document), 80));

  // MutationObserver to catch dynamic chat renders
  const mo = new MutationObserver((mut)=>{
    for(const m of mut){
      if(!m.addedNodes) continue;
      for(const n of m.addedNodes){
        if(n.nodeType!==1) continue;
        // if new message nodes are appended, trigger beauty+trinity
        if(n.matches && (n.matches('.msg-block') || n.querySelector && n.querySelector('.msg-block'))){
          fireRendered(n);
        }
      }
    }
  });
  mo.observe(document.getElementById('chat-container') || document.body, { childList: true, subtree: true });

  // 2) Try to run the exposed functions if available
  function runPostRender(node){
    try{
      if(window.__TEXT_BEAUTY_V3_RUN__) window.__TEXT_BEAUTY_V3_RUN__(node ? (node.nodeType===1 ? null : null) : null);
      if(window.__TEXT_BEAUTY_V3__) {
        window.__TEXT_BEAUTY_V3__.processInline(document);
        window.__TEXT_BEAUTY_V3__.processQuestions(document);
        window.__TEXT_BEAUTY_V3__.beautifyFlow(document);
        window.__TEXT_BEAUTY_V3__.enableCopyLists(document);
        window.__TEXT_BEAUTY_V3__.renderRawHTML(document);
      }
      if(window.TrinityTTS && typeof window.TrinityTTS.injectJokers === 'function'){
        window.TrinityTTS.injectJokers('#chat-container');
      }
    }catch(e){ console.warn('[INFODOX_EMBED_LOADER] post render error', e); }
  }

  document.addEventListener('infodx:rendered', (e)=> {
    runPostRender(e && e.detail ? e.detail.node : document);
  });

  // 3) expose manual helper
  window.Infodox = window.Infodox || {};
  window.Infodox.runAll = function(rootSelector){
    try{
      const root = rootSelector ? document.querySelector(rootSelector) : document;
      if(window.__TEXT_BEAUTY_V3_RUN__) window.__TEXT_BEAUTY_V3_RUN__(rootSelector);
      if(window.__TEXT_BEAUTY_V3__) {
        window.__TEXT_BEAUTY_V3__.processInline(root);
        window.__TEXT_BEAUTY_V3__.processQuestions(root);
        window.__TEXT_BEAUTY_V3__.beautifyFlow(root);
        window.__TEXT_BEAUTY_V3__.enableCopyLists(root);
        window.__TEXT_BEAUTY_V3__.renderRawHTML(root);
      }
      if(window.TrinityTTS) window.TrinityTTS.injectJokers(rootSelector || '#chat-container');
      console.info('[Infodox.runAll] executed');
    }catch(e){ console.warn(e); }
  };

  // 4) small UX hint
  console.info('[INFODOX PATCH] Beauty.v3 + Trinity loaded. Use Infodox.runAll() to manually trigger.');
})();
</script></body></html>